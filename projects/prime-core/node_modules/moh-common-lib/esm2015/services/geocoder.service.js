/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
import { Injectable } from '@angular/core';
import { AbstractHttpService } from './abstract-api-service';
import { HttpClient, HttpHeaders, HttpParams } from '@angular/common/http';
import { map } from 'rxjs/operators';
import { throwError } from 'rxjs';
import * as i0 from "@angular/core";
import * as i1 from "@angular/common/http";
/**
 * @record
 */
export function GeoAddressResult() { }
if (false) {
    /**
     * String from the API that includes street, city, province, and country.
     * @type {?}
     */
    GeoAddressResult.prototype.fullAddress;
    /** @type {?} */
    GeoAddressResult.prototype.city;
    /** @type {?} */
    GeoAddressResult.prototype.street;
    /** @type {?} */
    GeoAddressResult.prototype.country;
    /** @type {?} */
    GeoAddressResult.prototype.province;
}
export class GeocoderService extends AbstractHttpService {
    /**
     * @param {?} http
     */
    constructor(http) {
        super(http);
        this.http = http;
        this._headers = new HttpHeaders();
        this.BASE_URL = 'https://geocoder.api.gov.bc.ca';
        this.ADDRESS_URL = `${this.BASE_URL}/addresses.json?`;
        /**
         * Defaults for service
         */
        this.defaultCountry = 'Canada';
        this.defaultProv = 'British Columbia';
    }
    // https://geocoder.api.gov.bc.ca/addresses.json?minScore=50&maxResults=5&echo=false&brief=true&autoComplete=true&addressString=784+Hock
    /**
     * @param {?} address
     * @return {?}
     */
    lookup(address) {
        /** @type {?} */
        const params = new HttpParams()
            .set('minScore', '50')
            .set('maxResults', '10')
            .set('echo', 'false')
            .set('brief', 'false') // API splits address string up into sub-attributes, like city  / street name
            .set('autoComplete', 'true')
            .set('matchPrecisionNot', 'LOCALITY,STREET,BLOCK,INTERSECTION')
            .set('addressString', address);
        return this.get(this.ADDRESS_URL, params).pipe(map(this.processResponse));
    }
    /**
     * Formats the response from ADDRESS_URL, trimming irrelevant fields.
     *
     * This works for other requests for the same API too, however it may error
     * out on some items if matchPrecisionNot is not set.
     *
     * @private
     * @param {?} obj The response from ADDRESS_URL
     * @return {?}
     */
    processResponse(obj) {
        return obj.features.map((/**
         * @param {?} feature
         * @return {?}
         */
        feature => {
            /** @type {?} */
            const props = feature.properties;
            /** @type {?} */
            const city = props.localityName;
            // We get street just by trimming everything before city, more
            // stable than looking for commas, etc.
            /** @type {?} */
            const cityIndex = props.fullAddress.indexOf(`, ${city}`);
            /** @type {?} */
            const street = props.fullAddress.slice(0, cityIndex);
            return {
                fullAddress: props.fullAddress,
                city,
                street,
                country: this.defaultCountry,
                // Default to Canada
                province: this.defaultProv // Default to BC
            };
        }));
    }
    /**
     * @protected
     * @param {?} error
     * @return {?}
     */
    handleError(error) {
        console.error('GeoCoder network error', { error });
        return throwError('Geocoder error');
    }
}
GeocoderService.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root'
            },] }
];
/** @nocollapse */
GeocoderService.ctorParameters = () => [
    { type: HttpClient }
];
/** @nocollapse */ GeocoderService.ngInjectableDef = i0.defineInjectable({ factory: function GeocoderService_Factory() { return new GeocoderService(i0.inject(i1.HttpClient)); }, token: GeocoderService, providedIn: "root" });
if (false) {
    /**
     * @type {?}
     * @protected
     */
    GeocoderService.prototype._headers;
    /**
     * @type {?}
     * @private
     */
    GeocoderService.prototype.BASE_URL;
    /**
     * @type {?}
     * @private
     */
    GeocoderService.prototype.ADDRESS_URL;
    /**
     * Defaults for service
     * @type {?}
     */
    GeocoderService.prototype.defaultCountry;
    /** @type {?} */
    GeocoderService.prototype.defaultProv;
    /**
     * @type {?}
     * @protected
     */
    GeocoderService.prototype.http;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZ2VvY29kZXIuc2VydmljZS5qcyIsInNvdXJjZVJvb3QiOiJuZzovL21vaC1jb21tb24tbGliL3NlcnZpY2VzLyIsInNvdXJjZXMiOlsiZ2VvY29kZXIuc2VydmljZS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7O0FBQUEsT0FBTyxFQUFFLFVBQVUsRUFBRSxNQUFNLGVBQWUsQ0FBQztBQUMzQyxPQUFPLEVBQUUsbUJBQW1CLEVBQUUsTUFBTSx3QkFBd0IsQ0FBQztBQUM3RCxPQUFPLEVBQUUsVUFBVSxFQUFFLFdBQVcsRUFBcUIsVUFBVSxFQUFFLE1BQU0sc0JBQXNCLENBQUM7QUFDOUYsT0FBTyxFQUFFLEdBQUcsRUFBRSxNQUFNLGdCQUFnQixDQUFDO0FBQ3JDLE9BQU8sRUFBYyxVQUFVLEVBQUUsTUFBTSxNQUFNLENBQUM7Ozs7OztBQUU5QyxzQ0FRQzs7Ozs7O0lBTkcsdUNBQW9COztJQUNwQixnQ0FBYTs7SUFDYixrQ0FBZTs7SUFFZixtQ0FBZ0I7O0lBQ2hCLG9DQUFpQjs7QUFNckIsTUFBTSxPQUFPLGVBQWdCLFNBQVEsbUJBQW1COzs7O0lBV3BELFlBQXNCLElBQWdCO1FBQ2xDLEtBQUssQ0FBQyxJQUFJLENBQUMsQ0FBQztRQURNLFNBQUksR0FBSixJQUFJLENBQVk7UUFUNUIsYUFBUSxHQUFnQixJQUFJLFdBQVcsRUFBRSxDQUFDO1FBQzVDLGFBQVEsR0FBRyxnQ0FBZ0MsQ0FBQztRQUM1QyxnQkFBVyxHQUFHLEdBQUcsSUFBSSxDQUFDLFFBQVEsa0JBQWtCLENBQUM7Ozs7UUFJbEQsbUJBQWMsR0FBVyxRQUFRLENBQUM7UUFDbEMsZ0JBQVcsR0FBVyxrQkFBa0IsQ0FBQztJQUloRCxDQUFDOzs7Ozs7SUFJRCxNQUFNLENBQUMsT0FBZTs7Y0FDWixNQUFNLEdBQUcsSUFBSSxVQUFVLEVBQUU7YUFDMUIsR0FBRyxDQUFDLFVBQVUsRUFBRSxJQUFJLENBQUM7YUFDckIsR0FBRyxDQUFDLFlBQVksRUFBRSxJQUFJLENBQUM7YUFDdkIsR0FBRyxDQUFDLE1BQU0sRUFBRSxPQUFPLENBQUM7YUFDcEIsR0FBRyxDQUFDLE9BQU8sRUFBRSxPQUFPLENBQUMsQ0FBQyw2RUFBNkU7YUFDbkcsR0FBRyxDQUFDLGNBQWMsRUFBRSxNQUFNLENBQUM7YUFDM0IsR0FBRyxDQUFDLG1CQUFtQixFQUFFLG9DQUFvQyxDQUFDO2FBQzlELEdBQUcsQ0FBQyxlQUFlLEVBQUUsT0FBTyxDQUFDO1FBRWxDLE9BQU8sSUFBSSxDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUMsV0FBVyxFQUFFLE1BQU0sQ0FBQyxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLGVBQWUsQ0FBQyxDQUFDLENBQUM7SUFDOUUsQ0FBQzs7Ozs7Ozs7Ozs7SUFVTyxlQUFlLENBQUMsR0FBRztRQUN2QixPQUFPLEdBQUcsQ0FBQyxRQUFRLENBQUMsR0FBRzs7OztRQUFDLE9BQU8sQ0FBQyxFQUFFOztrQkFDeEIsS0FBSyxHQUFHLE9BQU8sQ0FBQyxVQUFVOztrQkFDMUIsSUFBSSxHQUFHLEtBQUssQ0FBQyxZQUFZOzs7O2tCQUd6QixTQUFTLEdBQUcsS0FBSyxDQUFDLFdBQVcsQ0FBQyxPQUFPLENBQUMsS0FBSyxJQUFJLEVBQUUsQ0FBQzs7a0JBQ2xELE1BQU0sR0FBRyxLQUFLLENBQUMsV0FBVyxDQUFDLEtBQUssQ0FBQyxDQUFDLEVBQUUsU0FBUyxDQUFDO1lBQ3BELE9BQU87Z0JBQ0gsV0FBVyxFQUFFLEtBQUssQ0FBQyxXQUFXO2dCQUM5QixJQUFJO2dCQUNKLE1BQU07Z0JBQ04sT0FBTyxFQUFFLElBQUksQ0FBQyxjQUFjOztnQkFDNUIsUUFBUSxFQUFFLElBQUksQ0FBQyxXQUFXLENBQUksZ0JBQWdCO2FBQ2pELENBQUM7UUFDTixDQUFDLEVBQUMsQ0FBQztJQUNQLENBQUM7Ozs7OztJQUVTLFdBQVcsQ0FBQyxLQUF3QjtRQUMxQyxPQUFPLENBQUMsS0FBSyxDQUFDLHdCQUF3QixFQUFFLEVBQUUsS0FBSyxFQUFFLENBQUMsQ0FBQztRQUNuRCxPQUFPLFVBQVUsQ0FBQyxnQkFBZ0IsQ0FBQyxDQUFDO0lBQ3hDLENBQUM7OztZQTlESixVQUFVLFNBQUM7Z0JBQ1IsVUFBVSxFQUFFLE1BQU07YUFDckI7Ozs7WUFoQlEsVUFBVTs7Ozs7Ozs7SUFtQmYsbUNBQW9EOzs7OztJQUNwRCxtQ0FBb0Q7Ozs7O0lBQ3BELHNDQUF5RDs7Ozs7SUFJekQseUNBQXlDOztJQUN6QyxzQ0FBZ0Q7Ozs7O0lBRXBDLCtCQUEwQiIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEluamVjdGFibGUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IEFic3RyYWN0SHR0cFNlcnZpY2UgfSBmcm9tICcuL2Fic3RyYWN0LWFwaS1zZXJ2aWNlJztcbmltcG9ydCB7IEh0dHBDbGllbnQsIEh0dHBIZWFkZXJzLCBIdHRwRXJyb3JSZXNwb25zZSwgSHR0cFBhcmFtcyB9IGZyb20gJ0Bhbmd1bGFyL2NvbW1vbi9odHRwJztcbmltcG9ydCB7IG1hcCB9IGZyb20gJ3J4anMvb3BlcmF0b3JzJztcbmltcG9ydCB7IE9ic2VydmFibGUsIHRocm93RXJyb3IgfSBmcm9tICdyeGpzJztcblxuZXhwb3J0IGludGVyZmFjZSBHZW9BZGRyZXNzUmVzdWx0IHtcbiAgICAvKiogU3RyaW5nIGZyb20gdGhlIEFQSSB0aGF0IGluY2x1ZGVzIHN0cmVldCwgY2l0eSwgcHJvdmluY2UsIGFuZCBjb3VudHJ5LiAqL1xuICAgIGZ1bGxBZGRyZXNzOiBzdHJpbmc7XG4gICAgY2l0eTogc3RyaW5nO1xuICAgIHN0cmVldDogc3RyaW5nO1xuICAgIC8vIFNldCB0byBkZWZhdWx0cyBpbiByZXNwb25zZVxuICAgIGNvdW50cnk6IHN0cmluZztcbiAgICBwcm92aW5jZTogc3RyaW5nO1xufVxuXG5ASW5qZWN0YWJsZSh7XG4gICAgcHJvdmlkZWRJbjogJ3Jvb3QnXG59KVxuZXhwb3J0IGNsYXNzIEdlb2NvZGVyU2VydmljZSBleHRlbmRzIEFic3RyYWN0SHR0cFNlcnZpY2Uge1xuXG4gICAgcHJvdGVjdGVkIF9oZWFkZXJzOiBIdHRwSGVhZGVycyA9IG5ldyBIdHRwSGVhZGVycygpO1xuICAgIHByaXZhdGUgQkFTRV9VUkwgPSAnaHR0cHM6Ly9nZW9jb2Rlci5hcGkuZ292LmJjLmNhJztcbiAgICBwcml2YXRlIEFERFJFU1NfVVJMID0gYCR7dGhpcy5CQVNFX1VSTH0vYWRkcmVzc2VzLmpzb24/YDtcblxuXG4gICAgLyoqIERlZmF1bHRzIGZvciBzZXJ2aWNlICovXG4gICAgcHVibGljIGRlZmF1bHRDb3VudHJ5OiBzdHJpbmcgPSAnQ2FuYWRhJztcbiAgICBwdWJsaWMgZGVmYXVsdFByb3Y6IHN0cmluZyA9ICdCcml0aXNoIENvbHVtYmlhJztcblxuICAgIGNvbnN0cnVjdG9yKHByb3RlY3RlZCBodHRwOiBIdHRwQ2xpZW50KSB7XG4gICAgICAgIHN1cGVyKGh0dHApO1xuICAgIH1cblxuXG4gICAgLy8gaHR0cHM6Ly9nZW9jb2Rlci5hcGkuZ292LmJjLmNhL2FkZHJlc3Nlcy5qc29uP21pblNjb3JlPTUwJm1heFJlc3VsdHM9NSZlY2hvPWZhbHNlJmJyaWVmPXRydWUmYXV0b0NvbXBsZXRlPXRydWUmYWRkcmVzc1N0cmluZz03ODQrSG9ja1xuICAgIGxvb2t1cChhZGRyZXNzOiBzdHJpbmcpOiBPYnNlcnZhYmxlPEdlb0FkZHJlc3NSZXN1bHRbXT4ge1xuICAgICAgICBjb25zdCBwYXJhbXMgPSBuZXcgSHR0cFBhcmFtcygpXG4gICAgICAgICAgICAuc2V0KCdtaW5TY29yZScsICc1MCcpXG4gICAgICAgICAgICAuc2V0KCdtYXhSZXN1bHRzJywgJzEwJylcbiAgICAgICAgICAgIC5zZXQoJ2VjaG8nLCAnZmFsc2UnKVxuICAgICAgICAgICAgLnNldCgnYnJpZWYnLCAnZmFsc2UnKSAvLyBBUEkgc3BsaXRzIGFkZHJlc3Mgc3RyaW5nIHVwIGludG8gc3ViLWF0dHJpYnV0ZXMsIGxpa2UgY2l0eSAgLyBzdHJlZXQgbmFtZVxuICAgICAgICAgICAgLnNldCgnYXV0b0NvbXBsZXRlJywgJ3RydWUnKVxuICAgICAgICAgICAgLnNldCgnbWF0Y2hQcmVjaXNpb25Ob3QnLCAnTE9DQUxJVFksU1RSRUVULEJMT0NLLElOVEVSU0VDVElPTicpXG4gICAgICAgICAgICAuc2V0KCdhZGRyZXNzU3RyaW5nJywgYWRkcmVzcyk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0KHRoaXMuQUREUkVTU19VUkwsIHBhcmFtcykucGlwZShtYXAodGhpcy5wcm9jZXNzUmVzcG9uc2UpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBGb3JtYXRzIHRoZSByZXNwb25zZSBmcm9tIEFERFJFU1NfVVJMLCB0cmltbWluZyBpcnJlbGV2YW50IGZpZWxkcy5cbiAgICAgKlxuICAgICAqIFRoaXMgd29ya3MgZm9yIG90aGVyIHJlcXVlc3RzIGZvciB0aGUgc2FtZSBBUEkgdG9vLCBob3dldmVyIGl0IG1heSBlcnJvclxuICAgICAqIG91dCBvbiBzb21lIGl0ZW1zIGlmIG1hdGNoUHJlY2lzaW9uTm90IGlzIG5vdCBzZXQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gb2JqIFRoZSByZXNwb25zZSBmcm9tIEFERFJFU1NfVVJMXG4gICAgICovXG4gICAgcHJpdmF0ZSBwcm9jZXNzUmVzcG9uc2Uob2JqKTogR2VvQWRkcmVzc1Jlc3VsdFtdIHtcbiAgICAgICAgcmV0dXJuIG9iai5mZWF0dXJlcy5tYXAoZmVhdHVyZSA9PiB7XG4gICAgICAgICAgICBjb25zdCBwcm9wcyA9IGZlYXR1cmUucHJvcGVydGllcztcbiAgICAgICAgICAgIGNvbnN0IGNpdHkgPSBwcm9wcy5sb2NhbGl0eU5hbWU7XG4gICAgICAgICAgICAvLyBXZSBnZXQgc3RyZWV0IGp1c3QgYnkgdHJpbW1pbmcgZXZlcnl0aGluZyBiZWZvcmUgY2l0eSwgbW9yZVxuICAgICAgICAgICAgLy8gc3RhYmxlIHRoYW4gbG9va2luZyBmb3IgY29tbWFzLCBldGMuXG4gICAgICAgICAgICBjb25zdCBjaXR5SW5kZXggPSBwcm9wcy5mdWxsQWRkcmVzcy5pbmRleE9mKGAsICR7Y2l0eX1gKTtcbiAgICAgICAgICAgIGNvbnN0IHN0cmVldCA9IHByb3BzLmZ1bGxBZGRyZXNzLnNsaWNlKDAsIGNpdHlJbmRleCk7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGZ1bGxBZGRyZXNzOiBwcm9wcy5mdWxsQWRkcmVzcyxcbiAgICAgICAgICAgICAgICBjaXR5LFxuICAgICAgICAgICAgICAgIHN0cmVldCxcbiAgICAgICAgICAgICAgICBjb3VudHJ5OiB0aGlzLmRlZmF1bHRDb3VudHJ5LCAvLyBEZWZhdWx0IHRvIENhbmFkYVxuICAgICAgICAgICAgICAgIHByb3ZpbmNlOiB0aGlzLmRlZmF1bHRQcm92ICAgIC8vIERlZmF1bHQgdG8gQkNcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIHByb3RlY3RlZCBoYW5kbGVFcnJvcihlcnJvcjogSHR0cEVycm9yUmVzcG9uc2UpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcignR2VvQ29kZXIgbmV0d29yayBlcnJvcicsIHsgZXJyb3IgfSk7XG4gICAgICAgIHJldHVybiB0aHJvd0Vycm9yKCdHZW9jb2RlciBlcnJvcicpO1xuICAgIH1cbn1cbiJdfQ==