/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
import { Component, Input, Output, EventEmitter, ViewChild, forwardRef } from '@angular/core';
import { NgxMyDatePickerDirective } from 'ngx-mydatepicker';
import * as moment_ from 'moment';
import { NgForm, ControlContainer, NG_VALUE_ACCESSOR } from '@angular/forms';
/** @type {?} */
const moment = moment_;
/**
 * PRIME datepicker component. Largely a wrapper for ngx-mydatepicker
 * https://github.com/kekeh/ngx-mydatepicker
 *
 * NOTE - YOU MUST INCLUDE NGX-MYDATEPICKER IN YOUR PARENT APPLICATION TO USE
 * THIS COMPONENT!  This is due to some poor implementation in ngx-mydatepicker.
 * Make sure to use the same version that this library uses.
 */
export class DatepickerComponent {
    constructor() {
        /**
         * Component size can be reduced, see Datepickersizes for options
         */
        this.size = DatepickerSizes.DEFAULT;
        this.dateChange = new EventEmitter();
        this.required = false;
        /**
         * Control visibility of the clear 'x' button on the mini datepicker.
         *
         * **'visible'** is default, button exists
         *
         * **'none'** means the element does not exist
         *
         * **'invisible'** means the element takes up space but is not visible / cannot be
         * used.
         *
         * Invisible is useful when you want to make sure a datepicker is the same
         * size as a visible one.
         */
        this.clearButton = 'visible';
        /**
         * Format for how to display the date to the user.
         */
        this.dateFormat = 'yyyy/mm/dd';
        // Make enum accessible in HTML
        this.DatepickerSizes = DatepickerSizes;
        this._onChange = (/**
         * @param {?} _
         * @return {?}
         */
        (_) => { });
        this._onTouched = (/**
         * @return {?}
         */
        () => { });
    }
    /**
     * @param {?} date
     * @return {?}
     */
    convertDateToSimpleDate(date) {
        if (date === null || date === undefined) {
            return null;
        }
        return {
            year: date.getFullYear(),
            month: date.getMonth() + 1,
            day: date.getDate(),
        };
    }
    /**
     * @param {?} date
     * @return {?}
     */
    convertSimpleDateToDate(date) {
        // When ngx-mydatepicker is cleared, it returns {year: 0, month: 0, day: 0}
        if (date.year === 0) {
            return null;
        }
        return new Date(date.year, date.month - 1, date.day);
    }
    /**
     * @param {?} x
     * @return {?}
     */
    isDate(x) {
        if (!x) {
            return false;
        }
        return x.getDate !== undefined;
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        if (!this.errorMessages) {
            this.errorMessages = {
                required: this.labelText + ' is required.',
                dayOutOfRange: 'Invalid ' + this.labelText + '.',
                yearDistantPast: 'Invalid ' + this.labelText + '.',
                yearDistantFuture: 'Invalid ' + this.labelText + '.',
                noFutureDatesAllowed: 'Invalid ' + this.labelText + '.',
                invalidValue: 'Invalid ' + this.labelText + '.'
            };
        }
        this.datepickerOptions = {
            dateFormat: this.dateFormat,
            sunHighlight: false,
            appendSelectorToBody: true,
        };
        if (this.size === DatepickerSizes.MINI) {
            // Set width/height to 4/5 of default
            this.datepickerOptions.selectorHeight = '185px';
            this.datepickerOptions.selectorWidth = '201px';
        }
        if (this.isDate(this.disableSince)) {
            this.datepickerOptions.disableSince = this.convertDateToSimpleDate(this.disableSince);
        }
        if (this.isDate(this.disableUntil)) {
            this.datepickerOptions.disableUntil = this.convertDateToSimpleDate(this.disableSince);
        }
        if (this.onlyFutureDates) {
            /** @type {?} */
            const today = new Date();
            this.datepickerOptions.disableUntil = this.convertDateToSimpleDate(today);
        }
        console.log('Datepicker ngOnInit', this.date);
        if (this.date) {
            // Even if jsdate winds up being undefined, even defining this.model will
            // set the input as non-empty and it'll satisfy the 'required' validation.
            // So, we only add the model if there's actual data.
            this.model = {
                jsdate: this.date
            };
        }
    }
    /**
     * @param {?} changes
     * @return {?}
     */
    ngOnChanges(changes) {
        // Parent component has passed in null, so we have to manually clear the input. This leads to 2 change detection cycles.
        // We could refactor it down to one, but the performance hit is minimal for such a simple component.
        if (this.date === null) {
            this.clearDate();
            this._onChange(null);
            this._onTouched();
        }
    }
    /**
     * @param {?} event
     * @return {?}
     */
    onDateChanged(event) {
        if (event.jsdate || event.jsdate === null) {
            // Always emit a Date (or null)
            this.dateChange.emit(event.jsdate);
            this._onChange(event.jsdate);
            this._onTouched();
        }
    }
    /**
     * @return {?}
     */
    clearDate() {
        if (this.ngxdp) {
            // We don't need to emit here, because by changing date we'll trigger onDateChanged automatically.
            this.date = null;
            this.ngxdp.clearDate();
        }
    }
    /**
     * @param {?} fn
     * @return {?}
     */
    registerOnChange(fn) {
        this._onChange = fn;
    }
    /**
     * @param {?} fn
     * @return {?}
     */
    registerOnTouched(fn) {
        this._onTouched = fn;
    }
    /**
     * @param {?} obj
     * @return {?}
     */
    writeValue(obj) {
        this.model = {
            jsdate: obj
        };
    }
}
DatepickerComponent.decorators = [
    { type: Component, args: [{
                selector: 'common-datepicker',
                template: "<div>\n    <label><span>{{labelText}}</span>\n        <div class=\"input-group\">\n            \n                <input class=\"form-control\" placeholder=\"YYYY/MM/DD\"\n                ngx-mydatepicker name=\"datepicker-{{labelText}}\"\n                [(ngModel)]=\"model\"\n                [options]=\"datepickerOptions\"\n                #dp=\"ngx-mydatepicker\"\n                #dateEl='ngModel'\n                (dateChanged)=\"onDateChanged($event)\"\n                [required]='required'\n                [disabled]=\"disabled\"/>\n\n            <span class=\"input-group-append float-label-append\">\n                <button type=\"button\" class=\"btn btn-default\" (click)=\"dp.toggleCalendar()\">\n                    <i class=\"fa fa-calendar\"></i>\n                </button>\n            </span>\n        </div>\n    </label>\n</div>\n\n<!-- InvalidDateFormat comes from ngxmydatepicker, so we have a little less control over it. -->\n<div *ngIf=\"!disabled && dateEl.touched\"\n    role=\"alert\"\n    class='error-container'\n    aria-live=\"assertive\">\n  <div class=\"text-danger\"\n       *ngIf=\"(dateEl?.errors?.required) && errorMessages?.required && !dateEl?.errors?.invalidDateFormat\">\n       {{errorMessages.required}}\n  </div>\n  <!-- ngx-mydatepicker has it's own errors and we can't easily add our own, so we have reduced error messages. -->\n  <!-- <div class=\"text-danger\"\n      *ngIf=\"dateEl?.errors?.dayOutOfRange && errorMessages?.dayOutOfRange\">\n       {{errorMessages.dayOutOfRange}}\n  </div>\n  <div class=\"text-danger\"\n       *ngIf=\"dateEl?.errors?.yearDistantPast && errorMessages?.yearDistantPast\">\n       {{errorMessages.yearDistantPast}}\n  </div>\n  <div class=\"text-danger\"\n       *ngIf=\"dateEl?.errors?.yearDistantFuture && errorMessages?.yearDistantFuture\">\n       {{errorMessages.yearDistantFuture}}\n  </div>\n  <div class=\"text-danger\"\n        *ngIf=\"dateEl?.errors?.noPastDatesAllowed && errorMessages?.noPastDatesAllowed\">\n        {{errorMessages.noPastDatesAllowed}}\n  </div>\n  \n  <div class=\"text-danger\"\n       *ngIf=\"dateEl?.errors?.noFutureDatesAllowed && errorMessages?.noFutureDatesAllowed\">\n       {{errorMessages.noFutureDatesAllowed}}\n  </div> -->\n  <div class=\"text-danger\"\n       *ngIf=\"(dateEl?.errors?.invalidValue || dateEl?.errors?.invalidDateFormat) && errorMessages?.invalidValue\">\n       {{errorMessages.invalidValue}}\n  </div>\n</div>",
                /* Re-use the same ngForm that it's parent is using. The component will show
                   * up in its parents `this.form`, and will auto-update `this.form.valid`
                   */
                viewProviders: [{ provide: ControlContainer, useExisting: forwardRef((/**
                         * @return {?}
                         */
                        () => NgForm)) }],
                providers: [
                    {
                        provide: NG_VALUE_ACCESSOR,
                        multi: true,
                        useExisting: forwardRef((/**
                         * @return {?}
                         */
                        () => DatepickerComponent))
                    }
                ],
                styles: [".datepicker--mini{display:flex;flex-wrap:nowrap}.datepicker--mini:not(.hide-clear)>.btn{border-top-right-radius:0;border-bottom-right-radius:0}.datepicker--mini .input-group-append .btn{padding:0 .5rem}.input-group-append{z-index:0}.float-label-append{margin-bottom:calc(.5rem + 2px)}.has-float-label{flex-basis:calc(100% - 36px)}"]
            }] }
];
/** @nocollapse */
DatepickerComponent.ctorParameters = () => [];
DatepickerComponent.propDecorators = {
    size: [{ type: Input }],
    date: [{ type: Input }],
    dateChange: [{ type: Output }],
    disabled: [{ type: Input }],
    labelText: [{ type: Input }],
    required: [{ type: Input }],
    disableUntil: [{ type: Input }],
    disableSince: [{ type: Input }],
    onlyFutureDates: [{ type: Input }],
    clearButton: [{ type: Input }],
    dateFormat: [{ type: Input }],
    errorMessages: [{ type: Input }],
    ngxdp: [{ type: ViewChild, args: ['dp',] }]
};
if (false) {
    /**
     * Component size can be reduced, see Datepickersizes for options
     * @type {?}
     */
    DatepickerComponent.prototype.size;
    /** @type {?} */
    DatepickerComponent.prototype.date;
    /** @type {?} */
    DatepickerComponent.prototype.dateChange;
    /** @type {?} */
    DatepickerComponent.prototype.disabled;
    /** @type {?} */
    DatepickerComponent.prototype.labelText;
    /** @type {?} */
    DatepickerComponent.prototype.required;
    /**
     * Dates **before** disableUntil will not be valid selections.  Maps to a ngx-mydatepicker option, but we convert IMyDate to Date
     * @type {?}
     */
    DatepickerComponent.prototype.disableUntil;
    /**
     * Dates **after** disableSince will not be valid selections.  Maps to a ngx-mydatepicker option, but we convert IMyDate to Date
     * @type {?}
     */
    DatepickerComponent.prototype.disableSince;
    /**
     * Equivalent to setting disableBefore to tomorrow.
     * @type {?}
     */
    DatepickerComponent.prototype.onlyFutureDates;
    /**
     * Control visibility of the clear 'x' button on the mini datepicker.
     *
     * **'visible'** is default, button exists
     *
     * **'none'** means the element does not exist
     *
     * **'invisible'** means the element takes up space but is not visible / cannot be
     * used.
     *
     * Invisible is useful when you want to make sure a datepicker is the same
     * size as a visible one.
     * @type {?}
     */
    DatepickerComponent.prototype.clearButton;
    /**
     * Format for how to display the date to the user.
     * @type {?}
     */
    DatepickerComponent.prototype.dateFormat;
    /** @type {?} */
    DatepickerComponent.prototype.errorMessages;
    /**
     * Datetime model used to interface with ngx-datepicker.
     * @type {?}
     */
    DatepickerComponent.prototype.model;
    /** @type {?} */
    DatepickerComponent.prototype.DatepickerSizes;
    /** @type {?} */
    DatepickerComponent.prototype.ngxdp;
    /**
     * Default options for wrapped ngx-datepicker.
     * @type {?}
     */
    DatepickerComponent.prototype.datepickerOptions;
    /** @type {?} */
    DatepickerComponent.prototype._onChange;
    /** @type {?} */
    DatepickerComponent.prototype._onTouched;
}
/** @enum {string} */
const DatepickerSizes = {
    MINI: 'mini',
    DEFAULT: 'default',
};
export { DatepickerSizes };
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZGF0ZXBpY2tlci5jb21wb25lbnQuanMiLCJzb3VyY2VSb290Ijoibmc6Ly9tb2gtY29tbW9uLWxpYi8iLCJzb3VyY2VzIjpbImxpYi9jb21wb25lbnRzL2RhdGVwaWNrZXIvZGF0ZXBpY2tlci5jb21wb25lbnQudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7OztBQUFBLE9BQU8sRUFBRSxTQUFTLEVBQVUsS0FBSyxFQUFFLE1BQU0sRUFBRSxZQUFZLEVBQWlCLFNBQVMsRUFBYSxVQUFVLEVBQUUsTUFBTSxlQUFlLENBQUM7QUFDaEksT0FBTyxFQUE0Qix3QkFBd0IsRUFBRSxNQUFNLGtCQUFrQixDQUFDO0FBQ3RGLE9BQU8sS0FBSyxPQUFPLE1BQU0sUUFBUSxDQUFDO0FBQ2xDLE9BQU8sRUFBRSxNQUFNLEVBQUUsZ0JBQWdCLEVBQWUsaUJBQWlCLEVBQXdCLE1BQU0sZ0JBQWdCLENBQUM7O01BRTFHLE1BQU0sR0FBRyxPQUFPOzs7Ozs7Ozs7QUEyQnRCLE1BQU0sT0FBTyxtQkFBbUI7SUF5RDlCOzs7O1FBdkRTLFNBQUksR0FBb0IsZUFBZSxDQUFDLE9BQU8sQ0FBQztRQUUvQyxlQUFVLEdBQUcsSUFBSSxZQUFZLEVBQVEsQ0FBQztRQUl2QyxhQUFRLEdBQVksS0FBSyxDQUFDOzs7Ozs7Ozs7Ozs7OztRQXlCMUIsZ0JBQVcsR0FBcUMsU0FBUyxDQUFDOzs7O1FBSzFELGVBQVUsR0FBVyxZQUFZLENBQUM7O1FBUzNDLG9CQUFlLEdBQTJCLGVBQWUsQ0FBQztRQU9uRCxjQUFTOzs7O1FBQUcsQ0FBQyxDQUFNLEVBQUUsRUFBRSxHQUFFLENBQUMsRUFBQztRQUMzQixlQUFVOzs7UUFBRyxHQUFHLEVBQUUsR0FBRSxDQUFDLEVBQUM7SUFFYixDQUFDOzs7OztJQUVqQix1QkFBdUIsQ0FBQyxJQUFVO1FBQ2hDLElBQUksSUFBSSxLQUFLLElBQUksSUFBSSxJQUFJLEtBQUssU0FBUyxFQUFFO1lBQUUsT0FBTyxJQUFJLENBQUM7U0FBRTtRQUN6RCxPQUFPO1lB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N0IsbTZFQUEwQzs7OztnQkFLMUMsYUFBYSxFQUFFLENBQUUsRUFBRSxPQUFPLEVBQUUsZ0JBQWdCLEVBQUUsV0FBVyxFQUFFLFVBQVU7Ozt3QkFBQyxHQUFHLEVBQUUsQ0FBQyxNQUFNLEVBQUUsRUFBRSxDQUFFO2dCQUN4RixTQUFTLEVBQUU7b0JBQ1Q7d0JBQ0UsT0FBTyxFQUFFLGlCQUFpQjt3QkFDMUIsS0FBSyxFQUFFLElBQUk7d0JBQ1gsV0FBVyxFQUFFLFVBQVU7Ozt3QkFBQyxHQUFHLEVBQUUsQ0FBQyxtQkFBbUIsRUFBQztxQkFDbkQ7aUJBQ0Y7O2FBQ0Y7Ozs7O21CQUdFLEtBQUs7bUJBQ0wsS0FBSzt5QkFDTCxNQUFNO3VCQUNOLEtBQUs7d0JBQ0wsS0FBSzt1QkFFTCxLQUFLOzJCQUlMLEtBQUs7MkJBR0wsS0FBSzs4QkFHTCxLQUFLOzBCQWVMLEtBQUs7eUJBS0wsS0FBSzs0QkFFTCxLQUFLO29CQVNMLFNBQVMsU0FBQyxJQUFJOzs7Ozs7O0lBL0NmLG1DQUF5RDs7SUFDekQsbUNBQW9COztJQUNwQix5Q0FBZ0Q7O0lBQ2hELHVDQUEyQjs7SUFDM0Isd0NBQTJCOztJQUUzQix1Q0FBbUM7Ozs7O0lBSW5DLDJDQUE0Qjs7Ozs7SUFHNUIsMkNBQTRCOzs7OztJQUc1Qiw4Q0FBa0M7Ozs7Ozs7Ozs7Ozs7OztJQWVsQywwQ0FBbUU7Ozs7O0lBS25FLHlDQUEyQzs7SUFFM0MsNENBQXFDOzs7OztJQUlyQyxvQ0FBVzs7SUFHWCw4Q0FBMEQ7O0lBRTFELG9DQUFpRDs7Ozs7SUFHakQsZ0RBQW1DOztJQUVuQyx3Q0FBa0M7O0lBQ2xDLHlDQUE2Qjs7OztJQTBIN0IsTUFBTyxNQUFNO0lBQ2IsU0FBVSxTQUFTIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgQ29tcG9uZW50LCBPbkluaXQsIElucHV0LCBPdXRwdXQsIEV2ZW50RW1pdHRlciwgU2ltcGxlQ2hhbmdlcywgVmlld0NoaWxkLCBPbkNoYW5nZXMsIGZvcndhcmRSZWYgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IElOZ3hNeURwT3B0aW9ucywgSU15RGF0ZSwgTmd4TXlEYXRlUGlja2VyRGlyZWN0aXZlIH0gZnJvbSAnbmd4LW15ZGF0ZXBpY2tlcic7XG5pbXBvcnQgKiBhcyBtb21lbnRfIGZyb20gJ21vbWVudCc7XG5pbXBvcnQgeyBOZ0Zvcm0sIENvbnRyb2xDb250YWluZXIsIEZvcm1Db250cm9sLCBOR19WQUxVRV9BQ0NFU1NPUiwgQ29udHJvbFZhbHVlQWNjZXNzb3IgfSBmcm9tICdAYW5ndWxhci9mb3Jtcyc7XG5pbXBvcnQgeyBEYXRlRXJyb3JNc2cgfSBmcm9tICcuLi9kYXRlL2RhdGUuY29tcG9uZW50JztcbmNvbnN0IG1vbWVudCA9IG1vbWVudF87XG5cblxuLyoqXG4gKiBQUklNRSBkYXRlcGlja2VyIGNvbXBvbmVudC4gTGFyZ2VseSBhIHdyYXBwZXIgZm9yIG5neC1teWRhdGVwaWNrZXJcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9rZWtlaC9uZ3gtbXlkYXRlcGlja2VyXG4gKlxuICogTk9URSAtIFlPVSBNVVNUIElOQ0xVREUgTkdYLU1ZREFURVBJQ0tFUiBJTiBZT1VSIFBBUkVOVCBBUFBMSUNBVElPTiBUTyBVU0VcbiAqIFRISVMgQ09NUE9ORU5UISAgVGhpcyBpcyBkdWUgdG8gc29tZSBwb29yIGltcGxlbWVudGF0aW9uIGluIG5neC1teWRhdGVwaWNrZXIuXG4gKiBNYWtlIHN1cmUgdG8gdXNlIHRoZSBzYW1lIHZlcnNpb24gdGhhdCB0aGlzIGxpYnJhcnkgdXNlcy5cbiAqL1xuQENvbXBvbmVudCh7XG4gIHNlbGVjdG9yOiAnY29tbW9uLWRhdGVwaWNrZXInLFxuICB0ZW1wbGF0ZVVybDogJy4vZGF0ZXBpY2tlci5jb21wb25lbnQuaHRtbCcsXG4gIHN0eWxlVXJsczogWycuL2RhdGVwaWNrZXIuY29tcG9uZW50LnNjc3MnXSxcbiAgLyogUmUtdXNlIHRoZSBzYW1lIG5nRm9ybSB0aGF0IGl0J3MgcGFyZW50IGlzIHVzaW5nLiBUaGUgY29tcG9uZW50IHdpbGwgc2hvd1xuICAgKiB1cCBpbiBpdHMgcGFyZW50cyBgdGhpcy5mb3JtYCwgYW5kIHdpbGwgYXV0by11cGRhdGUgYHRoaXMuZm9ybS52YWxpZGBcbiAgICovXG4gIHZpZXdQcm92aWRlcnM6IFsgeyBwcm92aWRlOiBDb250cm9sQ29udGFpbmVyLCB1c2VFeGlzdGluZzogZm9yd2FyZFJlZigoKSA9PiBOZ0Zvcm0gKSB9IF0sXG4gIHByb3ZpZGVyczogW1xuICAgIHtcbiAgICAgIHByb3ZpZGU6IE5HX1ZBTFVFX0FDQ0VTU09SLFxuICAgICAgbXVsdGk6IHRydWUsXG4gICAgICB1c2VFeGlzdGluZzogZm9yd2FyZFJlZigoKSA9PiBEYXRlcGlja2VyQ29tcG9uZW50KVxuICAgIH1cbiAgXVxufSlcbmV4cG9ydCBjbGFzcyBEYXRlcGlja2VyQ29tcG9uZW50IGltcGxlbWVudHMgT25Jbml0LCBPbkNoYW5nZXMsIENvbnRyb2xWYWx1ZUFjY2Vzc29yIHtcbiAgLyoqIENvbXBvbmVudCBzaXplIGNhbiBiZSByZWR1Y2VkLCBzZWUgRGF0ZXBpY2tlcnNpemVzIGZvciBvcHRpb25zICovXG4gIEBJbnB1dCgpIHNpemU6IERhdGVwaWNrZXJTaXplcyA9IERhdGVwaWNrZXJTaXplcy5ERUZBVUxUO1xuICBASW5wdXQoKSBkYXRlOiBEYXRlO1xuICBAT3V0cHV0KCkgZGF0ZUNoYW5nZSA9IG5ldyBFdmVudEVtaXR0ZXI8RGF0ZT4oKTtcbiAgQElucHV0KCkgZGlzYWJsZWQ6IGJvb2xlYW47XG4gIEBJbnB1dCgpIGxhYmVsVGV4dDogc3RyaW5nO1xuXG4gIEBJbnB1dCgpIHJlcXVpcmVkOiBib29sZWFuID0gZmFsc2U7XG5cblxuICAvKiogRGF0ZXMgKipiZWZvcmUqKiBkaXNhYmxlVW50aWwgd2lsbCBub3QgYmUgdmFsaWQgc2VsZWN0aW9ucy4gIE1hcHMgdG8gYSBuZ3gtbXlkYXRlcGlja2VyIG9wdGlvbiwgYnV0IHdlIGNvbnZlcnQgSU15RGF0ZSB0byBEYXRlICAqL1xuICBASW5wdXQoKSBkaXNhYmxlVW50aWw6IERhdGU7XG5cbiAgLyoqIERhdGVzICoqYWZ0ZXIqKiBkaXNhYmxlU2luY2Ugd2lsbCBub3QgYmUgdmFsaWQgc2VsZWN0aW9ucy4gIE1hcHMgdG8gYSBuZ3gtbXlkYXRlcGlja2VyIG9wdGlvbiwgYnV0IHdlIGNvbnZlcnQgSU15RGF0ZSB0byBEYXRlICovXG4gIEBJbnB1dCgpIGRpc2FibGVTaW5jZTogRGF0ZTtcblxuICAvKiogRXF1aXZhbGVudCB0byBzZXR0aW5nIGRpc2FibGVCZWZvcmUgdG8gdG9tb3Jyb3cuICovXG4gIEBJbnB1dCgpIG9ubHlGdXR1cmVEYXRlczogYm9vbGVhbjtcblxuICAvKipcbiAgICogQ29udHJvbCB2aXNpYmlsaXR5IG9mIHRoZSBjbGVhciAneCcgYnV0dG9uIG9uIHRoZSBtaW5pIGRhdGVwaWNrZXIuXG4gICAqXG4gICAqICoqJ3Zpc2libGUnKiogaXMgZGVmYXVsdCwgYnV0dG9uIGV4aXN0c1xuICAgKlxuICAgKiAqKidub25lJyoqIG1lYW5zIHRoZSBlbGVtZW50IGRvZXMgbm90IGV4aXN0XG4gICAqXG4gICAqICoqJ2ludmlzaWJsZScqKiBtZWFucyB0aGUgZWxlbWVudCB0YWtlcyB1cCBzcGFjZSBidXQgaXMgbm90IHZpc2libGUgLyBjYW5ub3QgYmVcbiAgICogdXNlZC5cbiAgICpcbiAgICogSW52aXNpYmxlIGlzIHVzZWZ1bCB3aGVuIHlvdSB3YW50IHRvIG1ha2Ugc3VyZSBhIGRhdGVwaWNrZXIgaXMgdGhlIHNhbWVcbiAgICogc2l6ZSBhcyBhIHZpc2libGUgb25lLlxuICAgKi9cbiAgQElucHV0KCkgY2xlYXJCdXR0b246ICd2aXNpYmxlJyB8ICdpbnZpc2libGUnIHwgJ25vbmUnID0gJ3Zpc2libGUnO1xuXG5cblxuICAvKiogRm9ybWF0IGZvciBob3cgdG8gZGlzcGxheSB0aGUgZGF0ZSB0byB0aGUgdXNlci4gKi9cbiAgQElucHV0KCkgZGF0ZUZvcm1hdDogc3RyaW5nID0gJ3l5eXkvbW0vZGQnO1xuXG4gIEBJbnB1dCgpIGVycm9yTWVzc2FnZXM6IERhdGVFcnJvck1zZztcblxuICAvKiogRGF0ZXRpbWUgbW9kZWwgdXNlZCB0byBpbnRlcmZhY2Ugd2l0aCBuZ3gtZGF0ZXBpY2tlci4gKi9cbiAgLy8gbW9kZWw6IGFueTtcbiAgbW9kZWw6IGFueTtcblxuICAvLyBNYWtlIGVudW0gYWNjZXNzaWJsZSBpbiBIVE1MXG4gIERhdGVwaWNrZXJTaXplczogdHlwZW9mIERhdGVwaWNrZXJTaXplcyA9IERhdGVwaWNrZXJTaXplcztcblxuICBAVmlld0NoaWxkKCdkcCcpIG5neGRwOiBOZ3hNeURhdGVQaWNrZXJEaXJlY3RpdmU7XG5cbiAgLyoqIERlZmF1bHQgb3B0aW9ucyBmb3Igd3JhcHBlZCBuZ3gtZGF0ZXBpY2tlci4gKi9cbiAgZGF0ZXBpY2tlck9wdGlvbnM6IElOZ3hNeURwT3B0aW9ucztcblxuICBwdWJsaWMgX29uQ2hhbmdlID0gKF86IGFueSkgPT4ge307XG4gIHB1YmxpYyBfb25Ub3VjaGVkID0gKCkgPT4ge307XG5cbiAgY29uc3RydWN0b3IoKSB7IH1cblxuICBjb252ZXJ0RGF0ZVRvU2ltcGxlRGF0ZShkYXRlOiBEYXRlKTogSU15RGF0ZSB7XG4gICAgaWYgKGRhdGUgPT09IG51bGwgfHwgZGF0ZSA9PT0gdW5kZWZpbmVkKSB7IHJldHVybiBudWxsOyB9XG4gICAgcmV0dXJuIHtcbiAgICAgIHllYXI6IGRhdGUuZ2V0RnVsbFllYXIoKSxcbiAgICAgIG1vbnRoOiBkYXRlLmdldE1vbnRoKCkgKyAxLFxuICAgICAgZGF5OiBkYXRlLmdldERhdGUoKSxcbiAgICB9O1xuICB9XG4gIGNvbnZlcnRTaW1wbGVEYXRlVG9EYXRlKGRhdGU6IElNeURhdGUpOiBEYXRlIHtcbiAgICAvLyBXaGVuIG5neC1teWRhdGVwaWNrZXIgaXMgY2xlYXJlZCwgaXQgcmV0dXJucyB7eWVhcjogMCwgbW9udGg6IDAsIGRheTogMH1cbiAgICBpZiAoZGF0ZS55ZWFyID09PSAwKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBEYXRlKGRhdGUueWVhciwgZGF0ZS5tb250aCAtIDEsIGRhdGUuZGF5KTtcbiAgfVxuXG4gIGlzRGF0ZSh4OiBhbnkpOiB4IGlzIERhdGUge1xuICAgIGlmICgheCkgeyByZXR1cm4gZmFsc2U7IH1cbiAgICByZXR1cm4geC5nZXREYXRlICE9PSB1bmRlZmluZWQ7XG4gIH1cblxuICBuZ09uSW5pdCgpIHtcbiAgICBpZiAoIXRoaXMuZXJyb3JNZXNzYWdlcykge1xuICAgICAgdGhpcy5lcnJvck1lc3NhZ2VzID0ge1xuICAgICAgICByZXF1aXJlZDogdGhpcy5sYWJlbFRleHQgKyAnIGlzIHJlcXVpcmVkLicsXG4gICAgICAgIGRheU91dE9mUmFuZ2U6ICdJbnZhbGlkICcgKyB0aGlzLmxhYmVsVGV4dCArICcuJyxcbiAgICAgICAgeWVhckRpc3RhbnRQYXN0OiAnSW52YWxpZCAnICsgdGhpcy5sYWJlbFRleHQgKyAnLicsXG4gICAgICAgIHllYXJEaXN0YW50RnV0dXJlOiAnSW52YWxpZCAnICsgdGhpcy5sYWJlbFRleHQgKyAnLicsXG4gICAgICAgIG5vRnV0dXJlRGF0ZXNBbGxvd2VkOiAnSW52YWxpZCAnICsgdGhpcy5sYWJlbFRleHQgKyAnLicsXG4gICAgICAgIGludmFsaWRWYWx1ZTogJ0ludmFsaWQgJyArIHRoaXMubGFiZWxUZXh0ICsgJy4nXG4gICAgICB9O1xuICAgIH1cblxuICAgIHRoaXMuZGF0ZXBpY2tlck9wdGlvbnMgPSB7XG4gICAgICBkYXRlRm9ybWF0OiB0aGlzLmRhdGVGb3JtYXQsXG4gICAgICBzdW5IaWdobGlnaHQ6IGZhbHNlLFxuICAgICAgYXBwZW5kU2VsZWN0b3JUb0JvZHk6IHRydWUsXG4gICAgfTtcblxuICAgIGlmICh0aGlzLnNpemUgPT09IERhdGVwaWNrZXJTaXplcy5NSU5JKSB7XG4gICAgICAvLyBTZXQgd2lkdGgvaGVpZ2h0IHRvIDQvNSBvZiBkZWZhdWx0XG4gICAgICB0aGlzLmRhdGVwaWNrZXJPcHRpb25zLnNlbGVjdG9ySGVpZ2h0ID0gJzE4NXB4JztcbiAgICAgIHRoaXMuZGF0ZXBpY2tlck9wdGlvbnMuc2VsZWN0b3JXaWR0aCA9ICcyMDFweCc7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuaXNEYXRlKHRoaXMuZGlzYWJsZVNpbmNlKSkge1xuICAgICAgdGhpcy5kYXRlcGlja2VyT3B0aW9ucy5kaXNhYmxlU2luY2UgPSB0aGlzLmNvbnZlcnREYXRlVG9TaW1wbGVEYXRlKHRoaXMuZGlzYWJsZVNpbmNlKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5pc0RhdGUodGhpcy5kaXNhYmxlVW50aWwpKSB7XG4gICAgICB0aGlzLmRhdGVwaWNrZXJPcHRpb25zLmRpc2FibGVVbnRpbCA9IHRoaXMuY29udmVydERhdGVUb1NpbXBsZURhdGUodGhpcy5kaXNhYmxlU2luY2UpO1xuICAgIH1cblxuICAgIGlmICh0aGlzLm9ubHlGdXR1cmVEYXRlcykge1xuICAgICAgY29uc3QgdG9kYXkgPSBuZXcgRGF0ZSgpO1xuICAgICAgdGhpcy5kYXRlcGlja2VyT3B0aW9ucy5kaXNhYmxlVW50aWwgPSB0aGlzLmNvbnZlcnREYXRlVG9TaW1wbGVEYXRlKHRvZGF5KTtcbiAgICB9XG5cbiAgICBjb25zb2xlLmxvZygnRGF0ZXBpY2tlciBuZ09uSW5pdCcsIHRoaXMuZGF0ZSk7XG5cblxuICAgIGlmICh0aGlzLmRhdGUpIHtcbiAgICAgIC8vIEV2ZW4gaWYganNkYXRlIHdpbmRzIHVwIGJlaW5nIHVuZGVmaW5lZCwgZXZlbiBkZWZpbmluZyB0aGlzLm1vZGVsIHdpbGxcbiAgICAgIC8vIHNldCB0aGUgaW5wdXQgYXMgbm9uLWVtcHR5IGFuZCBpdCdsbCBzYXRpc2Z5IHRoZSAncmVxdWlyZWQnIHZhbGlkYXRpb24uXG4gICAgICAvLyBTbywgd2Ugb25seSBhZGQgdGhlIG1vZGVsIGlmIHRoZXJlJ3MgYWN0dWFsIGRhdGEuXG4gICAgICB0aGlzLm1vZGVsID0ge1xuICAgICAgICBqc2RhdGU6IHRoaXMuZGF0ZVxuICAgICAgfTtcbiAgICB9XG5cblxuICB9XG5cblxuICBuZ09uQ2hhbmdlcyhjaGFuZ2VzOiBTaW1wbGVDaGFuZ2VzKSB7XG4gICAgLy8gUGFyZW50IGNvbXBvbmVudCBoYXMgcGFzc2VkIGluIG51bGwsIHNvIHdlIGhhdmUgdG8gbWFudWFsbHkgY2xlYXIgdGhlIGlucHV0LiBUaGlzIGxlYWRzIHRvIDIgY2hhbmdlIGRldGVjdGlvbiBjeWNsZXMuXG4gICAgLy8gV2UgY291bGQgcmVmYWN0b3IgaXQgZG93biB0byBvbmUsIGJ1dCB0aGUgcGVyZm9ybWFuY2UgaGl0IGlzIG1pbmltYWwgZm9yIHN1Y2ggYSBzaW1wbGUgY29tcG9uZW50LlxuICAgIGlmICh0aGlzLmRhdGUgPT09IG51bGwpIHtcbiAgICAgIHRoaXMuY2xlYXJEYXRlKCk7XG4gICAgICB0aGlzLl9vbkNoYW5nZShudWxsKTtcbiAgICAgIHRoaXMuX29uVG91Y2hlZCgpO1xuICAgIH1cbiAgfVxuXG4gIG9uRGF0ZUNoYW5nZWQoZXZlbnQpOiB2b2lkIHtcbiAgICBpZiAoZXZlbnQuanNkYXRlIHx8IGV2ZW50LmpzZGF0ZSA9PT0gbnVsbCkge1xuICAgICAgLy8gQWx3YXlzIGVtaXQgYSBEYXRlIChvciBudWxsKVxuICAgICAgdGhpcy5kYXRlQ2hhbmdlLmVtaXQoZXZlbnQuanNkYXRlKTtcbiAgICAgIHRoaXMuX29uQ2hhbmdlKGV2ZW50LmpzZGF0ZSk7XG4gICAgICB0aGlzLl9vblRvdWNoZWQoKTtcbiAgICB9XG4gIH1cblxuICBjbGVhckRhdGUoKSB7XG4gICAgaWYgKHRoaXMubmd4ZHApIHtcbiAgICAgIC8vIFdlIGRvbid0IG5lZWQgdG8gZW1pdCBoZXJlLCBiZWNhdXNlIGJ5IGNoYW5naW5nIGRhdGUgd2UnbGwgdHJpZ2dlciBvbkRhdGVDaGFuZ2VkIGF1dG9tYXRpY2FsbHkuXG4gICAgICB0aGlzLmRhdGUgPSBudWxsO1xuICAgICAgdGhpcy5uZ3hkcC5jbGVhckRhdGUoKTtcbiAgICB9XG4gIH1cblxuICByZWdpc3Rlck9uQ2hhbmdlKGZuOiBhbnkpOiB2b2lkIHtcbiAgICB0aGlzLl9vbkNoYW5nZSA9IGZuO1xuICB9XG5cbiAgcmVnaXN0ZXJPblRvdWNoZWQoZm46IGFueSk6IHZvaWQge1xuICAgIHRoaXMuX29uVG91Y2hlZCA9IGZuO1xuICB9XG5cbiAgd3JpdGVWYWx1ZShvYmo6IGFueSk6IHZvaWQge1xuICAgIHRoaXMubW9kZWwgPSB7XG4gICAgICBqc2RhdGU6IG9ialxuICAgIH07XG4gIH1cblxufVxuXG5leHBvcnQgZW51bSBEYXRlcGlja2VyU2l6ZXMge1xuICBNSU5JID0gJ21pbmknLFxuICBERUZBVUxUID0gJ2RlZmF1bHQnXG59XG4iXX0=