/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
import { Component, Input, ViewChild, ElementRef, ViewChildren, QueryList, ChangeDetectionStrategy, ChangeDetectorRef } from '@angular/core';
import { Router, NavigationEnd } from '@angular/router';
import { filter, map } from 'rxjs/operators';
/**
 * NPM Dependencies:
 *  a) rxjs
 *  b) ngx-bootstrap
 */
export class WizardProgressBarComponent {
    /**
     * @param {?} router
     * @param {?} cd
     */
    constructor(router, cd) {
        this.router = router;
        this.cd = cd;
        this.progressSteps = [];
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        // Update the progress bar view on route change and _only_ route chaange.
        // Skip most of Angular's ChangeDetection in favour of manually optimizing.
        this.routerEvents$ = this.router.events.pipe(filter((/**
         * @param {?} ev
         * @return {?}
         */
        ev => ev instanceof NavigationEnd)), map((/**
         * @param {?} ev
         * @return {?}
         */
        (ev) => ev.url))).subscribe((/**
         * @param {?} url
         * @return {?}
         */
        url => {
            this.activeIndex = this.getActiveIndex(url);
            this.cd.detectChanges();
            this.scrollStepIntoView();
        }));
        // Must schedule first run manually, or bar won't be set.
        this.activeIndex = this.getActiveIndex(this.router.url);
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        this.cd.detach();
        this.routerEvents$.unsubscribe();
    }
    /**
     * @return {?}
     */
    calculateProgressPercentage() {
        /** @type {?} */
        const denominator = this.progressSteps.length;
        /** @type {?} */
        const numerator = this.activeIndex + 1;
        if (denominator === 0 || numerator > denominator) {
            return 100;
        }
        // Because we've switched from space-evenly to space-around (for IE), we
        // have to handle the half-space that space-around adds to the start/end of
        // the container
        /** @type {?} */
        const halfSpace = 1 / (denominator * 2);
        return Math.round(((numerator / denominator) - halfSpace) * 100);
    }
    /**
     * @param {?} url
     * @return {?}
     */
    getActiveIndex(url) {
        return this.progressSteps.findIndex((/**
         * @param {?} x
         * @return {?}
         */
        x => url.includes(x.route)));
    }
    /**
     * Primarily for mobile, this horizontally scrolls the step into view.
     *
     * Note - be very careful with any changes to this function because it steps
     * outside of Angular to call native browser functions.
     * @private
     * @return {?}
     */
    scrollStepIntoView() {
        /** @type {?} */
        const target = this.steps.toArray()[this.activeIndex];
        /** @type {?} */
        const container = document.getElementsByClassName('horizontal-scroll');
        if (container.length === 1) {
            // Since we're already breaking out of Angular, we try and be safe by using a try/catch.
            // Otherwise an error here could halt execution,
            try {
                container[0].scrollLeft = Math.abs(target.nativeElement.offsetLeft - (window.outerWidth / 2));
            }
            catch (error) { }
        }
    }
}
WizardProgressBarComponent.decorators = [
    { type: Component, args: [{
                selector: 'common-wizard-progress-bar',
                template: "<progressbar\n  [value]=\"calculateProgressPercentage()\"\n  [max]=\"100\"\n  [animate]=\"true\">\n</progressbar>\n\n<div class=\"step-container\" #stepContainer>\n\n  <a #steps *ngFor=\"let step of progressSteps; let i = index;\" [routerLink]=\"step.route\">\n\n    <div class=\"step\" [ngClass]=\"{active: i === activeIndex}\">\n      <span class=\"step-text\">{{step.title}}</span>\n    </div>\n\n  </a>\n\n</div>\n",
                changeDetection: ChangeDetectionStrategy.OnPush,
                styles: [":host{flex:1;padding:0 2em;min-height:2em;min-width:650px}.step-container{display:flex;justify-content:space-around}progressbar{background-color:#adb5bd;height:.5rem}.step{position:relative;-webkit-transform:translateX(-.5em);transform:translateX(-.5em);margin-top:.25rem}.step:before{content:\" \";position:absolute;width:1em;height:1em;border-radius:100%;background:#fff;border:3px solid #036;right:0;left:0;margin:0 auto;bottom:100%}.step:not(.active) .step-text{opacity:.8}.step:not(.active):before{background:#ced4da}.step .step-text{position:absolute;-webkit-transform:translateX(-33%);transform:translateX(-33%);white-space:nowrap;font-size:small}.progress-background{width:100%;background-color:#00f}"]
            }] }
];
/** @nocollapse */
WizardProgressBarComponent.ctorParameters = () => [
    { type: Router },
    { type: ChangeDetectorRef }
];
WizardProgressBarComponent.propDecorators = {
    progressSteps: [{ type: Input }],
    stepContainer: [{ type: ViewChild, args: ['stepContainer',] }],
    steps: [{ type: ViewChildren, args: ['steps',] }]
};
if (false) {
    /** @type {?} */
    WizardProgressBarComponent.prototype.progressSteps;
    /** @type {?} */
    WizardProgressBarComponent.prototype.stepContainer;
    /** @type {?} */
    WizardProgressBarComponent.prototype.steps;
    /** @type {?} */
    WizardProgressBarComponent.prototype.activeIndex;
    /**
     * @type {?}
     * @private
     */
    WizardProgressBarComponent.prototype.routerEvents$;
    /**
     * @type {?}
     * @private
     */
    WizardProgressBarComponent.prototype.router;
    /**
     * @type {?}
     * @private
     */
    WizardProgressBarComponent.prototype.cd;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoid2l6YXJkLXByb2dyZXNzLWJhci5jb21wb25lbnQuanMiLCJzb3VyY2VSb290Ijoibmc6Ly9tb2gtY29tbW9uLWxpYi8iLCJzb3VyY2VzIjpbImxpYi9jb21wb25lbnRzL3dpemFyZC1wcm9ncmVzcy1iYXIvd2l6YXJkLXByb2dyZXNzLWJhci5jb21wb25lbnQudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7OztBQUFBLE9BQU8sRUFBRSxTQUFTLEVBQVUsS0FBSyxFQUFFLFNBQVMsRUFBRSxVQUFVLEVBQy9DLFlBQVksRUFBRSxTQUFTLEVBQUUsdUJBQXVCLEVBQ2hELGlCQUFpQixFQUFhLE1BQU0sZUFBZSxDQUFDO0FBQzdELE9BQU8sRUFBRSxNQUFNLEVBQUUsYUFBYSxFQUFFLE1BQU0saUJBQWlCLENBQUM7QUFDeEQsT0FBTyxFQUFFLE1BQU0sRUFBRSxHQUFHLEVBQUUsTUFBTSxnQkFBZ0IsQ0FBQzs7Ozs7O0FBZ0I3QyxNQUFNLE9BQU8sMEJBQTBCOzs7OztJQVNyQyxZQUFvQixNQUFjLEVBQVUsRUFBcUI7UUFBN0MsV0FBTSxHQUFOLE1BQU0sQ0FBUTtRQUFVLE9BQUUsR0FBRixFQUFFLENBQW1CO1FBUnhELGtCQUFhLEdBQXlCLEVBQUUsQ0FBQztJQVNqRCxDQUFDOzs7O0lBRUYsUUFBUTtRQUVOLHlFQUF5RTtRQUN6RSwyRUFBMkU7UUFDM0UsSUFBSSxDQUFDLGFBQWEsR0FBRyxJQUFJLENBQUMsTUFBTSxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQzFDLE1BQU07Ozs7UUFBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsWUFBWSxhQUFhLEVBQUMsRUFDekMsR0FBRzs7OztRQUFDLENBQUMsRUFBaUIsRUFBRSxFQUFFLENBQUMsRUFBRSxDQUFDLEdBQUcsRUFBQyxDQUNuQyxDQUFDLFNBQVM7Ozs7UUFBQyxHQUFHLENBQUMsRUFBRTtZQUNoQixJQUFJLENBQUMsV0FBVyxHQUFHLElBQUksQ0FBQyxjQUFjLENBQUMsR0FBRyxDQUFDLENBQUM7WUFDNUMsSUFBSSxDQUFDLEVBQUUsQ0FBQyxhQUFhLEVBQUUsQ0FBQztZQUN4QixJQUFJLENBQUMsa0JBQWtCLEVBQUUsQ0FBQztRQUM1QixDQUFDLEVBQUMsQ0FBQztRQUVILHlEQUF5RDtRQUN6RCxJQUFJLENBQUMsV0FBVyxHQUFHLElBQUksQ0FBQyxjQUFjLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxHQUFHLENBQUMsQ0FBQztJQUMxRCxDQUFDOzs7O0lBRUQsV0FBVztRQUNULElBQUksQ0FBQyxFQUFFLENBQUMsTUFBTSxFQUFFLENBQUM7UUFDakIsSUFBSSxDQUFDLGFBQWEsQ0FBQyxXQUFXLEVBQUUsQ0FBQztJQUNuQyxDQUFDOzs7O0lBRUQsMkJBQTJCOztjQUNuQixXQUFXLEdBQUcsSUFBSSxDQUFDLGFBQWEsQ0FBQyxNQUFNOztjQUN2QyxTQUFTLEdBQUcsSUFBSSxDQUFDLFdBQVcsR0FBRyxDQUFDO1FBRXRDLElBQUksV0FBVyxLQUFLLENBQUMsSUFBSSxTQUFTLEdBQUcsV0FBVyxFQUFFO1lBQ2hELE9BQU8sR0FBRyxDQUFDO1NBQ1o7Ozs7O2NBS0ssU0FBUyxHQUFHLENBQUMsR0FBRyxDQUFDLFdBQVcsR0FBRyxDQUFDLENBQUM7UUFDdkMsT0FBTyxJQUFJLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxTQUFTLEdBQUcsV0FBVyxDQUFDLEdBQUcsU0FBUyxDQUFDLEdBQUcsR0FBRyxDQUFDLENBQUM7SUFDbkUsQ0FBQzs7Ozs7SUFFRCxjQUFjLENBQUMsR0FBRztRQUNoQixPQUFPLElBQUksQ0FBQyxhQUFhLENBQUMsU0FBUzs7OztRQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsR0FBRyxDQUFDLFFBQVEsQ0FBQyxDQUFDLENBQUMsS0FBSyxDQUFDLEVBQUMsQ0FBQztJQUNsRSxDQUFDOzs7Ozs7Ozs7SUFRTyxrQkFBa0I7O2NBQ2xCLE1BQU0sR0FBRyxJQUFJLENBQUMsS0FBSyxDQUFDLE9BQU8sRUFBRSxDQUFDLElBQUksQ0FBQyxXQUFXLENBQUM7O2NBQy9DLFNBQVMsR0FBRyxRQUFRLENBQUMsc0JBQXNCLENBQUMsbUJBQW1CLENBQUM7UUFDdEUsSUFBSSxTQUFTLENBQUMsTUFBTSxLQUFLLENBQUMsRUFBRTtZQUMxQix3RkFBd0Y7WUFDeEYsZ0RBQWdEO1lBQ2hELElBQUk7Z0JBQ0YsU0FBUyxDQUFDLENBQUMsQ0FBQyxDQUFDLFVBQVUsR0FBRyxJQUFJLENBQUMsR0FBRyxDQUFDLE1BQU0sQ0FBQyxhQUFhLENBQUMsVUFBVSxHQUFHLENBQUMsTUFBTSxDQUFDLFVBQVUsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDO2FBQy9GO1lBQUMsT0FBTyxLQUFLLEVBQUUsR0FBRTtTQUNuQjtJQUNILENBQUM7OztZQTNFRixTQUFTLFNBQUM7Z0JBQ1QsUUFBUSxFQUFFLDRCQUE0QjtnQkFDdEMsOGFBQW1EO2dCQUVuRCxlQUFlLEVBQUUsdUJBQXVCLENBQUMsTUFBTTs7YUFDaEQ7Ozs7WUFoQlEsTUFBTTtZQUROLGlCQUFpQjs7OzRCQW1CdkIsS0FBSzs0QkFDTCxTQUFTLFNBQUMsZUFBZTtvQkFDekIsWUFBWSxTQUFDLE9BQU87Ozs7SUFGckIsbURBQWtEOztJQUNsRCxtREFBc0Q7O0lBQ3RELDJDQUF1RTs7SUFFdkUsaURBQTJCOzs7OztJQUUzQixtREFBb0M7Ozs7O0lBRXhCLDRDQUFzQjs7Ozs7SUFBRSx3Q0FBNkIiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBDb21wb25lbnQsIE9uSW5pdCwgSW5wdXQsIFZpZXdDaGlsZCwgRWxlbWVudFJlZixcbiAgICAgICAgIFZpZXdDaGlsZHJlbiwgUXVlcnlMaXN0LCBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneSxcbiAgICAgICAgIENoYW5nZURldGVjdG9yUmVmLCBPbkRlc3Ryb3kgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IFJvdXRlciwgTmF2aWdhdGlvbkVuZCB9IGZyb20gJ0Bhbmd1bGFyL3JvdXRlcic7XG5pbXBvcnQgeyBmaWx0ZXIsIG1hcCB9IGZyb20gJ3J4anMvb3BlcmF0b3JzJztcbmltcG9ydCB7IFN1YnNjcmlwdGlvbiB9IGZyb20gJ3J4anMnO1xuaW1wb3J0IHsgV2l6YXJkUHJvZ3Jlc3NJdGVtIH0gZnJvbSAnLi4vLi4vLi4vbW9kZWxzL3NyYy9jb250YWluZXInO1xuXG4vKipcbiAqIE5QTSBEZXBlbmRlbmNpZXM6XG4gKiAgYSkgcnhqc1xuICogIGIpIG5neC1ib290c3RyYXBcbiAqL1xuXG5AQ29tcG9uZW50KHtcbiAgc2VsZWN0b3I6ICdjb21tb24td2l6YXJkLXByb2dyZXNzLWJhcicsXG4gIHRlbXBsYXRlVXJsOiAnLi93aXphcmQtcHJvZ3Jlc3MtYmFyLmNvbXBvbmVudC5odG1sJyxcbiAgc3R5bGVVcmxzOiBbJy4vd2l6YXJkLXByb2dyZXNzLWJhci5jb21wb25lbnQuc2NzcyddLFxuICBjaGFuZ2VEZXRlY3Rpb246IENoYW5nZURldGVjdGlvblN0cmF0ZWd5Lk9uUHVzaFxufSlcbmV4cG9ydCBjbGFzcyBXaXphcmRQcm9ncmVzc0JhckNvbXBvbmVudCBpbXBsZW1lbnRzIE9uSW5pdCwgT25EZXN0cm95IHtcbiAgQElucHV0KCkgcHJvZ3Jlc3NTdGVwczogV2l6YXJkUHJvZ3Jlc3NJdGVtW10gPSBbXTtcbiAgQFZpZXdDaGlsZCgnc3RlcENvbnRhaW5lcicpIHN0ZXBDb250YWluZXI6IEVsZW1lbnRSZWY7XG4gIEBWaWV3Q2hpbGRyZW4oJ3N0ZXBzJykgc3RlcHM6IFF1ZXJ5TGlzdDxFbGVtZW50UmVmPEhUTUxBbmNob3JFbGVtZW50Pj47XG5cbiAgcHVibGljIGFjdGl2ZUluZGV4OiBudW1iZXI7XG5cbiAgcHJpdmF0ZSByb3V0ZXJFdmVudHMkOiBTdWJzY3JpcHRpb247XG5cbiAgY29uc3RydWN0b3IocHJpdmF0ZSByb3V0ZXI6IFJvdXRlciwgcHJpdmF0ZSBjZDogQ2hhbmdlRGV0ZWN0b3JSZWYpIHtcbiAgIH1cblxuICBuZ09uSW5pdCgpIHtcblxuICAgIC8vIFVwZGF0ZSB0aGUgcHJvZ3Jlc3MgYmFyIHZpZXcgb24gcm91dGUgY2hhbmdlIGFuZCBfb25seV8gcm91dGUgY2hhYW5nZS5cbiAgICAvLyBTa2lwIG1vc3Qgb2YgQW5ndWxhcidzIENoYW5nZURldGVjdGlvbiBpbiBmYXZvdXIgb2YgbWFudWFsbHkgb3B0aW1pemluZy5cbiAgICB0aGlzLnJvdXRlckV2ZW50cyQgPSB0aGlzLnJvdXRlci5ldmVudHMucGlwZShcbiAgICAgIGZpbHRlcihldiA9PiBldiBpbnN0YW5jZW9mIE5hdmlnYXRpb25FbmQpLFxuICAgICAgbWFwKChldjogTmF2aWdhdGlvbkVuZCkgPT4gZXYudXJsKVxuICAgICkuc3Vic2NyaWJlKHVybCA9PiB7XG4gICAgICB0aGlzLmFjdGl2ZUluZGV4ID0gdGhpcy5nZXRBY3RpdmVJbmRleCh1cmwpO1xuICAgICAgdGhpcy5jZC5kZXRlY3RDaGFuZ2VzKCk7XG4gICAgICB0aGlzLnNjcm9sbFN0ZXBJbnRvVmlldygpO1xuICAgIH0pO1xuXG4gICAgLy8gTXVzdCBzY2hlZHVsZSBmaXJzdCBydW4gbWFudWFsbHksIG9yIGJhciB3b24ndCBiZSBzZXQuXG4gICAgdGhpcy5hY3RpdmVJbmRleCA9IHRoaXMuZ2V0QWN0aXZlSW5kZXgodGhpcy5yb3V0ZXIudXJsKTtcbiAgfVxuXG4gIG5nT25EZXN0cm95KCkge1xuICAgIHRoaXMuY2QuZGV0YWNoKCk7XG4gICAgdGhpcy5yb3V0ZXJFdmVudHMkLnVuc3Vic2NyaWJlKCk7XG4gIH1cblxuICBjYWxjdWxhdGVQcm9ncmVzc1BlcmNlbnRhZ2UoKTogTnVtYmVyIHtcbiAgICBjb25zdCBkZW5vbWluYXRvciA9IHRoaXMucHJvZ3Jlc3NTdGVwcy5sZW5ndGg7XG4gICAgY29uc3QgbnVtZXJhdG9yID0gdGhpcy5hY3RpdmVJbmRleCArIDE7XG5cbiAgICBpZiAoZGVub21pbmF0b3IgPT09IDAgfHwgbnVtZXJhdG9yID4gZGVub21pbmF0b3IpIHtcbiAgICAgIHJldHVybiAxMDA7XG4gICAgfVxuXG4gICAgLy8gQmVjYXVzZSB3ZSd2ZSBzd2l0Y2hlZCBmcm9tIHNwYWNlLWV2ZW5seSB0byBzcGFjZS1hcm91bmQgKGZvciBJRSksIHdlXG4gICAgLy8gaGF2ZSB0byBoYW5kbGUgdGhlIGhhbGYtc3BhY2UgdGhhdCBzcGFjZS1hcm91bmQgYWRkcyB0byB0aGUgc3RhcnQvZW5kIG9mXG4gICAgLy8gdGhlIGNvbnRhaW5lclxuICAgIGNvbnN0IGhhbGZTcGFjZSA9IDEgLyAoZGVub21pbmF0b3IgKiAyKTtcbiAgICByZXR1cm4gTWF0aC5yb3VuZCgoKG51bWVyYXRvciAvIGRlbm9taW5hdG9yKSAtIGhhbGZTcGFjZSkgKiAxMDApO1xuICB9XG5cbiAgZ2V0QWN0aXZlSW5kZXgodXJsKTogbnVtYmVyIHtcbiAgICByZXR1cm4gdGhpcy5wcm9ncmVzc1N0ZXBzLmZpbmRJbmRleCh4ID0+IHVybC5pbmNsdWRlcyh4LnJvdXRlKSk7XG4gIH1cblxuICAgLyoqXG4gICAqIFByaW1hcmlseSBmb3IgbW9iaWxlLCB0aGlzIGhvcml6b250YWxseSBzY3JvbGxzIHRoZSBzdGVwIGludG8gdmlldy5cbiAgICpcbiAgICogTm90ZSAtIGJlIHZlcnkgY2FyZWZ1bCB3aXRoIGFueSBjaGFuZ2VzIHRvIHRoaXMgZnVuY3Rpb24gYmVjYXVzZSBpdCBzdGVwc1xuICAgKiBvdXRzaWRlIG9mIEFuZ3VsYXIgdG8gY2FsbCBuYXRpdmUgYnJvd3NlciBmdW5jdGlvbnMuXG4gICAqL1xuICBwcml2YXRlIHNjcm9sbFN0ZXBJbnRvVmlldygpIHtcbiAgICBjb25zdCB0YXJnZXQgPSB0aGlzLnN0ZXBzLnRvQXJyYXkoKVt0aGlzLmFjdGl2ZUluZGV4XTtcbiAgICBjb25zdCBjb250YWluZXIgPSBkb2N1bWVudC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lKCdob3Jpem9udGFsLXNjcm9sbCcpO1xuICAgIGlmIChjb250YWluZXIubGVuZ3RoID09PSAxKSB7XG4gICAgICAvLyBTaW5jZSB3ZSdyZSBhbHJlYWR5IGJyZWFraW5nIG91dCBvZiBBbmd1bGFyLCB3ZSB0cnkgYW5kIGJlIHNhZmUgYnkgdXNpbmcgYSB0cnkvY2F0Y2guXG4gICAgICAvLyBPdGhlcndpc2UgYW4gZXJyb3IgaGVyZSBjb3VsZCBoYWx0IGV4ZWN1dGlvbixcbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnRhaW5lclswXS5zY3JvbGxMZWZ0ID0gTWF0aC5hYnModGFyZ2V0Lm5hdGl2ZUVsZW1lbnQub2Zmc2V0TGVmdCAtICh3aW5kb3cub3V0ZXJXaWR0aCAvIDIpKTtcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7fVxuICAgIH1cbiAgfVxuXG59XG4iXX0=