/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
import { Directive, forwardRef } from '@angular/core';
import { NG_VALIDATORS } from '@angular/forms';
import * as moment_ from 'moment';
/** @type {?} */
const moment = moment_;
export class DayValidationDirective {
    /**
     * @param {?} control
     * @return {?}
     */
    validate(control) {
        /** @type {?} */
        const date = control.parent.value;
        if (!control.value) {
            return null; // empty value
        }
        /** @type {?} */
        const day = parseInt(control.value, 10);
        // console.log( 'day: ', day );
        if (!isNaN(day)) {
            // console.log( 'parent: ', date );
            // Only process of value is numeric
            if (!isNaN(date.month) && !isNaN(date.year)) {
                // Determine days in month
                /** @type {?} */
                const str = `${date.year}-${date.month}`;
                /** @type {?} */
                let daysInMonth = moment(str, 'YYYY-MM').daysInMonth();
                // console.log( 'str: ', str + ', dayInMonth: ', daysInMonth );
                if (isNaN(daysInMonth)) {
                    daysInMonth = 31;
                }
                // Validate days
                if (day > daysInMonth || day < 1) {
                    return { 'dayOutOfRange': true };
                }
            }
            return null;
        }
        return { 'invalidValue': true };
    }
}
DayValidationDirective.decorators = [
    { type: Directive, args: [{
                selector: '[commonDayValidation]',
                providers: [
                    { provide: NG_VALIDATORS, useExisting: forwardRef((/**
                         * @return {?}
                         */
                        () => DayValidationDirective)), multi: true }
                ]
            },] }
];
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZGF5LXZhbGlkYXRpb24uZGlyZWN0aXZlLmpzIiwic291cmNlUm9vdCI6Im5nOi8vbW9oLWNvbW1vbi1saWIvIiwic291cmNlcyI6WyJsaWIvY29tcG9uZW50cy9kYXRlL2RheS12YWxpZGF0aW9uLmRpcmVjdGl2ZS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7O0FBQUEsT0FBTyxFQUFFLFNBQVMsRUFBRSxVQUFVLEVBQUUsTUFBTSxlQUFlLENBQUM7QUFDdEQsT0FBTyxFQUFFLGFBQWEsRUFBMEIsTUFBTSxnQkFBZ0IsQ0FBQztBQUN2RSxPQUFPLEtBQUssT0FBTyxNQUFNLFFBQVEsQ0FBQzs7TUFDNUIsTUFBTSxHQUFHLE9BQU87QUFRdEIsTUFBTSxPQUFPLHNCQUFzQjs7Ozs7SUFFakMsUUFBUSxDQUFFLE9BQW9COztjQUN0QixJQUFJLEdBQUcsT0FBTyxDQUFDLE1BQU0sQ0FBQyxLQUFLO1FBRWpDLElBQUssQ0FBQyxPQUFPLENBQUMsS0FBSyxFQUFHO1lBQ3BCLE9BQU8sSUFBSSxDQUFDLENBQUMsY0FBYztTQUM1Qjs7Y0FFSyxHQUFHLEdBQVcsUUFBUSxDQUFFLE9BQU8sQ0FBQyxLQUFLLEVBQUUsRUFBRSxDQUFFO1FBQ2pELCtCQUErQjtRQUUvQixJQUFLLENBQUMsS0FBSyxDQUFFLEdBQUcsQ0FBRSxFQUFHO1lBRW5CLG1DQUFtQztZQUNuQyxtQ0FBbUM7WUFDbkMsSUFBSyxDQUFDLEtBQUssQ0FBRSxJQUFJLENBQUMsS0FBSyxDQUFFLElBQUssQ0FBQyxLQUFLLENBQUUsSUFBSSxDQUFDLElBQUksQ0FBRSxFQUFHOzs7c0JBRzVDLEdBQUcsR0FBRyxHQUFHLElBQUksQ0FBQyxJQUFJLElBQUksSUFBSSxDQUFDLEtBQUssRUFBRTs7b0JBQ3BDLFdBQVcsR0FBVyxNQUFNLENBQUMsR0FBRyxFQUFFLFNBQVMsQ0FBQyxDQUFDLFdBQVcsRUFBRTtnQkFDOUQsK0RBQStEO2dCQUUvRCxJQUFLLEtBQUssQ0FBRSxXQUFXLENBQUUsRUFBRztvQkFDMUIsV0FBVyxHQUFHLEVBQUUsQ0FBQztpQkFDbEI7Z0JBRUQsZ0JBQWdCO2dCQUNoQixJQUFLLEdBQUcsR0FBRyxXQUFXLElBQUksR0FBRyxHQUFHLENBQUMsRUFBRztvQkFDbEMsT0FBTyxFQUFFLGVBQWUsRUFBRSxJQUFJLEVBQUUsQ0FBQztpQkFDbEM7YUFDRjtZQUVELE9BQU8sSUFBSSxDQUFDO1NBQ2I7UUFFRCxPQUFPLEVBQUUsY0FBYyxFQUFFLElBQUksRUFBRSxDQUFDO0lBQ2xDLENBQUM7OztZQTNDRixTQUFTLFNBQUM7Z0JBQ1QsUUFBUSxFQUFFLHVCQUF1QjtnQkFDakMsU0FBUyxFQUFFO29CQUNULEVBQUMsT0FBTyxFQUFFLGFBQWEsRUFBRSxXQUFXLEVBQUUsVUFBVTs7O3dCQUFDLEdBQUcsRUFBRSxDQUFDLHNCQUFzQixFQUFDLEVBQUUsS0FBSyxFQUFFLElBQUksRUFBQztpQkFDN0Y7YUFDRiIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IERpcmVjdGl2ZSwgZm9yd2FyZFJlZiB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgTkdfVkFMSURBVE9SUywgVmFsaWRhdG9yLCBGb3JtQ29udHJvbCB9IGZyb20gJ0Bhbmd1bGFyL2Zvcm1zJztcbmltcG9ydCAqIGFzIG1vbWVudF8gZnJvbSAnbW9tZW50JztcbmNvbnN0IG1vbWVudCA9IG1vbWVudF87XG5cbkBEaXJlY3RpdmUoe1xuICBzZWxlY3RvcjogJ1tjb21tb25EYXlWYWxpZGF0aW9uXScsXG4gIHByb3ZpZGVyczogW1xuICAgIHtwcm92aWRlOiBOR19WQUxJREFUT1JTLCB1c2VFeGlzdGluZzogZm9yd2FyZFJlZigoKSA9PiBEYXlWYWxpZGF0aW9uRGlyZWN0aXZlKSwgbXVsdGk6IHRydWV9XG4gIF1cbn0pXG5leHBvcnQgY2xhc3MgRGF5VmFsaWRhdGlvbkRpcmVjdGl2ZSBpbXBsZW1lbnRzIFZhbGlkYXRvciB7XG5cbiAgdmFsaWRhdGUoIGNvbnRyb2w6IEZvcm1Db250cm9sICk6IHtba2V5OiBzdHJpbmddOiBhbnl9IHwgbnVsbCB7XG4gICAgY29uc3QgZGF0ZSA9IGNvbnRyb2wucGFyZW50LnZhbHVlO1xuXG4gICAgaWYgKCAhY29udHJvbC52YWx1ZSApIHtcbiAgICAgIHJldHVybiBudWxsOyAvLyBlbXB0eSB2YWx1ZVxuICAgIH1cblxuICAgIGNvbnN0IGRheTogbnVtYmVyID0gcGFyc2VJbnQoIGNvbnRyb2wudmFsdWUsIDEwICk7XG4gICAgLy8gY29uc29sZS5sb2coICdkYXk6ICcsIGRheSApO1xuXG4gICAgaWYgKCAhaXNOYU4oIGRheSApICkge1xuXG4gICAgICAvLyBjb25zb2xlLmxvZyggJ3BhcmVudDogJywgZGF0ZSApO1xuICAgICAgLy8gT25seSBwcm9jZXNzIG9mIHZhbHVlIGlzIG51bWVyaWNcbiAgICAgIGlmICggIWlzTmFOKCBkYXRlLm1vbnRoICkgICYmICFpc05hTiggZGF0ZS55ZWFyICkgKSB7XG5cbiAgICAgICAgLy8gRGV0ZXJtaW5lIGRheXMgaW4gbW9udGhcbiAgICAgICAgY29uc3Qgc3RyID0gYCR7ZGF0ZS55ZWFyfS0ke2RhdGUubW9udGh9YDtcbiAgICAgICAgbGV0IGRheXNJbk1vbnRoOiBudW1iZXIgPSBtb21lbnQoc3RyLCAnWVlZWS1NTScpLmRheXNJbk1vbnRoKCk7XG4gICAgICAgIC8vIGNvbnNvbGUubG9nKCAnc3RyOiAnLCBzdHIgKyAnLCBkYXlJbk1vbnRoOiAnLCBkYXlzSW5Nb250aCApO1xuXG4gICAgICAgIGlmICggaXNOYU4oIGRheXNJbk1vbnRoICkgKSB7XG4gICAgICAgICAgZGF5c0luTW9udGggPSAzMTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFZhbGlkYXRlIGRheXNcbiAgICAgICAgaWYgKCBkYXkgPiBkYXlzSW5Nb250aCB8fCBkYXkgPCAxICkge1xuICAgICAgICAgIHJldHVybiB7ICdkYXlPdXRPZlJhbmdlJzogdHJ1ZSB9O1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIHJldHVybiB7ICdpbnZhbGlkVmFsdWUnOiB0cnVlIH07XG4gIH1cblxufVxuIl19