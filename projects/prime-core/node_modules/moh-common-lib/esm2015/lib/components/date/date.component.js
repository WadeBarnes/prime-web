/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
import { Component, Input, Output, EventEmitter, ViewChild, ChangeDetectorRef, forwardRef } from '@angular/core';
import { Base } from '../../../models/src/base';
import { ControlContainer, NgForm, NgModel } from '@angular/forms';
import * as moment_ from 'moment';
/** @type {?} */
const moment = moment_;
/**
 * Component NPM package dependencies:
 * a) moment
 * @record
 */
export function DateErrorMsg() { }
if (false) {
    /** @type {?} */
    DateErrorMsg.prototype.required;
    /** @type {?|undefined} */
    DateErrorMsg.prototype.dayOutOfRange;
    /** @type {?|undefined} */
    DateErrorMsg.prototype.yearDistantPast;
    /** @type {?|undefined} */
    DateErrorMsg.prototype.yearDistantFuture;
    /** @type {?|undefined} */
    DateErrorMsg.prototype.noPastDatesAllowed;
    /** @type {?|undefined} */
    DateErrorMsg.prototype.noFutureDatesAllowed;
    /** @type {?|undefined} */
    DateErrorMsg.prototype.invalidValue;
}
export class DateComponent extends Base {
    /**
     * @param {?} form
     * @param {?} cd
     */
    constructor(form, cd) {
        super();
        this.form = form;
        this.cd = cd;
        this.useCurrentDate = false;
        this.required = true;
        this.disabled = false;
        this.label = 'Date';
        /**
         * Can be one of: "future", "past". "future" includes today, "past" does not.
         */
        this.restrictDate = 'any';
        this.dateChange = new EventEmitter();
        this.monthList = [
            'January', 'February', 'March', 'April', 'May', 'June',
            'July', 'August', 'September', 'October', 'November', 'December'
        ];
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        if (!this.errorMessages) {
            // Use default messages
            this.errorMessages = {
                required: this.label + ' is required.',
                dayOutOfRange: 'Invalid ' + this.label + '.',
                yearDistantPast: 'Invalid ' + this.label + '.',
                yearDistantFuture: 'Invalid ' + this.label + '.',
                noFutureDatesAllowed: 'Invalid ' + this.label + '.',
                invalidValue: 'Invalid ' + this.label + '.'
            };
        }
        if (this.useCurrentDate) {
            // Set date to current date
            this.date.month = moment().month();
            this.date.day = moment().date();
            this.date.year = moment().year();
        }
    }
    /**
     * Set the month and notify caller of change
     * @param {?} value
     * @return {?}
     */
    setMonth(value) {
        /** @type {?} */
        const month = this.getNumericValue(value);
        // console.log( 'monthRef: ', this.monthRef );
        if (this.date) {
            this.date.month = month;
            this.triggerDayValidation();
            this.dateChange.emit(this.date);
        }
    }
    /**
     * Set the day and notify caller of change
     * @param {?} value
     * @return {?}
     */
    setDay(value) {
        /** @type {?} */
        const day = this.getNumericValue(value);
        // console.log(  'dayRef: ', this.dayRef );
        if (this.date) {
            this.date.day = day;
            this.dateChange.emit(this.date);
        }
    }
    /**
     * Set the yera and notify caller of change
     * @param {?} value
     * @return {?}
     */
    setYear(value) {
        /** @type {?} */
        const year = this.getNumericValue(value);
        // console.log( 'yearRef: ', this.yearRef );
        if (this.date) {
            this.date.year = year;
            this.triggerDayValidation();
            this.dateChange.emit(this.date);
        }
    }
    /**
     * Force the `day` input to run it's directives again. Important in cases
     * where user fills fields out of order, e.g. sets days to 31 then month to
     * Februrary.
     * @private
     * @return {?}
     */
    triggerDayValidation() {
        // We have to wrap this in a timeout, otherwise it runs before Angular has updated the values
        setTimeout((/**
         * @return {?}
         */
        () => {
            if (this.form.controls['day']) {
                // console.log( 'Trigger day validation' );
                this.form.controls['day'].updateValueAndValidity();
                this.cd.detectChanges();
            }
        }), 0);
    }
    /**
     * Convert string to numeric value or null if not
     * @private
     * @param {?} value
     * @return {?}
     */
    getNumericValue(value) {
        /** @type {?} */
        const parsed = parseInt(value, 10);
        return (isNaN(parsed) ? null : parsed);
    }
}
DateComponent.decorators = [
    { type: Component, args: [{
                selector: 'common-date',
                template: "<fieldset>\n  <legend class=\"date--legend\">{{label}}</legend>\n  <div class=\"form-group date-row\">\n\n    <label class=\"visuallyhidden\" for=\"month{{objectId}}\">Month</label>\n    <select class=\"form-control monthSelect\"\n            id=\"month{{objectId}}\"\n            name=\"month\"\n            [ngModel]=\"date?.month\"\n            (ngModelChange)=\"setMonth($event)\"\n            [disabled]='disabled'\n            #monthRef=\"ngModel\"\n            [required]=\"required\">\n      <!-- We show the blank option so the user can clear out their data.-->\n      <option value=\"null\" label=\"-- month --\" selected [disabled]='required'></option>\n      <option *ngFor=\"let month of monthList; let i = index;\" [value]=\"i + 1\">{{month}}</option>\n    </select>\n\n    <label class=\"visuallyhidden\" for=\"day{{objectId}}\">Day</label>\n    <input type=\"number\"\n           class=\"form-control dayInput\"\n           id=\"day{{objectId}}\"\n           name=\"day\"\n           placeholder=\"day\"\n           [ngModel]=\"date?.day\"\n           (ngModelChange)=\"setDay($event)\"\n           #dayRef=\"ngModel\"\n           [required]=\"required\"\n           commonDateFieldFormat\n           commonDayValidation\n           [disabled]='disabled'\n           maxlength=\"2\" />\n\n    <label class=\"visuallyhidden\" for=\"year{{objectId}}\">Year</label>\n    <input type=\"number\"\n           class=\"form-control yearInput\"\n           id=\"year{{objectId}}\"\n           name=\"year\"\n           placeholder=\"year\"\n           [ngModel]=\"date?.year\"\n           (ngModelChange)=\"setYear($event)\"\n           #yearRef=\"ngModel\"\n           [required]=\"required\"\n           commonDateFieldFormat\n           [commonYearValidate]=\"restrictDate\"\n           [disabled]='disabled'\n           maxlength=\"4\" />\n\n  </div>\n\n</fieldset>\n\n<!-- Error messages for component -->\n<div *ngIf=\"!disabled && (monthRef.touched || monthRef.dirty) && (dayRef.touched || dayRef.dirty) && (yearRef.touched || yearRef.dirty)\"\n    role=\"alert\"\n    class='error-container'\n    aria-live=\"assertive\">\n  <div class=\"text-danger\"\n       *ngIf=\"(monthRef?.errors?.required || dayRef?.errors?.required || yearRef?.errors?.required ) && errorMessages?.required\">\n       {{errorMessages.required}}\n  </div>\n  <div class=\"text-danger\"\n      *ngIf=\"dayRef?.errors?.dayOutOfRange && errorMessages?.dayOutOfRange\">\n       {{errorMessages.dayOutOfRange}}\n  </div>\n  <div class=\"text-danger\"\n       *ngIf=\"yearRef?.errors?.yearDistantPast && errorMessages?.yearDistantPast\">\n       {{errorMessages.yearDistantPast}}\n  </div>\n  <div class=\"text-danger\"\n       *ngIf=\"yearRef?.errors?.yearDistantFuture && errorMessages?.yearDistantFuture\">\n       {{errorMessages.yearDistantFuture}}\n  </div>\n  <div class=\"text-danger\"\n        *ngIf=\"yearRef?.errors?.noPastDatesAllowed && errorMessages?.noPastDatesAllowed\">\n        {{errorMessages.noPastDatesAllowed}}\n  </div>\n  <div class=\"text-danger\"\n       *ngIf=\"yearRef?.errors?.noFutureDatesAllowed && errorMessages?.noFutureDatesAllowed\">\n       {{errorMessages.noFutureDatesAllowed}}\n  </div>\n  <!-- Case should not happen until something is not formatted correctly-->\n  <div class=\"text-danger\"\n       *ngIf=\"(dayRef?.errors?.invalidValue || yearRef?.errors?.invalidValue) && errorMessages?.invalidValue\">\n       {{errorMessages.invalidValue}}\n  </div>\n</div>\n\n\n",
                /* Re-use the same ngForm that it's parent is using. The component will show
                   * up in its parents `this.form`, and will auto-update `this.form.valid`
                   */
                viewProviders: [{ provide: ControlContainer, useExisting: forwardRef((/**
                         * @return {?}
                         */
                        () => NgForm)) }],
                styles: [".date--legend{font-size:inherit;font-weight:700}.date-row{display:flex;flex-wrap:nowrap;justify-content:space-between}.monthSelect{max-width:50%;height:35px;margin-right:1em}.dayInput{max-width:25%;height:35px;margin-right:1em}.yearInput{max-width:25%;height:35px}.error-container{flex-basis:100%!important}input[type=number]::-webkit-inner-spin-button,input[type=number]::-webkit-outer-spin-button{-webkit-appearance:none;-moz-appearance:none;appearance:none;margin:0}select option[selected]{color:gray!important}"]
            }] }
];
/** @nocollapse */
DateComponent.ctorParameters = () => [
    { type: NgForm },
    { type: ChangeDetectorRef }
];
DateComponent.propDecorators = {
    monthRef: [{ type: ViewChild, args: ['monthRef',] }],
    dayRef: [{ type: ViewChild, args: ['dayRef',] }],
    yearRef: [{ type: ViewChild, args: ['yearRef',] }],
    useCurrentDate: [{ type: Input }],
    required: [{ type: Input }],
    disabled: [{ type: Input }],
    label: [{ type: Input }],
    date: [{ type: Input }],
    restrictDate: [{ type: Input }],
    errorMessages: [{ type: Input }],
    dateChange: [{ type: Output }]
};
if (false) {
    /** @type {?} */
    DateComponent.prototype.monthRef;
    /** @type {?} */
    DateComponent.prototype.dayRef;
    /** @type {?} */
    DateComponent.prototype.yearRef;
    /** @type {?} */
    DateComponent.prototype.useCurrentDate;
    /** @type {?} */
    DateComponent.prototype.required;
    /** @type {?} */
    DateComponent.prototype.disabled;
    /** @type {?} */
    DateComponent.prototype.label;
    /** @type {?} */
    DateComponent.prototype.date;
    /**
     * Can be one of: "future", "past". "future" includes today, "past" does not.
     * @type {?}
     */
    DateComponent.prototype.restrictDate;
    /** @type {?} */
    DateComponent.prototype.errorMessages;
    /** @type {?} */
    DateComponent.prototype.dateChange;
    /** @type {?} */
    DateComponent.prototype.monthList;
    /**
     * @type {?}
     * @private
     */
    DateComponent.prototype.form;
    /**
     * @type {?}
     * @private
     */
    DateComponent.prototype.cd;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZGF0ZS5jb21wb25lbnQuanMiLCJzb3VyY2VSb290Ijoibmc6Ly9tb2gtY29tbW9uLWxpYi8iLCJzb3VyY2VzIjpbImxpYi9jb21wb25lbnRzL2RhdGUvZGF0ZS5jb21wb25lbnQudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7OztBQUFBLE9BQU8sRUFBRSxTQUFTLEVBQVUsS0FBSyxFQUFFLE1BQU0sRUFBRSxZQUFZLEVBQUUsU0FBUyxFQUFjLGlCQUFpQixFQUFFLFVBQVUsRUFBRSxNQUFNLGVBQWUsQ0FBQztBQUNySSxPQUFPLEVBQUUsSUFBSSxFQUFFLE1BQU0sMEJBQTBCLENBQUM7QUFFaEQsT0FBTyxFQUFFLGdCQUFnQixFQUFFLE1BQU0sRUFBRSxPQUFPLEVBQUUsTUFBTSxnQkFBZ0IsQ0FBQztBQUNuRSxPQUFPLEtBQUssT0FBTyxNQUFNLFFBQVEsQ0FBQzs7TUFDNUIsTUFBTSxHQUFHLE9BQU87Ozs7OztBQU90QixrQ0FRQzs7O0lBUEMsZ0NBQWlCOztJQUNqQixxQ0FBdUI7O0lBQ3ZCLHVDQUF5Qjs7SUFDekIseUNBQTJCOztJQUMzQiwwQ0FBNEI7O0lBQzVCLDRDQUE4Qjs7SUFDOUIsb0NBQXNCOztBQVl4QixNQUFNLE9BQU8sYUFBYyxTQUFRLElBQUk7Ozs7O0lBc0JyQyxZQUFxQixJQUFZLEVBQ1osRUFBcUI7UUFDeEMsS0FBSyxFQUFFLENBQUM7UUFGVyxTQUFJLEdBQUosSUFBSSxDQUFRO1FBQ1osT0FBRSxHQUFGLEVBQUUsQ0FBbUI7UUFqQmpDLG1CQUFjLEdBQVksS0FBSyxDQUFDO1FBQ2hDLGFBQVEsR0FBWSxJQUFJLENBQUM7UUFDekIsYUFBUSxHQUFZLEtBQUssQ0FBQztRQUMxQixVQUFLLEdBQVcsTUFBTSxDQUFDOzs7O1FBR3ZCLGlCQUFZLEdBQThCLEtBQUssQ0FBQztRQUcvQyxlQUFVLEdBQTZCLElBQUksWUFBWSxFQUFjLENBQUM7UUFFekUsY0FBUyxHQUFhO1lBQzNCLFNBQVMsRUFBRSxVQUFVLEVBQUUsT0FBTyxFQUFF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SCxDQUFDLEdBQUUsQ0FBQyxDQUFDLENBQUM7SUFDUixDQUFDOzs7Ozs7O0lBR08sZUFBZSxDQUFFLEtBQWE7O2NBQzlCLE1BQU0sR0FBRyxRQUFRLENBQUUsS0FBSyxFQUFFLEVBQUUsQ0FBRTtRQUNwQyxPQUFPLENBQUUsS0FBSyxDQUFFLE1BQU0sQ0FBRSxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLE1BQU0sQ0FBRSxDQUFDO0lBQzdDLENBQUM7OztZQWhIRixTQUFTLFNBQUM7Z0JBQ1QsUUFBUSxFQUFFLGFBQWE7Z0JBQ3ZCLGc3R0FBb0M7Ozs7Z0JBS3BDLGFBQWEsRUFBRSxDQUFFLEVBQUUsT0FBTyxFQUFFLGdCQUFnQixFQUFFLFdBQVcsRUFBRSxVQUFVOzs7d0JBQUMsR0FBRyxFQUFFLENBQUMsTUFBTSxFQUFFLEVBQUUsQ0FBRTs7YUFDekY7Ozs7WUEzQjBCLE1BQU07WUFIK0MsaUJBQWlCOzs7dUJBaUM5RixTQUFTLFNBQUUsVUFBVTtxQkFDckIsU0FBUyxTQUFFLFFBQVE7c0JBQ25CLFNBQVMsU0FBRSxTQUFTOzZCQUVwQixLQUFLO3VCQUNMLEtBQUs7dUJBQ0wsS0FBSztvQkFDTCxLQUFLO21CQUNMLEtBQUs7MkJBRUwsS0FBSzs0QkFDTCxLQUFLO3lCQUVMLE1BQU07Ozs7SUFiUCxpQ0FBMkM7O0lBQzNDLCtCQUF1Qzs7SUFDdkMsZ0NBQXdDOztJQUV4Qyx1Q0FBeUM7O0lBQ3pDLGlDQUFrQzs7SUFDbEMsaUNBQW1DOztJQUNuQyw4QkFBZ0M7O0lBQ2hDLDZCQUEwQjs7Ozs7SUFFMUIscUNBQXlEOztJQUN6RCxzQ0FBcUM7O0lBRXJDLG1DQUFnRjs7SUFFaEYsa0NBR0U7Ozs7O0lBRVcsNkJBQW9COzs7OztJQUNwQiwyQkFBNkIiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBDb21wb25lbnQsIE9uSW5pdCwgSW5wdXQsIE91dHB1dCwgRXZlbnRFbWl0dGVyLCBWaWV3Q2hpbGQsIEVsZW1lbnRSZWYsIENoYW5nZURldGVjdG9yUmVmLCBmb3J3YXJkUmVmIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBCYXNlIH0gZnJvbSAnLi4vLi4vLi4vbW9kZWxzL3NyYy9iYXNlJztcbmltcG9ydCB7IFNpbXBsZURhdGUgfSBmcm9tICcuLi8uLi8uLi9tb2RlbHMvc3JjL3NpbXBsZS1kYXRlLmludGVyZmFjZSc7XG5pbXBvcnQgeyBDb250cm9sQ29udGFpbmVyLCBOZ0Zvcm0sIE5nTW9kZWwgfSBmcm9tICdAYW5ndWxhci9mb3Jtcyc7XG5pbXBvcnQgKiBhcyBtb21lbnRfIGZyb20gJ21vbWVudCc7XG5jb25zdCBtb21lbnQgPSBtb21lbnRfO1xuXG4vKipcbiAqIENvbXBvbmVudCBOUE0gcGFja2FnZSBkZXBlbmRlbmNpZXM6XG4gKiBhKSBtb21lbnRcbiAqL1xuXG5leHBvcnQgaW50ZXJmYWNlIERhdGVFcnJvck1zZyB7XG4gIHJlcXVpcmVkOiBzdHJpbmc7XG4gIGRheU91dE9mUmFuZ2U/OiBzdHJpbmc7XG4gIHllYXJEaXN0YW50UGFzdD86IHN0cmluZztcbiAgeWVhckRpc3RhbnRGdXR1cmU/OiBzdHJpbmc7XG4gIG5vUGFzdERhdGVzQWxsb3dlZD86IHN0cmluZztcbiAgbm9GdXR1cmVEYXRlc0FsbG93ZWQ/OiBzdHJpbmc7XG4gIGludmFsaWRWYWx1ZT86IHN0cmluZztcbn1cblxuQENvbXBvbmVudCh7XG4gIHNlbGVjdG9yOiAnY29tbW9uLWRhdGUnLFxuICB0ZW1wbGF0ZVVybDogJy4vZGF0ZS5jb21wb25lbnQuaHRtbCcsXG4gIHN0eWxlVXJsczogWycuL2RhdGUuY29tcG9uZW50LnNjc3MnXSxcbiAgLyogUmUtdXNlIHRoZSBzYW1lIG5nRm9ybSB0aGF0IGl0J3MgcGFyZW50IGlzIHVzaW5nLiBUaGUgY29tcG9uZW50IHdpbGwgc2hvd1xuICAgKiB1cCBpbiBpdHMgcGFyZW50cyBgdGhpcy5mb3JtYCwgYW5kIHdpbGwgYXV0by11cGRhdGUgYHRoaXMuZm9ybS52YWxpZGBcbiAgICovXG4gIHZpZXdQcm92aWRlcnM6IFsgeyBwcm92aWRlOiBDb250cm9sQ29udGFpbmVyLCB1c2VFeGlzdGluZzogZm9yd2FyZFJlZigoKSA9PiBOZ0Zvcm0gKSB9IF1cbn0pXG5leHBvcnQgY2xhc3MgRGF0ZUNvbXBvbmVudCBleHRlbmRzIEJhc2UgaW1wbGVtZW50cyBPbkluaXQge1xuICAvLyBFeGlzdHMgZm9yIHVuaXQgdGVzdGluZyB0byB2YWxpZGF0ZSBlcnJvcnMgc2V0XG4gIEBWaWV3Q2hpbGQoICdtb250aFJlZicgKSBtb250aFJlZjogTmdNb2RlbDtcbiAgQFZpZXdDaGlsZCggJ2RheVJlZicgKSBkYXlSZWY6IE5nTW9kZWw7XG4gIEBWaWV3Q2hpbGQoICd5ZWFyUmVmJykgeWVhclJlZjogTmdNb2RlbDtcblxuICBASW5wdXQoKSB1c2VDdXJyZW50RGF0ZTogYm9vbGVhbiA9IGZhbHNlO1xuICBASW5wdXQoKSByZXF1aXJlZDogYm9vbGVhbiA9IHRydWU7XG4gIEBJbnB1dCgpIGRpc2FibGVkOiBib29sZWFuID0gZmFsc2U7XG4gIEBJbnB1dCgpIGxhYmVsOiBzdHJpbmcgPSAnRGF0ZSc7XG4gIEBJbnB1dCgpIGRhdGU6IFNpbXBsZURhdGU7XG4gIC8qKiBDYW4gYmUgb25lIG9mOiBcImZ1dHVyZVwiLCBcInBhc3RcIi4gXCJmdXR1cmVcIiBpbmNsdWRlcyB0b2RheSwgXCJwYXN0XCIgZG9lcyBub3QuICovXG4gIEBJbnB1dCgpIHJlc3RyaWN0RGF0ZTogJ2Z1dHVyZScgfCAncGFzdCcgfCAnYW55JyA9ICdhbnknO1xuICBASW5wdXQoKSBlcnJvck1lc3NhZ2VzOiBEYXRlRXJyb3JNc2c7XG5cbiAgQE91dHB1dCgpIGRhdGVDaGFuZ2U6IEV2ZW50RW1pdHRlcjxTaW1wbGVEYXRlPiA9IG5ldyBFdmVudEVtaXR0ZXI8U2ltcGxlRGF0ZT4oKTtcblxuICBwdWJsaWMgbW9udGhMaXN0OiBzdHJpbmdbXSA9IFtcbiAgICAnSmFudWFyeScsICdGZWJydWFyeScsICdNYXJjaCcsICdBcHJpbCcsICdNYXknLCAnSnVuZScsXG4gICAgJ0p1bHknLCAnQXVndXN0JywgJ1NlcHRlbWJlcicsICdPY3RvYmVyJywgJ05vdmVtYmVyJywgJ0RlY2VtYmVyJ1xuICBdO1xuXG4gIGNvbnN0cnVjdG9yKCBwcml2YXRlIGZvcm06IE5nRm9ybSxcbiAgICAgICAgICAgICAgIHByaXZhdGUgY2Q6IENoYW5nZURldGVjdG9yUmVmICkge1xuICAgIHN1cGVyKCk7XG4gIH1cblxuICBuZ09uSW5pdCgpIHtcbiAgICBpZiAoICF0aGlzLmVycm9yTWVzc2FnZXMgKSB7XG4gICAgICAvLyBVc2UgZGVmYXVsdCBtZXNzYWdlc1xuICAgICAgdGhpcy5lcnJvck1lc3NhZ2VzID0ge1xuICAgICAgICByZXF1aXJlZDogdGhpcy5sYWJlbCArICcgaXMgcmVxdWlyZWQuJyxcbiAgICAgICAgZGF5T3V0T2ZSYW5nZTogJ0ludmFsaWQgJyArIHRoaXMubGFiZWwgKyAnLicsXG4gICAgICAgIHllYXJEaXN0YW50UGFzdDogJ0ludmFsaWQgJyArIHRoaXMubGFiZWwgKyAnLicsXG4gICAgICAgIHllYXJEaXN0YW50RnV0dXJlOiAnSW52YWxpZCAnICsgdGhpcy5sYWJlbCArICcuJyxcbiAgICAgICAgbm9GdXR1cmVEYXRlc0FsbG93ZWQ6ICdJbnZhbGlkICcgKyB0aGlzLmxhYmVsICsgJy4nLFxuICAgICAgICBpbnZhbGlkVmFsdWU6ICdJbnZhbGlkICcgKyB0aGlzLmxhYmVsICsgJy4nXG4gICAgICB9O1xuICAgIH1cblxuICAgIGlmICggdGhpcy51c2VDdXJyZW50RGF0ZSApIHtcbiAgICAgIC8vIFNldCBkYXRlIHRvIGN1cnJlbnQgZGF0ZVxuICAgICAgdGhpcy5kYXRlLm1vbnRoID0gbW9tZW50KCkubW9udGgoKTtcbiAgICAgIHRoaXMuZGF0ZS5kYXkgPSBtb21lbnQoKS5kYXRlKCk7XG4gICAgICB0aGlzLmRhdGUueWVhciA9IG1vbWVudCgpLnllYXIoKTtcbiAgICB9XG4gIH1cblxuICAvKiogU2V0IHRoZSBtb250aCBhbmQgbm90aWZ5IGNhbGxlciBvZiBjaGFuZ2UgKi9cbiAgc2V0TW9udGgoIHZhbHVlOiBzdHJpbmcgKTogdm9pZCB7XG4gICAgY29uc3QgbW9udGggPSB0aGlzLmdldE51bWVyaWNWYWx1ZSggdmFsdWUgKTtcblxuICAgIC8vIGNvbnNvbGUubG9nKCAnbW9udGhSZWY6ICcsIHRoaXMubW9udGhSZWYgKTtcbiAgICBpZiAoIHRoaXMuZGF0ZSApIHtcbiAgICAgIHRoaXMuZGF0ZS5tb250aCA9IG1vbnRoO1xuICAgICAgdGhpcy50cmlnZ2VyRGF5VmFsaWRhdGlvbigpO1xuICAgICAgdGhpcy5kYXRlQ2hhbmdlLmVtaXQoIHRoaXMuZGF0ZSApO1xuICAgIH1cbiAgfVxuXG4gIC8qKiBTZXQgdGhlIGRheSBhbmQgbm90aWZ5IGNhbGxlciBvZiBjaGFuZ2UgKi9cbiAgc2V0RGF5KCB2YWx1ZTogc3RyaW5nICk6IHZvaWQge1xuICAgIGNvbnN0IGRheSA9IHRoaXMuZ2V0TnVtZXJpY1ZhbHVlKCB2YWx1ZSApO1xuXG4gICAgLy8gY29uc29sZS5sb2coICAnZGF5UmVmOiAnLCB0aGlzLmRheVJlZiApO1xuICAgIGlmICggdGhpcy5kYXRlICkge1xuICAgICAgdGhpcy5kYXRlLmRheSA9IGRheTtcbiAgICAgIHRoaXMuZGF0ZUNoYW5nZS5lbWl0KCB0aGlzLmRhdGUgKTtcbiAgICB9XG4gIH1cblxuICAvKiogU2V0IHRoZSB5ZXJhIGFuZCBub3RpZnkgY2FsbGVyIG9mIGNoYW5nZSAqL1xuICBzZXRZZWFyKCB2YWx1ZTogc3RyaW5nICk6IHZvaWQge1xuICAgIGNvbnN0IHllYXIgPSB0aGlzLmdldE51bWVyaWNWYWx1ZSggdmFsdWUgKTtcblxuICAgIC8vIGNvbnNvbGUubG9nKCAneWVhclJlZjogJywgdGhpcy55ZWFyUmVmICk7XG4gICAgaWYgKCB0aGlzLmRhdGUgKSB7XG4gICAgICB0aGlzLmRhdGUueWVhciA9IHllYXI7XG4gICAgICB0aGlzLnRyaWdnZXJEYXlWYWxpZGF0aW9uKCk7XG4gICAgICB0aGlzLmRhdGVDaGFuZ2UuZW1pdCggdGhpcy5kYXRlICk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEZvcmNlIHRoZSBgZGF5YCBpbnB1dCB0byBydW4gaXQncyBkaXJlY3RpdmVzIGFnYWluLiBJbXBvcnRhbnQgaW4gY2FzZXNcbiAgICogd2hlcmUgdXNlciBmaWxscyBmaWVsZHMgb3V0IG9mIG9yZGVyLCBlLmcuIHNldHMgZGF5cyB0byAzMSB0aGVuIG1vbnRoIHRvXG4gICAqIEZlYnJ1cmFyeS5cbiAgICovXG4gIHByaXZhdGUgdHJpZ2dlckRheVZhbGlkYXRpb24oKSB7XG4gICAgLy8gV2UgaGF2ZSB0byB3cmFwIHRoaXMgaW4gYSB0aW1lb3V0LCBvdGhlcndpc2UgaXQgcnVucyBiZWZvcmUgQW5ndWxhciBoYXMgdXBkYXRlZCB0aGUgdmFsdWVzXG4gICAgc2V0VGltZW91dCggKCkgPT4ge1xuICAgICAgaWYgKCB0aGlzLmZvcm0uY29udHJvbHNbJ2RheSddICkge1xuICAgICAgICAvLyBjb25zb2xlLmxvZyggJ1RyaWdnZXIgZGF5IHZhbGlkYXRpb24nICk7XG4gICAgICAgIHRoaXMuZm9ybS5jb250cm9sc1snZGF5J10udXBkYXRlVmFsdWVBbmRWYWxpZGl0eSgpO1xuICAgICAgICB0aGlzLmNkLmRldGVjdENoYW5nZXMoKTtcbiAgICAgIH1cbiAgICB9LCAwKTtcbiAgfVxuXG4gIC8qKiBDb252ZXJ0IHN0cmluZyB0byBudW1lcmljIHZhbHVlIG9yIG51bGwgaWYgbm90ICovXG4gIHByaXZhdGUgZ2V0TnVtZXJpY1ZhbHVlKCB2YWx1ZTogc3RyaW5nICk6IG51bWJlciB8IG51bGwge1xuICAgIGNvbnN0IHBhcnNlZCA9IHBhcnNlSW50KCB2YWx1ZSwgMTAgKTtcbiAgICByZXR1cm4gKCBpc05hTiggcGFyc2VkICkgPyBudWxsIDogcGFyc2VkICk7XG4gIH1cbn1cbiJdfQ==