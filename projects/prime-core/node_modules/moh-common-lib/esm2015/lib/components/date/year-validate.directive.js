/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
import { Directive, forwardRef, Input } from '@angular/core';
import { NG_VALIDATORS } from '@angular/forms';
import * as moment_ from 'moment';
/** @type {?} */
const moment = moment_;
// TODO:  Create a message structure to pass in error messages similar to password module.
export class YearValidateDirective {
    /**
     * @param {?} control
     * @return {?}
     */
    validate(control) {
        /** @type {?} */
        const date = control.parent.value;
        // console.log( 'validate year: ', control.value );
        if (!control.value) {
            return null; // empty value
        }
        /** @type {?} */
        const year = parseInt(control.value, 10);
        // Only process if value is numeric
        if (!isNaN(year)) {
            /** @type {?} */
            const currentYear = moment().get('y');
            if (currentYear - year > 150) {
                return { 'yearDistantPast': true };
            }
            if (year - currentYear > 150) {
                return { 'yearDistantFuture': true };
            }
            // Check whether dates can be present or past
            if (this.commonYearValidate && this.commonYearValidate !== 'any' &&
                !isNaN(date.day) && !isNaN(date.month)) {
                /** @type {?} */
                const diff = moment({ year: year, month: date.month, day: date.day })
                    .diff(moment(), 'days', true);
                /**
                 * Validate current date as if it's a future date, and reject it when only
                 * accepting past dates.  We accomplish this by comparing diff against 1.
                 */
                if (diff < -1 && this.commonYearValidate === 'future') {
                    return { 'noPastDatesAllowed': true };
                }
                if (diff >= -1 && this.commonYearValidate === 'past') {
                    return { 'noFutureDatesAllowed': true };
                }
            }
            return null;
        }
        return { 'invalidValue': true };
    }
}
YearValidateDirective.decorators = [
    { type: Directive, args: [{
                selector: '[commonYearValidate]',
                providers: [
                    { provide: NG_VALIDATORS, useExisting: forwardRef((/**
                         * @return {?}
                         */
                        () => YearValidateDirective)), multi: true }
                ]
            },] }
];
YearValidateDirective.propDecorators = {
    commonYearValidate: [{ type: Input }]
};
if (false) {
    /** @type {?} */
    YearValidateDirective.prototype.commonYearValidate;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoieWVhci12YWxpZGF0ZS5kaXJlY3RpdmUuanMiLCJzb3VyY2VSb290Ijoibmc6Ly9tb2gtY29tbW9uLWxpYi8iLCJzb3VyY2VzIjpbImxpYi9jb21wb25lbnRzL2RhdGUveWVhci12YWxpZGF0ZS5kaXJlY3RpdmUudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7OztBQUFBLE9BQU8sRUFBRSxTQUFTLEVBQUUsVUFBVSxFQUFFLEtBQUssRUFBRSxNQUFNLGVBQWUsQ0FBQztBQUM3RCxPQUFPLEVBQUUsYUFBYSxFQUEwQixNQUFNLGdCQUFnQixDQUFDO0FBQ3ZFLE9BQU8sS0FBSyxPQUFPLE1BQU0sUUFBUSxDQUFDOztNQUM1QixNQUFNLEdBQUcsT0FBTzs7QUFVdEIsTUFBTSxPQUFPLHFCQUFxQjs7Ozs7SUFJaEMsUUFBUSxDQUFFLE9BQW9COztjQUN0QixJQUFJLEdBQUcsT0FBTyxDQUFDLE1BQU0sQ0FBQyxLQUFLO1FBRWpDLG1EQUFtRDtRQUVuRCxJQUFLLENBQUMsT0FBTyxDQUFDLEtBQUssRUFBRztZQUNwQixPQUFPLElBQUksQ0FBQyxDQUFDLGNBQWM7U0FDNUI7O2NBRUssSUFBSSxHQUFXLFFBQVEsQ0FBRSxPQUFPLENBQUMsS0FBSyxFQUFFLEVBQUUsQ0FBRTtRQUVsRCxtQ0FBbUM7UUFDbkMsSUFBSyxDQUFDLEtBQUssQ0FBRyxJQUFJLENBQUUsRUFBRzs7a0JBQ2YsV0FBVyxHQUFHLE1BQU0sRUFBRSxDQUFDLEdBQUcsQ0FBRSxHQUFHLENBQUU7WUFFdkMsSUFBSyxXQUFXLEdBQUcsSUFBSSxHQUFHLEdBQUcsRUFBRztnQkFDOUIsT0FBTyxFQUFFLGlCQUFpQixFQUFFLElBQUksRUFBRSxDQUFDO2FBQ3BDO1lBRUQsSUFBSyxJQUFJLEdBQUcsV0FBVyxHQUFHLEdBQUcsRUFBRztnQkFDOUIsT0FBTyxFQUFFLG1CQUFtQixFQUFFLElBQUksRUFBQyxDQUFFO2FBQ3RDO1lBRUQsNkNBQTZDO1lBQzdDLElBQUssSUFBSSxDQUFDLGtCQUFrQixJQUFJLElBQUksQ0FBQyxrQkFBa0IsS0FBSyxLQUFLO2dCQUM1RCxDQUFDLEtBQUssQ0FBRSxJQUFJLENBQUMsR0FBRyxDQUFFLElBQUssQ0FBQyxLQUFLLENBQUUsSUFBSSxDQUFDLEtBQUssQ0FBRSxFQUFHOztzQkFFM0MsSUFBSSxHQUFHLE1BQU0sQ0FBRSxFQUFFLElBQUksRUFBRSxJQUFJLEVBQUUsS0FBSyxFQUFFLElBQUksQ0FBQyxLQUFLLEVBQUUsR0FBRyxFQUFFLElBQUksQ0FBQyxHQUFHLEVBQUUsQ0FBRTtxQkFDcEUsSUFBSSxDQUFFLE1BQU0sRUFBRSxFQUFFLE1BQU0sRUFBRSxJQUFJLENBQUU7Z0JBRWhDOzs7bUJBR0c7Z0JBQ0YsSUFBSyxJQUFJLEdBQUcsQ0FBQyxDQUFDLElBQUksSUFBSSxDQUFDLGtCQUFrQixLQUFLLFFBQVEsRUFBRztvQkFDdkQsT0FBTyxFQUFFLG9CQUFvQixFQUFFLElBQUksRUFBRSxDQUFDO2lCQUN2QztnQkFFRCxJQUFLLElBQUksSUFBSSxDQUFDLENBQUMsSUFBSSxJQUFJLENBQUMsa0JBQWtCLEtBQUssTUFBTSxFQUFHO29CQUN0RCxPQUFPLEVBQUUsc0JBQXNCLEVBQUUsSUFBSSxFQUFFLENBQUM7aUJBQ3pDO2FBQ0o7WUFFRCxPQUFPLElBQUksQ0FBQztTQUNiO1FBRUQsT0FBTyxFQUFFLGNBQWMsRUFBRSxJQUFJLEVBQUUsQ0FBQztJQUNsQyxDQUFDOzs7WUF6REYsU0FBUyxTQUFDO2dCQUNULFFBQVEsRUFBRSxzQkFBc0I7Z0JBQ2hDLFNBQVMsRUFBRTtvQkFDVCxFQUFDLE9BQU8sRUFBRSxhQUFhLEVBQUUsV0FBVyxFQUFFLFVBQVU7Ozt3QkFBQyxHQUFHLEVBQUUsQ0FBQyxxQkFBcUIsRUFBQyxFQUFFLEtBQUssRUFBRSxJQUFJLEVBQUM7aUJBQzVGO2FBQ0Y7OztpQ0FHRSxLQUFLOzs7O0lBQU4sbURBQW9DIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgRGlyZWN0aXZlLCBmb3J3YXJkUmVmLCBJbnB1dCB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgTkdfVkFMSURBVE9SUywgVmFsaWRhdG9yLCBGb3JtQ29udHJvbCB9IGZyb20gJ0Bhbmd1bGFyL2Zvcm1zJztcbmltcG9ydCAqIGFzIG1vbWVudF8gZnJvbSAnbW9tZW50JztcbmNvbnN0IG1vbWVudCA9IG1vbWVudF87XG5cbi8vIFRPRE86ICBDcmVhdGUgYSBtZXNzYWdlIHN0cnVjdHVyZSB0byBwYXNzIGluIGVycm9yIG1lc3NhZ2VzIHNpbWlsYXIgdG8gcGFzc3dvcmQgbW9kdWxlLlxuXG5ARGlyZWN0aXZlKHtcbiAgc2VsZWN0b3I6ICdbY29tbW9uWWVhclZhbGlkYXRlXScsXG4gIHByb3ZpZGVyczogW1xuICAgIHtwcm92aWRlOiBOR19WQUxJREFUT1JTLCB1c2VFeGlzdGluZzogZm9yd2FyZFJlZigoKSA9PiBZZWFyVmFsaWRhdGVEaXJlY3RpdmUpLCBtdWx0aTogdHJ1ZX1cbiAgXVxufSlcbmV4cG9ydCBjbGFzcyBZZWFyVmFsaWRhdGVEaXJlY3RpdmUgaW1wbGVtZW50cyBWYWxpZGF0b3IgIHtcblxuICBASW5wdXQoKSBjb21tb25ZZWFyVmFsaWRhdGU6IHN0cmluZztcblxuICB2YWxpZGF0ZSggY29udHJvbDogRm9ybUNvbnRyb2wgKToge1trZXk6IHN0cmluZ106IGFueX0gfCBudWxsIHtcbiAgICBjb25zdCBkYXRlID0gY29udHJvbC5wYXJlbnQudmFsdWU7XG5cbiAgICAvLyBjb25zb2xlLmxvZyggJ3ZhbGlkYXRlIHllYXI6ICcsIGNvbnRyb2wudmFsdWUgKTtcblxuICAgIGlmICggIWNvbnRyb2wudmFsdWUgKSB7XG4gICAgICByZXR1cm4gbnVsbDsgLy8gZW1wdHkgdmFsdWVcbiAgICB9XG5cbiAgICBjb25zdCB5ZWFyOiBudW1iZXIgPSBwYXJzZUludCggY29udHJvbC52YWx1ZSwgMTAgKTtcblxuICAgIC8vIE9ubHkgcHJvY2VzcyBpZiB2YWx1ZSBpcyBudW1lcmljXG4gICAgaWYgKCAhaXNOYU4oICB5ZWFyICkgKSB7XG4gICAgICBjb25zdCBjdXJyZW50WWVhciA9IG1vbWVudCgpLmdldCggJ3knICk7XG5cbiAgICAgIGlmICggY3VycmVudFllYXIgLSB5ZWFyID4gMTUwICkge1xuICAgICAgICByZXR1cm4geyAneWVhckRpc3RhbnRQYXN0JzogdHJ1ZSB9O1xuICAgICAgfVxuXG4gICAgICBpZiAoIHllYXIgLSBjdXJyZW50WWVhciA+IDE1MCApIHtcbiAgICAgICAgcmV0dXJuIHsgJ3llYXJEaXN0YW50RnV0dXJlJzogdHJ1ZX0gO1xuICAgICAgfVxuXG4gICAgICAvLyBDaGVjayB3aGV0aGVyIGRhdGVzIGNhbiBiZSBwcmVzZW50IG9yIHBhc3RcbiAgICAgIGlmICggdGhpcy5jb21tb25ZZWFyVmFsaWRhdGUgJiYgdGhpcy5jb21tb25ZZWFyVmFsaWRhdGUgIT09ICdhbnknICYmXG4gICAgICAgICAgICFpc05hTiggZGF0ZS5kYXkgKSAgJiYgIWlzTmFOKCBkYXRlLm1vbnRoICkgKSB7XG5cbiAgICAgICAgY29uc3QgZGlmZiA9IG1vbWVudCggeyB5ZWFyOiB5ZWFyLCBtb250aDogZGF0ZS5tb250aCwgZGF5OiBkYXRlLmRheSB9IClcbiAgICAgICAgICAuZGlmZiggbW9tZW50KCksICdkYXlzJywgdHJ1ZSApO1xuXG4gICAgICAgICAvKipcbiAgICAgICAgICAqIFZhbGlkYXRlIGN1cnJlbnQgZGF0ZSBhcyBpZiBpdCdzIGEgZnV0dXJlIGRhdGUsIGFuZCByZWplY3QgaXQgd2hlbiBvbmx5XG4gICAgICAgICAgKiBhY2NlcHRpbmcgcGFzdCBkYXRlcy4gIFdlIGFjY29tcGxpc2ggdGhpcyBieSBjb21wYXJpbmcgZGlmZiBhZ2FpbnN0IDEuXG4gICAgICAgICAgKi9cbiAgICAgICAgICBpZiAoIGRpZmYgPCAtMSAmJiB0aGlzLmNvbW1vblllYXJWYWxpZGF0ZSA9PT0gJ2Z1dHVyZScgKSB7XG4gICAgICAgICAgICByZXR1cm4geyAnbm9QYXN0RGF0ZXNBbGxvd2VkJzogdHJ1ZSB9O1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmICggZGlmZiA+PSAtMSAmJiB0aGlzLmNvbW1vblllYXJWYWxpZGF0ZSA9PT0gJ3Bhc3QnICkge1xuICAgICAgICAgICAgcmV0dXJuIHsgJ25vRnV0dXJlRGF0ZXNBbGxvd2VkJzogdHJ1ZSB9O1xuICAgICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgcmV0dXJuIHsgJ2ludmFsaWRWYWx1ZSc6IHRydWUgfTtcbiAgfVxuXG59XG4iXX0=