/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
import { ChangeDetectorRef, Component, ElementRef, EventEmitter, Input, NgZone, Output, ViewChild, forwardRef } from '@angular/core';
import { NgForm, ControlContainer } from '@angular/forms';
import { Observable, fromEvent, merge } from 'rxjs';
import { map, filter, flatMap, scan, delay, retryWhen } from 'rxjs/operators';
import { CommonImage, CommonImageError, CommonImageProcessingError, CommonImageScaleFactorsImpl } from '../../../images/src/public_api';
// import { MspLogService } from '../../service/log.service';
// import { MspDataService } from '../../service/msp-data.service';
// import { BaseComponent } from '../base.component';
// import { LogEntry } from '../logging/log-entry.model';
// import {Person} from '../../model/application.model';
import { Router } from '@angular/router';
import { Base } from '../../../models/src/base';
// import {ApplicationBase} from '../../model/application-base.model';
// const loadImage = require('blueimp-load-image');
// const sha1 = require('sha1');
import * as loadImage_ from 'blueimp-load-image';
/** @type {?} */
const loadImage = loadImage_;
import * as sha1_ from 'sha1';
/** @type {?} */
const sha1 = sha1_;
// const PDFJS: PDFJSStatic = require('pdfjs-dist');
import * as PDFJS_ from 'pdfjs-dist';
/** @type {?} */
const PDFJS = ((/** @type {?} */ (PDFJS_)));
/**
 * @record
 */
export function FileUploaderMsg() { }
if (false) {
    /** @type {?} */
    FileUploaderMsg.prototype.required;
}
// TODO - Remove this and fix tslint issues
/* tslint:disable:max-line-length*/
export class FileUploaderComponent extends Base {
    /**
     * @param {?} zone
     * @param {?} cd
     * @param {?} router
     * @param {?} controlContainer
     */
    constructor(zone, cd, router, controlContainer) {
        super();
        this.zone = zone;
        this.cd = cd;
        this.router = router;
        this.controlContainer = controlContainer;
        // lang = require('./i18n');
        this.noIdImage = false;
        // @ContentChild('uploadInstruction') uploadInstructionRef: ElementRef;
        this.images = new Array(0);
        this.imagesChange = new EventEmitter();
        this.required = false;
        this.instructionText = 'Please upload required ID documents.';
        this.errorMessages = { required: 'File is required.' };
        this.errorDocument = new EventEmitter();
        // this.application = this.getApplicationType();
    }
    /**
     * This is created as a workaround to access the form control that binds to
     * the input[type='file']. We can't access it via the template name bindings
     * as that isn't working, so instead we access the parent form and then find
     * the input by name.
     * @return {?}
     */
    get fileControl() {
        /** @type {?} */
        const INPUT_NAME = `fileUploadBrowse-${this.id}`;
        // note - should be "this.controlContainer as NgForm" here, which works,
        // but fails on compiliation due to secondary entries
        return ((/** @type {?} */ (this.controlContainer))).controls[INPUT_NAME];
    }
    /**
     * Return true if file already exists in the list; false otherwise.
     * @param {?} file
     * @param {?} imageList
     * @return {?}
     */
    static checkImageExists(file, imageList) {
        if (!imageList || imageList.length < 1) {
            return false;
        }
        else {
            /** @type {?} */
            const sha1Sum = sha1(file.fileContent);
            for (let i = imageList.length - 1; i >= 0; i--) {
                // console.log(`compare  ${imageList[i].id} with ${sha1Sum}, result ${imageList[i].id === sha1Sum}`);
                if (imageList[i].id === sha1Sum) {
                    console.log(`This file ${file.name} has already been uploaded.`);
                    return true;
                }
            }
            return false;
        }
    }
    /**
     * A special method to force the rendering of this component.  This is a workaround
     * because for some unknown reason, AngularJS2 change detector does not detect the
     * change of the images Array.
     * @return {?}
     */
    forceRender() {
        this.zone.run((/**
         * @return {?}
         */
        () => {
        }));
    }
    /**
     * @param {?} changes
     * @return {?}
     */
    ngOnChanges(changes) {
        console.log('fileuploader onChanges', changes['images']);
        // if (changes['images'] && (changes['images'].currentValue.length === 0 &&
        //   changes['images'].previousValue.length > 0)) {
        if (changes['images'] && (changes['images'].currentValue.length === 0
            && changes['images'].previousValue
            && changes['images'].previousValue.length > 0)) {
            this.noIdImage = true;
        }
        else {
            this.noIdImage = false;
        }
    }
    /*
         System processing steps
    
         1. User clicks browse or drag-n-drops an file
         2. For browse case, the browser is told to only accept mime type image/*, .JPG, .GIF, .PNG, etc,
         however user can override and for drag-n-drop we don't can't impose this filter
         4. Using the HTML5 File API, we open a handle on the file
         5. Read the filename for later display to the user
         6. Create a hidden Image element in the browser's DOM
         7. Read the file's bytes as a DataUrl and copy them into the Image element
         8. Wait until the Image finishes loading the image
         9. Read the image element's natural width and height
         10. Pass the File handle into a HTML5 Canvas lib (we need the XIFF headers to auto rotate, XIFF headers are not available in DataUrl)
         11. The Canvas errors because it's a wrong type, e.g., TIFF, we abort and notify user
         12. Instruct the Canvas lib to keep resizing the image if it exceeds a maximum width or height,
         extract meta data, and auto-orient based on XIFF metadata.  It uses a "contain" operation which retains
         it's width to height pixel ratio.
         13. Call a function on the Canvas element to turn the Canvas into a JPEG of quality 50%.
         14. Once in a Blob with get the blob size in bytes and a human friendly display size
         15. In order to more easily manage the image, we convert the Blob to a DataUrl again.
         16. Pass the DataUrl into a hash algorithm to create an identifier and to check if the image has already been uploaded
         17. Next we check the final size of the image to ensure it's not to small in resolution
         (arguably this could've been done earlier), if too small we notify user
         18. Finally, the image is saved into the user's ongoing EA/PA application including localstorage
         19. The image is displayed to user as a thumbnail
    
         */
    /**
     * @return {?}
     */
    ngOnInit() {
        /** @type {?} */
        const dragOverStream = fromEvent(this.dropZone.nativeElement, 'dragover');
        /**
         * Must cancel the dragover event in order for the drop event to work.
         */
        dragOverStream.pipe(map((/**
         * @param {?} evt
         * @return {?}
         */
        evt => {
            return event;
        }))).subscribe((/**
         * @param {?} evt
         * @return {?}
         */
        evt => {
            // console.log('Cancel dragover event.');
            evt.preventDefault();
        }));
        /** @type {?} */
        const dropStream = fromEvent(this.dropZone.nativeElement, 'drop');
        /** @type {?} */
        const filesArrayFromDrop = dropStream.pipe(map((/**
         * @param {?} event
         * @return {?}
         */
        function (event) {
            event.preventDefault();
            return event.dataTransfer.files;
        })));
        /** @type {?} */
        const browseFileStream = fromEvent(this.browseFileRef.nativeElement, 'change');
        // const captureFileStream = fromEvent<Event>(this.captureFileRef.nativeElement, 'change');
        merge(merge(browseFileStream).pipe(map((/**
         * @param {?} event
         * @return {?}
         */
        (event) => {
            event.preventDefault();
            return event.target['files'];
        }))), filesArrayFromDrop).pipe(filter((/**
         * @param {?} files
         * @return {?}
         */
        files => {
            console.log('files');
            return !!files && files.length && files.length > 0;
        })), flatMap((/**
         * @param {?} fileList
         * @return {?}
         */
        (fileList) => {
            return this.observableFromFiles(fileList, new CommonImageScaleFactorsImpl(1, 1));
        })), filter((/**
         * @param {?} mspImage
         * @return {?}
         */
        (mspImage) => {
            /** @type {?} */
            const imageExists = FileUploaderComponent.checkImageExists(mspImage, this.images);
            if (imageExists) {
                this.handleError(CommonImageError.AlreadyExists, mspImage);
                this.resetInputFields();
            }
            return !imageExists;
        })), 
        // TODO - Is this necessary? Can likely be removed as it's exactly identical to the preceding.
        filter((/**
         * @param {?} mspImage
         * @return {?}
         */
        (mspImage) => {
            /** @type {?} */
            const imageExists = FileUploaderComponent.checkImageExists(mspImage, this.images);
            if (imageExists) {
                this.handleError(CommonImageError.AlreadyExists, mspImage);
                this.resetInputFields();
            }
            return !imageExists;
        })), filter((/**
         * @param {?} mspImage
         * @return {?}
         */
        (mspImage) => {
            /** @type {?} */
            const imageSizeOk = this.checkImageDimensions(mspImage);
            if (!imageSizeOk) {
                this.handleError(CommonImageError.TooSmall, mspImage);
                this.resetInputFields();
            }
            return imageSizeOk;
        }))).subscribe((/**
         * @param {?} file
         * @return {?}
         */
        (file) => {
            this.handleImageFile(file);
            this.resetInputFields();
        }), (/**
         * @param {?} error
         * @return {?}
         */
        (error) => {
            console.log('Error in loading image: %o', error);
            /**
             * Handle the error if the image is gigantic that after
             * 100 times of scaling down by 30% on each step, the image
             * is still over 1 MB.
             */
            if (error.errorCode) {
                if (CommonImageError.TooBig === error.errorCode) {
                    this.handleError(CommonImageError.TooBig, error.image);
                }
                else if (CommonImageError.CannotOpen === error.errorCode) {
                    if (!error.image) {
                        error.image = new CommonImage();
                        if (error.rawImageFile) {
                            error.image.name = error.rawImageFile.name;
                        }
                    }
                    this.handleError(CommonImageError.CannotOpen, error.image);
                }
                else if (CommonImageError.CannotOpenPDF === error.errorCode) {
                    this.handleError(CommonImageError.CannotOpenPDF, error.image, error.errorDescription);
                }
                else {
                    throw error;
                }
            }
        }), (/**
         * @return {?}
         */
        () => {
            console.log('completed loading image');
        }));
    }
    /**
     * @param {?} var1
     * @return {?}
     */
    test(var1) {
        console.log(var1);
    }
    /**
     * @return {?}
     */
    ngAfterContentInit() {
        /** @type {?} */
        const imagePlaceholderEnterKeyStream = merge(fromEvent(this.imagePlaceholderRef.nativeElement, 'keyup'), fromEvent(this.selectFileLabelRef.nativeElement, 'keyup')).pipe(filter((/**
         * @param {?} evt
         * @return {?}
         */
        (evt) => evt.key === 'Enter')));
        merge(fromEvent(this.imagePlaceholderRef.nativeElement, 'click'), 
        // fromEvent<Event>(this.uploadInstructionRef.nativeElement, 'click'),
        imagePlaceholderEnterKeyStream).pipe(map((/**
         * @param {?} event
         * @return {?}
         */
        (event) => {
            event.preventDefault();
            return event;
        }))).subscribe((/**
         * @param {?} event
         * @return {?}
         */
        (event) => { this.browseFileRef.nativeElement.click(); }));
    }
    /**
     * Solve size in this equation: size * 0.8to-the-power-of30 < 1MB, size
     * will be the max image size this application can accept and scale down
     * to under 1MB. In this case: size < 807 MB
     *
     * 30 is the number of retries. the value for maxRetry passed to retryStrategy
     * function.
     *
     * If: size * 0.8to-the-power-of40 < 1MB, then size < 1262 MB.
     *
     * Note: 0.8 is the self.appConstants.images.reductionScaleFactor defined in global.js
     *
     *
     * @param {?} fileList
     * @param {?} scaleFactors
     * @return {?}
     */
    observableFromFiles(fileList, scaleFactors) {
        /**
         * Previously this was set in appConstants, but that's removed from the common lib.
         * @type {?}
         */
        const reductionScaleFactor = 0.8;
        console.log('obserablveFromFiles');
        // Init
        /** @type {?} */
        const self = this;
        //    let  pageNumber = Math.max(...self.images.concat( self.application.getAllImages()).map(function(o) {return o.attachmentOrder; }), 0) + 1 ;
        /** @type {?} */
        let pageNumber = Math.max(...self.images.map((/**
         * @param {?} o
         * @return {?}
         */
        function (o) { return o.attachmentOrder; })), 0) + 1;
        // Create our observer
        /** @type {?} */
        const fileObservable = Observable.create((/**
         * @param {?} observer
         * @return {?}
         */
        (observer) => {
            /** @type {?} */
            const mspImages = [];
            scaleFactors = scaleFactors.scaleDown(reductionScaleFactor);
            for (let fileIndex = 0; fileIndex < fileList.length; fileIndex++) {
                /** @type {?} */
                const file = fileList[fileIndex];
                console.log('Start processing file ' + fileIndex + ' of ' + fileList.length + ' %s of size %s bytes %s type', file.name, file.size, file.type);
                /* Previously set in appConstants */
                /** @type {?} */
                const pdfScaleFactor = 2.0;
                // let mspImage: MspImage = new MspImage();
                // let reader: FileReader = new FileReader();
                // // Copy file properties
                // mspImage.name = file.name;
                if (file.type === 'application/pdf') {
                    // this.logService.log({name: file.name + ' Received in Upload',
                    //     UUID: self.dataService.getMspUuid()}, 'File_Upload');
                    /**
                     *  Page number logic :
                     *      Images - Assign current page number whichever is available..so get the current page number , pass it to call back [reserve it] and increment
                     *      PDF    -  we dont know how many pages..so cant get current number and keep it since it can be multiple pages... so start assigning later point
                     *      when PDF is totally read..
                     *
                     *  */
                    this.readPDF(file, pdfScaleFactor, (/**
                     * @param {?} images
                     * @param {?} pdfFile
                     * @return {?}
                     */
                    (images, pdfFile) => {
                        // this.logService.log({name: file.name + 'is successfully split into ' + images.length + ' images',
                        // UUID: self.dataService.getMspUuid()}, 'File_Upload');
                        images.map((/**
                         * @param {?} image
                         * @param {?} index
                         * @return {?}
                         */
                        (image, index) => {
                            image.name = pdfFile.name;
                            this.resizeImage(image, self, scaleFactors, observer, pageNumber, true); // index starts from zero
                            pageNumber = pageNumber + 1;
                        }));
                    }), (/**
                     * @param {?} error
                     * @return {?}
                     */
                    (error) => {
                        console.log('error' + JSON.stringify(error));
                        /** @type {?} */
                        const imageReadError = new CommonImageProcessingError(CommonImageError.CannotOpenPDF, error);
                        observer.error(imageReadError);
                    }));
                }
                else {
                    // Load image into img element to read natural height and width
                    this.readImage(file, pageNumber, (/**
                     * @param {?} image
                     * @param {?} imageFile
                     * @param {?} nextPageNumber
                     * @return {?}
                     */
                    (image, imageFile, nextPageNumber) => {
                        image.id = imageFile.name; // .name deprecated, changed image.name to image.id
                        this.resizeImage(image, self, scaleFactors, observer, nextPageNumber);
                    }), (
                    // can be ignored for bug, the log line is never called
                    /**
                     * @param {?} error
                     * @return {?}
                     */
                    (error) => {
                        console.log('error' + JSON.stringify(error));
                        observer.error(error);
                    }));
                    pageNumber = pageNumber + 1;
                }
            }
            // retryWhen is potential issue!
        })).pipe(retryWhen(this.retryStrategy(32)));
        return fileObservable;
    }
    /**
     * @private
     * @param {?} image
     * @param {?} self
     * @param {?} scaleFactors
     * @param {?} observer
     * @param {?=} pageNumber
     * @param {?=} isPdf
     * @return {?}
     */
    resizeImage(image, self, scaleFactors, observer, pageNumber = 0, isPdf = false) {
        // While it's still in an image, get it's height and width
        /** @type {?} */
        const mspImage = new CommonImage();
        /** @type {?} */
        const reader = new FileReader();
        console.log('image.name:' + image.id); // .name deprecated, changed image.name to image.id
        // Copy file properties
        mspImage.name = image.id;
        if (isPdf) {
            mspImage.name = image.name + '-page' + pageNumber; // Just give name to pdf
        }
        // Temporary so we don't have duplicate file names. TODO: Improve.
        //   mspImage.name += Math.ceil(Math.random()*100);
        mspImage.attachmentOrder = pageNumber;
        mspImage.naturalWidth = image.naturalWidth;
        mspImage.naturalHeight = image.naturalHeight;
        console.log(`image file natural height and width:
            ${mspImage.naturalHeight} x ${mspImage.naturalWidth}`);
        // Canvas will force the change to a JPEG
        mspImage.contentType = 'image/jpeg'; // previously in appConstants
        // Scale the image by loading into a canvas
        console.log('Start scaling down the image using blueimp-load-image lib: ');
        /** @type {?} */
        const scaledImage = loadImage(image.src, (
        // NOTE: we pass the File ref here again even though its already read because we need the XIFF metadata
        /**
         * @param {?} canvas
         * @param {?} metadata
         * @return {?}
         */
        function (canvas, metadata) {
            // Canvas may be an Event when errors happens
            if (canvas instanceof Event) {
                self.handleError(CommonImageError.WrongType, mspImage);
                self.resetInputFields();
                return;
            }
            // Convert to blob to get size
            canvas.toBlob((/**
             * @param {?} blob
             * @return {?}
             */
            (blob) => {
                // Copy the blob properties
                mspImage.size = blob.size;
                // log image info (but only for the first time before any scaling)
                // if (s
                /** @type {?} */
                const fileName = mspImage.name;
                /** @type {?} */
                const nBytes = mspImage.size;
                /** @type {?} */
                let fileSize = '';
                /** @type {?} */
                let fileSizeUnit = '';
                /** @type {?} */
                let sOutput = nBytes + ' bytes';
                // optional code for multiples approximation
                for (let aMultiples = ['KiB', 'MiB', 'GiB', 'TiB', 'PiB', 'EiB', 'ZiB', 'YiB'], nMultiple = 0, nApprox = nBytes / 1024; nApprox > 1; nApprox /= 1024, nMultiple++) {
                    sOutput = nApprox.toFixed(3) + ' ' + aMultiples[nMultiple] + ' (' + nBytes + ' bytes)';
                    fileSize = nApprox.toFixed(0);
                    fileSizeUnit = aMultiples[nMultiple];
                    mspImage.sizeUnit = fileSizeUnit;
                }
                console.log(`File ${fileName} is scaled down to: ${sOutput}`);
                mspImage.sizeTxt = sOutput;
                // call reader with new transformed image
                reader.onload = (/**
                 * @param {?} evt
                 * @return {?}
                 */
                function (evt) {
                    mspImage.fileContent = evt.target.result;
                    mspImage.id = sha1(mspImage.fileContent);
                    // keep scaling down the image until the image size is
                    // under max image size
                    /**
                     * previously in appConstants
                     * @type {?}
                     */
                    const maxSizeBytes = 1048576;
                    if (mspImage.size > maxSizeBytes) {
                        console.log('File size after scaling down: %d, max file size allowed: %d', mspImage.size, maxSizeBytes);
                        /** @type {?} */
                        const imageTooBigError = new CommonImageProcessingError(CommonImageError.TooBig);
                        imageTooBigError.maxSizeAllowed = maxSizeBytes;
                        imageTooBigError.commonImage = mspImage;
                        observer.error(imageTooBigError);
                    }
                    else {
                        // log image info
                        //   self.logImageInfo("msp_file-uploader_after_resize_attributes", self.dataService.getMspUuid(), mspImage);
                        observer.next(mspImage);
                    }
                });
                reader.readAsDataURL(blob);
            }), 
            // What mime type to make the blob as and jpeg quality
            'image/jpeg', 0.5);
        }), {
            maxWidth: 2600 * scaleFactors.widthFactor,
            maxHeight: 3300 * scaleFactors.heightFactor,
            contain: true,
            canvas: true,
            meta: true,
            orientation: true
        });
    }
    /**
     * Max retry scaling down for maxRetry times.
     * @param {?} maxRetry
     * @return {?}
     */
    retryStrategy(maxRetry) {
        return (/**
         * @param {?} errors
         * @return {?}
         */
        function (errors) {
            /**Done: COMPLETE THIS! For some reason can't get scan() to work, types always malformed.*/
            // return errors.pipe(
            //     // scan((acc, curr) => {acc + curr}, 0)
            //     scan((acc, error, index) => {
            //         return acc + error;
            //     }, 0)
            // );
            // Done: Unsure if we have to re-implement this line. It causes errors, but simply removing it may not be appropriate.
            // NOTE: RxJS-compat might be saving us here and "fixing" the errors. See if errors return when we remove rxjs-compat.
            // return errors.pipe(scan((acc, curr) => acc + curr, 0))
            return errors.pipe(scan((
            // return errors.pipe(
            /**
             * @param {?} acc
             * @param {?} error
             * @param {?} index
             * @return {?}
             */
            (acc, error, index) => {
                // console.log('Error encountered: %o', error);;
                /**
                 * If the error is about file too big and we have not reach max retry
                 * yet, theyt keep going to scaling down.
                 */
                if (acc < maxRetry && error.errorCode === CommonImageError.TooBig) {
                    // console.log('Progressively scaling down the image, step %d.', index);
                    return acc + 1;
                }
                else {
                    /**
                     * For either conditions terminate the retry, propogate
                     * the error.
                     *
                     * 1. errors such as CannotRead or any other unknown errors
                     * not listed in MspImageError enum
                     * 2. Exceeded maxRetry
                     *
                     */
                    console.log('Re-throw this image process error: %o', error);
                    throw error;
                }
            }), 0), delay(2));
        });
    }
    /**
     * @private
     * @param {?} imageFile
     * @param {?} nextPageNumber
     * @param {?} callback
     * @param {?} invalidImageHanlder
     * @return {?}
     */
    readImage(imageFile, nextPageNumber, callback, invalidImageHanlder) {
        /** @type {?} */
        const reader = new FileReader();
        reader.onload = (/**
         * @param {?} progressEvt
         * @return {?}
         */
        function (progressEvt) {
            console.log('loading image into an img tag: %o', progressEvt);
            // Load into an image element
            /** @type {?} */
            const imgEl = document.createElement('img');
            imgEl.src = ((/** @type {?} */ (reader.result)));
            // Wait for onload so all properties are populated
            imgEl.onload = (/**
             * @param {?} args
             * @return {?}
             */
            (args) => {
                console.log('Completed image loading into an img tag: %o', args);
                return callback(imgEl, imageFile, nextPageNumber);
            });
            imgEl.onerror =
                (/**
                 * @param {?} args
                 * @return {?}
                 */
                (args) => {
                    // log it to the console
                    console.log('This image cannot be opened/read, it is probably an invalid image. %o', args);
                    // throw new Error('This image cannot be opened/read');
                    /** @type {?} */
                    const imageReadError = new CommonImageProcessingError(CommonImageError.CannotOpen);
                    imageReadError.rawImageFile = imageFile;
                    return invalidImageHanlder(imageReadError);
                });
        });
        reader.readAsDataURL(imageFile);
    }
    /**
     * @private
     * @param {?} pdfFile
     * @param {?} pdfScaleFactor
     * @param {?} callback
     * @param {?} error
     * @return {?}
     */
    readPDF(pdfFile, pdfScaleFactor, callback, error) {
        PDFJS.disableWorker = true;
        PDFJS.disableStream = true;
        /** @type {?} */
        const reader = new FileReader();
        /** @type {?} */
        let currentPage = 1;
        /** @type {?} */
        const canvas = document.createElement('canvas');
        /** @type {?} */
        const imgElsArray = [];
        /** @type {?} */
        const ctx = canvas.getContext('2d');
        reader.onload = (/**
         * @param {?} progressEvt
         * @return {?}
         */
        function (progressEvt) {
            /** @type {?} */
            const docInitParams = { data: reader.result };
            // TODO - The 'as any' was added when porting to common library from MSP
            PDFJS.getDocument(((/** @type {?} */ (docInitParams)))).then((/**
             * @param {?} pdfdoc
             * @return {?}
             */
            (pdfdoc) => {
                /** @type {?} */
                const numPages = pdfdoc.numPages;
                if (currentPage <= pdfdoc.numPages) {
                    getPage();
                }
                /**
                 * @return {?}
                 */
                function getPage() {
                    pdfdoc.getPage(currentPage).then((/**
                     * @param {?} page
                     * @return {?}
                     */
                    function (page) {
                        /** @type {?} */
                        const viewport = page.getViewport(pdfScaleFactor);
                        canvas.height = viewport.height;
                        canvas.width = viewport.width;
                        /** @type {?} */
                        const renderContext = {
                            canvasContext: ctx,
                            viewport: viewport
                        };
                        page.render(renderContext).then((/**
                         * @return {?}
                         */
                        function () {
                            /** @type {?} */
                            const imgEl = document.createElement('img');
                            imgEl.src = canvas.toDataURL();
                            imgElsArray.push(imgEl);
                            if (currentPage < numPages) {
                                currentPage++;
                                getPage();
                            }
                            else {
                                callback(imgElsArray, pdfFile);
                            }
                        }));
                    }), (/**
                     * @param {?} errorReason
                     * @return {?}
                     */
                    function (errorReason) {
                        error(errorReason);
                    }));
                }
            }), (/**
             * @param {?} errorReason
             * @return {?}
             */
            function (errorReason) {
                error(errorReason);
            }));
        });
        reader.readAsArrayBuffer(pdfFile);
    }
    /**
     * Non reversible image filter to take an existing canvas and make it gray scale
     * @param {?} canvas
     * @return {?}
     */
    makeGrayScale(canvas) {
        /** @type {?} */
        const context = canvas.getContext('2d');
        /** @type {?} */
        const imageData = context.getImageData(0, 0, canvas.width, canvas.height);
        /** @type {?} */
        const data = imageData.data;
        for (let i = 0; i < data.length; i += 4) {
            /** @type {?} */
            const brightness = 0.34 * data[i] + 0.5 * data[i + 1] + 0.16 * data[i + 2];
            // red
            data[i] = brightness;
            // green
            data[i + 1] = brightness;
            // blue
            data[i + 2] = brightness;
        }
        // overwrite original image
        context.putImageData(imageData, 0, 0);
    }
    /**
     * @param {?} mspImage
     * @return {?}
     */
    handleImageFile(mspImage) {
        console.log('image size (bytes) after compression: ' + mspImage.size);
        if (this.images.length >= 50) {
            // log it
            // this.logImageInfo('msp_file-uploader_error', this.dataService.getMspUuid(),
            //     mspImage, `Number of image files exceeds max of ${50}`);
            // log to console
            console.log(`Max number of image file you can upload is ${50}.
      This file ${mspImage.name} was not uploaded.`);
        }
        else {
            this.images.push(mspImage);
            this.imagesChange.emit(this.images);
            this.showError = false;
            this.noIdImage = false;
        }
    }
    /**
     * @param {?} error
     * @param {?} mspImage
     * @param {?=} errorDescription
     * @return {?}
     */
    handleError(error, mspImage, errorDescription) {
        if (!mspImage) {
            mspImage = new CommonImage();
        }
        // just add the error to mspImage
        mspImage.error = error;
        // log the error
        if (error !== CommonImageError.PDFnotSupported) {
            // this.logImageInfo('msp_file-uploader_error', this.dataService.getMspUuid(), mspImage,
            //     '  mspImageFile: ' + mspImage.name + '  mspErrorNum: ' + error + '  mspError: ' +
            //     error + '-' + errorDescription);
        }
        // console.log("error with image: ", mspImage);
        this.errorDocument.emit(mspImage);
    }
    /**
     * Reset input fields so that user can delete a file and
     * immediately upload that file again.
     * @return {?}
     */
    resetInputFields() {
        // let brosweFileInputElement = this.browseFileRef.nativeElement;
        // let captureFileInputElement = this.captureFileRef.nativeElement;
        this.browseFileRef.nativeElement.value = '';
        // this.captureFileRef.nativeElement.value = '';
    }
    /**
     * @param {?} mspImage
     * @return {?}
     */
    deleteImage(mspImage) {
        this.resetInputFields();
        this.images = this.images.filter((/**
         * @param {?} x
         * @return {?}
         */
        x => x.uuid !== mspImage.uuid));
        this.imagesChange.emit(this.images);
        // If there are no images yet, we have to reset the input so it triggers 'required'.
        if (this.required && this.images.length <= 0) {
            console.log('No images, resetting input');
            // this.fileControl.value = '';
            this.fileControl.setErrors({ 'required': true });
        }
    }
    /**
     * Log image attributes
     * @private
     * @param {?} title
     * @param {?} applicationId
     * @param {?} mspImage
     * @param {?=} additionalInfo
     * @return {?}
     */
    logImageInfo(title, applicationId, mspImage, additionalInfo) {
        // TODO!
        // // create log entry
        // const log: LogEntry = new LogEntry();
        // log.applicationId = applicationId;
        // const now = moment();
        // log.mspTimestamp = now.toISOString();
        // log.applicationPhase = title + ':  mspImageId: ' + mspImage.id
        //     + '  mspImageUuid: ' + mspImage.uuid
        //     + '  mspImageSize: ' + mspImage.size
        //     + '  mspImageWidth: ' + mspImage.naturalWidth
        //     + '  mspImageHeight: ' + mspImage.naturalHeight
        //     + '  mspImageContentType: ' + mspImage.contentType
        //     + (additionalInfo ? '  ' + additionalInfo : '');
        // // send it while subscribing to response
        // this.logService.logIt(log, title).subscribe(
        //     (response) => {
        //         // console.log('log rest service response: ');
        //         // console.log(response);
        //     },
        //     (error) => {
        //         console.log('HTTP error response from logging service: ');
        //         console.log(error);
        //     },
        //     () => {
        //         // console.log('log rest service completed!');
        //     }
        // );
    }
    /**
     * Return true if the image size is within range
     * @param {?} file
     * @return {?}
     */
    checkImageDimensions(file) {
        if (file.naturalHeight < 0 ||
            file.naturalWidth < 0) {
            return false;
        }
        return true;
    }
    /**
     * @return {?}
     */
    isValid() {
        console.log('isValid', this.images);
        if (this.required) {
            return this.images && this.images.length > 0;
        }
        return true;
    }
}
FileUploaderComponent.decorators = [
    { type: Component, args: [{
                selector: 'common-file-uploader',
                template: "<div class=\"dropzone\" #dropZone [ngClass]='{\"has-error\": fileControl?.touched && fileControl?.errors?.required}'>\n\n  <div class=\"instruction-zone d-flex align-items-center flex-wrap flex-sm-nowrap flex-column flex-sm-row\">\n    <i class=\"fa fa-cloud-upload fa-4x d-inline-block upload-icon\" aria-hidden=\"true\" #imagePlaceholderRef tabindex=\"0\"></i>\n\n    <input type=\"file\" id=\"fileUploadBrowse-{{id}}\" #browseFileRef ngModel accept=\"image/*,application/pdf\" style=\"display:none;\"\n            tabindex=\"0\" multiple name='fileUploadBrowse-{{id}}' [required]='required && images.length === 0' />\n    <label for=\"fileUploadBrowse-{{id}}\" class=\"file-upload-label d-inline-block ml-3\" #selectFileLabel tabindex=\"0\">\n      <span class='h2 color-body'>Select a file</span>\n      <span class='d-block description'>{{ instructionText }}</span>\n    </label>\n    \n    <!-- TODO - STYLE/ENABLE/TEST THE BELOW FOR MOBILE ONLY! Also need to test on a phone after deploying to OpenShift-->\n    <!-- <span class=\"d-block d-sm-none\">or</span>\n    <input type=\"file\" id=\"fileUploadUseCamera-{{id}}\" #captureFileRef accept=\"image/*,application/pdf\" capture=\"camera\"\n            tabindex=\"0\" multiple />\n    <span class=\"fa fa-camera d-block d-sm-none fa-4x\" aria-hidden=\"true\"></span>\n    <label for=\"fileUploadUseCamera-{{id}}\" class=\"file-upload-label description d-block d-sm-none\" tabindex=\"0\">\n      take a photo\n    </label> -->\n    \n  </div>\n  \n  <div *ngIf=\"fileControl?.touched\" role=\"alert\" class='error-container' aria-live=\"assertive\">\n    <div class=\"text-danger\" *ngIf=\"fileControl?.errors?.required\">\n      {{errorMessages.required}}\n    </div>\n  </div>\n\n  <div class=\"preview-zone\">\n    <div *ngFor=\"let mspImage of images\" class=\"preview-item\">\n      <common-thumbnail [imageObject]=\"mspImage\" (deleteImage)=\"deleteImage($event)\">\n      </common-thumbnail>\n    </div>\n  </div>\n\n  <!-- The sole purpose of this element is to maintain the drop zone to an \n        large size to display on screen.\n      -->\n  <div class=\"preview-zone\">\n    <div class=\"preview-item\">\n    </div>\n  </div>\n\n</div>\n\n<!-- This hidden canvas is used to transform / resize images -->\n<canvas #canvas style=\"display:none;\">\n\n</canvas>\n",
                viewProviders: [{ provide: ControlContainer, useExisting: forwardRef((/**
                         * @return {?}
                         */
                        () => NgForm)) }],
                styles: [".color-body{color:#494949}.description{font-weight:400}.dropzone{border:2px dashed #d3d3d3;margin-bottom:10px;border-radius:8px;padding:2em 4em}.dropzone.has-error{border-color:#a94442}.dropzone .instruction-zone{margin:10px 5px 5px;text-align:left}.dropzone .instruction-zone input{display:none}.dropzone .instruction-zone .file-upload-label{color:#494949}.dropzone .instruction-zone .file-upload-label:hover{text-decoration:none;cursor:pointer}.dropzone .preview-zone{display:flex;flex-wrap:wrap;justify-content:left;align-items:left}.dropzone .preview-zone .preview-item{position:relative;height:120px;text-align:left;margin-left:6rem;margin-bottom:1.5rem}.dropzone .preview-zone .preview-item .icon-upload{opacity:.3;margin:0 auto 15px}.dropzone .preview-zone .preview-item .icon-upload:hover{cursor:pointer;opacity:.6}.dropzone .preview-zone .preview-item .text-upload:hover{cursor:pointer}.dropzone .preview-zone .error-style{color:red;font-weight:700}.dropzone .mobileShow{display:none}@media only screen and (min-device-width:320px) and (max-device-width:480px){.dropzone .mobileShow{display:inline}}"]
            }] }
];
/** @nocollapse */
FileUploaderComponent.ctorParameters = () => [
    { type: NgZone },
    { type: ChangeDetectorRef },
    { type: Router },
    { type: ControlContainer }
];
FileUploaderComponent.propDecorators = {
    dropZone: [{ type: ViewChild, args: ['dropZone',] }],
    browseFileRef: [{ type: ViewChild, args: ['browseFileRef',] }],
    imagePlaceholderRef: [{ type: ViewChild, args: ['imagePlaceholderRef',] }],
    selectFileLabelRef: [{ type: ViewChild, args: ['selectFileLabel',] }],
    images: [{ type: Input }],
    imagesChange: [{ type: Output }],
    id: [{ type: Input }],
    showError: [{ type: Input }],
    required: [{ type: Input }],
    instructionText: [{ type: Input }],
    errorMessages: [{ type: Input }],
    canvas: [{ type: ViewChild, args: ['canvas',] }],
    errorDocument: [{ type: Output }]
};
if (false) {
    /** @type {?} */
    FileUploaderComponent.prototype.noIdImage;
    /**
     * @type {?}
     * @private
     */
    FileUploaderComponent.prototype.appConstants;
    /** @type {?} */
    FileUploaderComponent.prototype.dropZone;
    /** @type {?} */
    FileUploaderComponent.prototype.browseFileRef;
    /** @type {?} */
    FileUploaderComponent.prototype.imagePlaceholderRef;
    /** @type {?} */
    FileUploaderComponent.prototype.selectFileLabelRef;
    /** @type {?} */
    FileUploaderComponent.prototype.images;
    /** @type {?} */
    FileUploaderComponent.prototype.imagesChange;
    /** @type {?} */
    FileUploaderComponent.prototype.id;
    /** @type {?} */
    FileUploaderComponent.prototype.showError;
    /** @type {?} */
    FileUploaderComponent.prototype.required;
    /** @type {?} */
    FileUploaderComponent.prototype.instructionText;
    /** @type {?} */
    FileUploaderComponent.prototype.errorMessages;
    /** @type {?} */
    FileUploaderComponent.prototype.canvas;
    /** @type {?} */
    FileUploaderComponent.prototype.errorDocument;
    /**
     * @type {?}
     * @private
     */
    FileUploaderComponent.prototype.zone;
    /**
     * @type {?}
     * @private
     */
    FileUploaderComponent.prototype.cd;
    /**
     * @type {?}
     * @private
     */
    FileUploaderComponent.prototype.router;
    /**
     * @type {?}
     * @private
     */
    FileUploaderComponent.prototype.controlContainer;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZmlsZS11cGxvYWRlci5jb21wb25lbnQuanMiLCJzb3VyY2VSb290Ijoibmc6Ly9tb2gtY29tbW9uLWxpYi8iLCJzb3VyY2VzIjpbImxpYi9jb21wb25lbnRzL2ZpbGUtdXBsb2FkZXIvZmlsZS11cGxvYWRlci5jb21wb25lbnQudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7OztBQUFBLE9BQU8sRUFBb0IsaUJBQWlCLEVBQUUsU0FBUyxFQUNyQyxVQUFVLEVBQUUsWUFBWSxFQUFFLEtBQUssRUFBRSxNQUFNLEVBQzdDLE1BQU0sRUFBaUIsU0FBUyxFQUFFLFVBQVUsRUFBaUIsTUFBTSxlQUFlLENBQUM7QUFDL0YsT0FBTyxFQUFFLE1BQU0sRUFBRSxnQkFBZ0IsRUFBRSxNQUFNLGdCQUFnQixDQUFDO0FBSTFELE9BQU8sRUFBRSxVQUFVLEVBQWMsU0FBUyxFQUFFLEtBQUssRUFBRSxNQUFNLE1BQU0sQ0FBQztBQUNoRSxPQUFPLEVBQUMsR0FBRyxFQUFFLE1BQU0sRUFBRSxPQUFPLEVBQUUsSUFBSSxFQUFFLEtBQUssRUFBRSxTQUFTLEVBQUMsTUFBTSxnQkFBZ0IsQ0FBQztBQUM1RSxPQUFPLEVBQUUsV0FBVyxFQUFFLGdCQUFnQixFQUFFLDBCQUEwQixFQUN6QywyQkFBMkIsRUFBRSxNQUFNLGdDQUFnQyxDQUFDOzs7Ozs7QUFNN0YsT0FBTyxFQUFDLE1BQU0sRUFBQyxNQUFNLGlCQUFpQixDQUFDO0FBQ3ZDLE9BQU8sRUFBRSxJQUFJLEVBQUUsTUFBTSwwQkFBMEIsQ0FBQzs7OztBQU1oRCxPQUFPLEtBQUssVUFBVSxNQUFNLG9CQUFvQixDQUFDOztNQUMzQyxTQUFTLEdBQUcsVUFBVTtBQUM1QixPQUFPLEtBQUssS0FBSyxNQUFNLE1BQU0sQ0FBQzs7TUFDeEIsSUFBSSxHQUFHLEtBQUs7O0FBR2xCLE9BQU8sS0FBSyxNQUFNLE1BQU0sWUFBWSxDQUFDOztNQUMvQixLQUFLLEdBQWdCLENBQUMsbUJBQUEsTUFBTSxFQUFPLENBQUM7Ozs7QUFFMUMs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QUU7O2FBQzNGOzs7O1lBM0NrRCxNQUFNO1lBRDlCLGlCQUFpQjtZQWdCcEMsTUFBTTtZQWJHLGdCQUFnQjs7O3VCQStDNUIsU0FBUyxTQUFDLFVBQVU7NEJBQ3BCLFNBQVMsU0FBQyxlQUFlO2tDQUV6QixTQUFTLFNBQUMscUJBQXFCO2lDQUMvQixTQUFTLFNBQUMsaUJBQWlCO3FCQUczQixLQUFLOzJCQUNMLE1BQU07aUJBQ04sS0FBSzt3QkFDTCxLQUFLO3VCQUNMLEtBQUs7OEJBQ0wsS0FBSzs0QkFDTCxLQUFLO3FCQUVMLFNBQVMsU0FBQyxRQUFROzRCQUdsQixNQUFNOzs7O0lBcEJQLDBDQUEyQjs7Ozs7SUFDM0IsNkNBQXFCOztJQUNyQix5Q0FBNEM7O0lBQzVDLDhDQUFzRDs7SUFFdEQsb0RBQWtFOztJQUNsRSxtREFBNkQ7O0lBRzdELHVDQUFnRTs7SUFDaEUsNkNBQWtHOztJQUNsRyxtQ0FBb0I7O0lBQ3BCLDBDQUE0Qjs7SUFDNUIseUNBQW1DOztJQUNuQyxnREFBMEU7O0lBQzFFLDhDQUEwRTs7SUFFMUUsdUNBQXdDOztJQUd4Qyw4Q0FBcUY7Ozs7O0lBS3pFLHFDQUFvQjs7Ozs7SUFDcEIsbUNBQTZCOzs7OztJQUFHLHVDQUFzQjs7Ozs7SUFDdEQsaURBQTBDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgQWZ0ZXJDb250ZW50SW5pdCwgQ2hhbmdlRGV0ZWN0b3JSZWYsIENvbXBvbmVudCxcbiAgICBDb250ZW50Q2hpbGQsIEVsZW1lbnRSZWYsIEV2ZW50RW1pdHRlciwgSW5wdXQsIE5nWm9uZSwgT25DaGFuZ2VzLFxuICAgIE9uSW5pdCwgT3V0cHV0LCBTaW1wbGVDaGFuZ2VzLCBWaWV3Q2hpbGQsIGZvcndhcmRSZWYsIEFmdGVyVmlld0luaXQgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IE5nRm9ybSwgQ29udHJvbENvbnRhaW5lciB9IGZyb20gJ0Bhbmd1bGFyL2Zvcm1zJztcbmltcG9ydCAqIGFzIG1vbWVudCBmcm9tICdtb21lbnQnO1xuaW1wb3J0IHsgTW9kYWxEaXJlY3RpdmV9IGZyb20gJ25neC1ib290c3RyYXAnO1xuaW1wb3J0IHsgUERGSlNTdGF0aWMgfSBmcm9tICdwZGZqcy1kaXN0JztcbmltcG9ydCB7IE9ic2VydmFibGUgLCAgT2JzZXJ2ZXIsIGZyb21FdmVudCwgbWVyZ2UgfSBmcm9tICdyeGpzJztcbmltcG9ydCB7bWFwLCBmaWx0ZXIsIGZsYXRNYXAsIHNjYW4sIGRlbGF5LCByZXRyeVdoZW59IGZyb20gJ3J4anMvb3BlcmF0b3JzJztcbmltcG9ydCB7IENvbW1vbkltYWdlLCBDb21tb25JbWFnZUVycm9yLCBDb21tb25JbWFnZVByb2Nlc3NpbmdFcnJvcixcbkNvbW1vbkltYWdlU2NhbGVGYWN0b3JzLCBDb21tb25JbWFnZVNjYWxlRmFjdG9yc0ltcGwgfSBmcm9tICcuLi8uLi8uLi9pbWFnZXMvc3JjL3B1YmxpY19hcGknO1xuLy8gaW1wb3J0IHsgTXNwTG9nU2VydmljZSB9IGZyb20gJy4uLy4uL3NlcnZpY2UvbG9nLnNlcnZpY2UnO1xuLy8gaW1wb3J0IHsgTXNwRGF0YVNlcnZpY2UgfSBmcm9tICcuLi8uLi9zZXJ2aWNlL21zcC1kYXRhLnNlcnZpY2UnO1xuLy8gaW1wb3J0IHsgQmFzZUNvbXBvbmVudCB9IGZyb20gJy4uL2Jhc2UuY29tcG9uZW50Jztcbi8vIGltcG9ydCB7IExvZ0VudHJ5IH0gZnJvbSAnLi4vbG9nZ2luZy9sb2ctZW50cnkubW9kZWwnO1xuLy8gaW1wb3J0IHtQZXJzb259IGZyb20gJy4uLy4uL21vZGVsL2FwcGxpY2F0aW9uLm1vZGVsJztcbmltcG9ydCB7Um91dGVyfSBmcm9tICdAYW5ndWxhci9yb3V0ZXInO1xuaW1wb3J0IHsgQmFzZSB9IGZyb20gJy4uLy4uLy4uL21vZGVscy9zcmMvYmFzZSc7XG4vLyBpbXBvcnQge0FwcGxpY2F0aW9uQmFzZX0gZnJvbSAnLi4vLi4vbW9kZWwvYXBwbGljYXRpb24tYmFzZS5tb2RlbCc7XG5cbi8vIGNvbnN0IGxvYWRJbWFnZSA9IHJlcXVpcmUoJ2JsdWVpbXAtbG9hZC1pbWFnZScpO1xuLy8gY29uc3Qgc2hhMSA9IHJlcXVpcmUoJ3NoYTEnKTtcblxuaW1wb3J0ICogYXMgbG9hZEltYWdlXyBmcm9tICdibHVlaW1wLWxvYWQtaW1hZ2UnO1xuY29uc3QgbG9hZEltYWdlID0gbG9hZEltYWdlXztcbmltcG9ydCAqIGFzIHNoYTFfIGZyb20gJ3NoYTEnO1xuY29uc3Qgc2hhMSA9IHNoYTFfO1xuXG4vLyBjb25zdCBQREZKUzogUERGSlNTdGF0aWMgPSByZXF1aXJlKCdwZGZqcy1kaXN0Jyk7XG5pbXBvcnQgKiBhcyBQREZKU18gZnJvbSAncGRmanMtZGlzdCc7XG5jb25zdCBQREZKUzogUERGSlNTdGF0aWMgPSAoUERGSlNfIGFzIGFueSk7XG5cbmV4cG9ydCBpbnRlcmZhY2UgRmlsZVVwbG9hZGVyTXNnIHtcbiAgICByZXF1aXJlZDogc3RyaW5nO1xufVxuXG4vLyBUT0RPIC0gUmVtb3ZlIHRoaXMgYW5kIGZpeCB0c2xpbnQgaXNzdWVzXG4vKiB0c2xpbnQ6ZGlzYWJsZTptYXgtbGluZS1sZW5ndGgqL1xuXG5AQ29tcG9uZW50KHtcbiAgICBzZWxlY3RvcjogJ2NvbW1vbi1maWxlLXVwbG9hZGVyJyxcbiAgICB0ZW1wbGF0ZVVybDogJy4vZmlsZS11cGxvYWRlci5jb21wb25lbnQuaHRtbCcsXG4gICAgc3R5bGVVcmxzOiBbJy4vZmlsZS11cGxvYWRlci5jb21wb25lbnQuc2NzcyddLFxuICAgIHZpZXdQcm92aWRlcnM6IFsgeyBwcm92aWRlOiBDb250cm9sQ29udGFpbmVyLCB1c2VFeGlzdGluZzogZm9yd2FyZFJlZigoKSA9PiBOZ0Zvcm0gKSB9IF1cbn0pXG5leHBvcnQgY2xhc3MgRmlsZVVwbG9hZGVyQ29tcG9uZW50IGV4dGVuZHMgQmFzZVxuICAgIGltcGxlbWVudHMgT25Jbml0LCBPbkNoYW5nZXMsIEFmdGVyQ29udGVudEluaXQge1xuICAgIC8vIGxhbmcgPSByZXF1aXJlKCcuL2kxOG4nKTtcbiAgICBub0lkSW1hZ2U6IEJvb2xlYW4gPSBmYWxzZTtcbiAgICBwcml2YXRlIGFwcENvbnN0YW50cztcbiAgICBAVmlld0NoaWxkKCdkcm9wWm9uZScpIGRyb3Bab25lOiBFbGVtZW50UmVmO1xuICAgIEBWaWV3Q2hpbGQoJ2Jyb3dzZUZpbGVSZWYnKSBicm93c2VGaWxlUmVmOiBFbGVtZW50UmVmO1xuICAgIC8vIEBWaWV3Q2hpbGQoJ2NhcHR1cmVGaWxlUmVmJykgY2FwdHVyZUZpbGVSZWY6IEVsZW1lbnRSZWY7XG4gICAgQFZpZXdDaGlsZCgnaW1hZ2VQbGFjZWhvbGRlclJlZicpIGltYWdlUGxhY2Vob2xkZXJSZWY6IEVsZW1lbnRSZWY7XG4gICAgQFZpZXdDaGlsZCgnc2VsZWN0RmlsZUxhYmVsJykgc2VsZWN0RmlsZUxhYmVsUmVmOiBFbGVtZW50UmVmO1xuXG4gICAgLy8gQENvbnRlbnRDaGlsZCgndXBsb2FkSW5zdHJ1Y3Rpb24nKSB1cGxvYWRJbnN0cnVjdGlvblJlZjogRWxlbWVudFJlZjtcbiAgICBASW5wdXQoKSBpbWFnZXM6IEFycmF5PENvbW1vbkltYWdlPiA9IG5ldyBBcnJheTxDb21tb25JbWFnZT4oMCk7XG4gICAgQE91dHB1dCgpIGltYWdlc0NoYW5nZTogRXZlbnRFbWl0dGVyPEFycmF5PENvbW1vbkltYWdlPj4gPSBuZXcgRXZlbnRFbWl0dGVyPEFycmF5PENvbW1vbkltYWdlPj4oKTtcbiAgICBASW5wdXQoKSBpZDogc3RyaW5nO1xuICAgIEBJbnB1dCgpIHNob3dFcnJvcjogYm9vbGVhbjtcbiAgICBASW5wdXQoKSByZXF1aXJlZDogYm9vbGVhbiA9IGZhbHNlO1xuICAgIEBJbnB1dCgpIGluc3RydWN0aW9uVGV4dDogc3RyaW5nID0gJ1BsZWFzZSB1cGxvYWQgcmVxdWlyZWQgSUQgZG9jdW1lbnRzLic7XG4gICAgQElucHV0KCkgZXJyb3JNZXNzYWdlczogRmlsZVVwbG9hZGVyTXNnID0ge3JlcXVpcmVkOiAnRmlsZSBpcyByZXF1aXJlZC4nfTtcblxuICAgIEBWaWV3Q2hpbGQoJ2NhbnZhcycpIGNhbnZhczogRWxlbWVudFJlZjtcblxuXG4gICAgQE91dHB1dCgpIGVycm9yRG9jdW1lbnQ6IEV2ZW50RW1pdHRlcjxDb21tb25JbWFnZT4gPSBuZXcgRXZlbnRFbWl0dGVyPENvbW1vbkltYWdlPigpO1xuXG4gICAgY29uc3RydWN0b3IoXG4gICAgICAgICAgICAgICAgLy8gcHJpdmF0ZSBkYXRhU2VydmljZTogTXNwRGF0YVNlcnZpY2UsXG4gICAgICAgICAgICAgICAgLy8gcHJpdmF0ZSBsb2dTZXJ2aWNlOiBNc3BMb2dTZXJ2aWNlLFxuICAgICAgICAgICAgICAgIHByaXZhdGUgem9uZTogTmdab25lLFxuICAgICAgICAgICAgICAgIHByaXZhdGUgY2Q6IENoYW5nZURldGVjdG9yUmVmICwgcHJpdmF0ZSByb3V0ZXI6IFJvdXRlcixcbiAgICAgICAgICAgICAgICBwcml2YXRlIGNvbnRyb2xDb250YWluZXI6IENvbnRyb2xDb250YWluZXIpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgLy8gdGhpcy5hcHBsaWNhdGlvbiA9IHRoaXMuZ2V0QXBwbGljYXRpb25UeXBlKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBpcyBjcmVhdGVkIGFzIGEgd29ya2Fyb3VuZCB0byBhY2Nlc3MgdGhlIGZvcm0gY29udHJvbCB0aGF0IGJpbmRzIHRvXG4gICAgICogdGhlIGlucHV0W3R5cGU9J2ZpbGUnXS4gV2UgY2FuJ3QgYWNjZXNzIGl0IHZpYSB0aGUgdGVtcGxhdGUgbmFtZSBiaW5kaW5nc1xuICAgICAqIGFzIHRoYXQgaXNuJ3Qgd29ya2luZywgc28gaW5zdGVhZCB3ZSBhY2Nlc3MgdGhlIHBhcmVudCBmb3JtIGFuZCB0aGVuIGZpbmRcbiAgICAgKiB0aGUgaW5wdXQgYnkgbmFtZS5cbiAgICAgKi9cbiAgICBnZXQgZmlsZUNvbnRyb2woKSB7XG4gICAgICAgIGNvbnN0IElOUFVUX05BTUUgPSBgZmlsZVVwbG9hZEJyb3dzZS0ke3RoaXMuaWR9YDtcbiAgICAgICAgLy8gbm90ZSAtIHNob3VsZCBiZSBcInRoaXMuY29udHJvbENvbnRhaW5lciBhcyBOZ0Zvcm1cIiBoZXJlLCB3aGljaCB3b3JrcyxcbiAgICAgICAgLy8gYnV0IGZhaWxzIG9uIGNvbXBpbGlhdGlvbiBkdWUgdG8gc2Vjb25kYXJ5IGVudHJpZXNcbiAgICAgICAgcmV0dXJuICh0aGlzLmNvbnRyb2xDb250YWluZXIgYXMgYW55KS5jb250cm9sc1tJTlBVVF9OQU1FXTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gdHJ1ZSBpZiBmaWxlIGFscmVhZHkgZXhpc3RzIGluIHRoZSBsaXN0OyBmYWxzZSBvdGhlcndpc2UuXG4gICAgICovXG4gICAgc3RhdGljIGNoZWNrSW1hZ2VFeGlzdHMoZmlsZTogQ29tbW9uSW1hZ2UsIGltYWdlTGlzdDogQXJyYXk8Q29tbW9uSW1hZ2U+KSB7XG4gICAgICAgIGlmICghaW1hZ2VMaXN0IHx8IGltYWdlTGlzdC5sZW5ndGggPCAxKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgICAgIGNvbnN0IHNoYTFTdW0gPSBzaGExKGZpbGUuZmlsZUNvbnRlbnQpO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IGltYWdlTGlzdC5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKGBjb21wYXJlICAke2ltYWdlTGlzdFtpXS5pZH0gd2l0aCAke3NoYTFTdW19LCByZXN1bHQgJHtpbWFnZUxpc3RbaV0uaWQgPT09IHNoYTFTdW19YCk7XG4gICAgICAgICAgICAgICAgaWYgKGltYWdlTGlzdFtpXS5pZCA9PT0gc2hhMVN1bSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhgVGhpcyBmaWxlICR7ZmlsZS5uYW1lfSBoYXMgYWxyZWFkeSBiZWVuIHVwbG9hZGVkLmApO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBIHNwZWNpYWwgbWV0aG9kIHRvIGZvcmNlIHRoZSByZW5kZXJpbmcgb2YgdGhpcyBjb21wb25lbnQuICBUaGlzIGlzIGEgd29ya2Fyb3VuZFxuICAgICAqIGJlY2F1c2UgZm9yIHNvbWUgdW5rbm93biByZWFzb24sIEFuZ3VsYXJKUzIgY2hhbmdlIGRldGVjdG9yIGRvZXMgbm90IGRldGVjdCB0aGVcbiAgICAgKiBjaGFuZ2Ugb2YgdGhlIGltYWdlcyBBcnJheS5cbiAgICAgKi9cbiAgICBmb3JjZVJlbmRlcigpIHtcbiAgICAgICAgdGhpcy56b25lLnJ1bigoKSA9PiB7XG4gICAgICAgIH0pO1xuICAgIH1cblxuXG4gICAgbmdPbkNoYW5nZXMoY2hhbmdlczogU2ltcGxlQ2hhbmdlcyk6IHZvaWQge1xuICAgICAgICBjb25zb2xlLmxvZygnZmlsZXVwbG9hZGVyIG9uQ2hhbmdlcycsIGNoYW5nZXNbJ2ltYWdlcyddKTtcbiAgICAgICAgLy8gaWYgKGNoYW5nZXNbJ2ltYWdlcyddICYmIChjaGFuZ2VzWydpbWFnZXMnXS5jdXJyZW50VmFsdWUubGVuZ3RoID09PSAwICYmXG4gICAgICAgIC8vICAgY2hhbmdlc1snaW1hZ2VzJ10ucHJldmlvdXNWYWx1ZS5sZW5ndGggPiAwKSkge1xuICAgICAgICBpZiAoY2hhbmdlc1snaW1hZ2VzJ10gJiYgKFxuICAgICAgICAgICAgY2hhbmdlc1snaW1hZ2VzJ10uY3VycmVudFZhbHVlLmxlbmd0aCA9PT0gMFxuICAgICAgICAgICAgJiYgY2hhbmdlc1snaW1hZ2VzJ10ucHJldmlvdXNWYWx1ZVxuICAgICAgICAgICAgJiYgY2hhbmdlc1snaW1hZ2VzJ10ucHJldmlvdXNWYWx1ZS5sZW5ndGggPiAwKVxuICAgICAgICApIHtcbiAgICAgICAgICAgIHRoaXMubm9JZEltYWdlID0gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMubm9JZEltYWdlID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKlxuICAgICBTeXN0ZW0gcHJvY2Vzc2luZyBzdGVwc1xuXG4gICAgIDEuIFVzZXIgY2xpY2tzIGJyb3dzZSBvciBkcmFnLW4tZHJvcHMgYW4gZmlsZVxuICAgICAyLiBGb3IgYnJvd3NlIGNhc2UsIHRoZSBicm93c2VyIGlzIHRvbGQgdG8gb25seSBhY2NlcHQgbWltZSB0eXBlIGltYWdlLyosIC5KUEcsIC5HSUYsIC5QTkcsIGV0YyxcbiAgICAgaG93ZXZlciB1c2VyIGNhbiBvdmVycmlkZSBhbmQgZm9yIGRyYWctbi1kcm9wIHdlIGRvbid0IGNhbid0IGltcG9zZSB0aGlzIGZpbHRlclxuICAgICA0LiBVc2luZyB0aGUgSFRNTDUgRmlsZSBBUEksIHdlIG9wZW4gYSBoYW5kbGUgb24gdGhlIGZpbGVcbiAgICAgNS4gUmVhZCB0aGUgZmlsZW5hbWUgZm9yIGxhdGVyIGRpc3BsYXkgdG8gdGhlIHVzZXJcbiAgICAgNi4gQ3JlYXRlIGEgaGlkZGVuIEltYWdlIGVsZW1lbnQgaW4gdGhlIGJyb3dzZXIncyBET01cbiAgICAgNy4gUmVhZCB0aGUgZmlsZSdzIGJ5dGVzIGFzIGEgRGF0YVVybCBhbmQgY29weSB0aGVtIGludG8gdGhlIEltYWdlIGVsZW1lbnRcbiAgICAgOC4gV2FpdCB1bnRpbCB0aGUgSW1hZ2UgZmluaXNoZXMgbG9hZGluZyB0aGUgaW1hZ2VcbiAgICAgOS4gUmVhZCB0aGUgaW1hZ2UgZWxlbWVudCdzIG5hdHVyYWwgd2lkdGggYW5kIGhlaWdodFxuICAgICAxMC4gUGFzcyB0aGUgRmlsZSBoYW5kbGUgaW50byBhIEhUTUw1IENhbnZhcyBsaWIgKHdlIG5lZWQgdGhlIFhJRkYgaGVhZGVycyB0byBhdXRvIHJvdGF0ZSwgWElGRiBoZWFkZXJzIGFyZSBub3QgYXZhaWxhYmxlIGluIERhdGFVcmwpXG4gICAgIDExLiBUaGUgQ2FudmFzIGVycm9ycyBiZWNhdXNlIGl0J3MgYSB3cm9uZyB0eXBlLCBlLmcuLCBUSUZGLCB3ZSBhYm9ydCBhbmQgbm90aWZ5IHVzZXJcbiAgICAgMTIuIEluc3RydWN0IHRoZSBDYW52YXMgbGliIHRvIGtlZXAgcmVzaXppbmcgdGhlIGltYWdlIGlmIGl0IGV4Y2VlZHMgYSBtYXhpbXVtIHdpZHRoIG9yIGhlaWdodCxcbiAgICAgZXh0cmFjdCBtZXRhIGRhdGEsIGFuZCBhdXRvLW9yaWVudCBiYXNlZCBvbiBYSUZGIG1ldGFkYXRhLiAgSXQgdXNlcyBhIFwiY29udGFpblwiIG9wZXJhdGlvbiB3aGljaCByZXRhaW5zXG4gICAgIGl0J3Mgd2lkdGggdG8gaGVpZ2h0IHBpeGVsIHJhdGlvLlxuICAgICAxMy4gQ2FsbCBhIGZ1bmN0aW9uIG9uIHRoZSBDYW52YXMgZWxlbWVudCB0byB0dXJuIHRoZSBDYW52YXMgaW50byBhIEpQRUcgb2YgcXVhbGl0eSA1MCUuXG4gICAgIDE0LiBPbmNlIGluIGEgQmxvYiB3aXRoIGdldCB0aGUgYmxvYiBzaXplIGluIGJ5dGVzIGFuZCBhIGh1bWFuIGZyaWVuZGx5IGRpc3BsYXkgc2l6ZVxuICAgICAxNS4gSW4gb3JkZXIgdG8gbW9yZSBlYXNpbHkgbWFuYWdlIHRoZSBpbWFnZSwgd2UgY29udmVydCB0aGUgQmxvYiB0byBhIERhdGFVcmwgYWdhaW4uXG4gICAgIDE2LiBQYXNzIHRoZSBEYXRhVXJsIGludG8gYSBoYXNoIGFsZ29yaXRobSB0byBjcmVhdGUgYW4gaWRlbnRpZmllciBhbmQgdG8gY2hlY2sgaWYgdGhlIGltYWdlIGhhcyBhbHJlYWR5IGJlZW4gdXBsb2FkZWRcbiAgICAgMTcuIE5leHQgd2UgY2hlY2sgdGhlIGZpbmFsIHNpemUgb2YgdGhlIGltYWdlIHRvIGVuc3VyZSBpdCdzIG5vdCB0byBzbWFsbCBpbiByZXNvbHV0aW9uXG4gICAgIChhcmd1YWJseSB0aGlzIGNvdWxkJ3ZlIGJlZW4gZG9uZSBlYXJsaWVyKSwgaWYgdG9vIHNtYWxsIHdlIG5vdGlmeSB1c2VyXG4gICAgIDE4LiBGaW5hbGx5LCB0aGUgaW1hZ2UgaXMgc2F2ZWQgaW50byB0aGUgdXNlcidzIG9uZ29pbmcgRUEvUEEgYXBwbGljYXRpb24gaW5jbHVkaW5nIGxvY2Fsc3RvcmFnZVxuICAgICAxOS4gVGhlIGltYWdlIGlzIGRpc3BsYXllZCB0byB1c2VyIGFzIGEgdGh1bWJuYWlsXG5cbiAgICAgKi9cblxuICAgIG5nT25Jbml0KCk6IHZvaWQge1xuXG5cbiAgICAgICAgY29uc3QgZHJhZ092ZXJTdHJlYW0gPVxuICAgICAgICAgICAgZnJvbUV2ZW50PERyYWdFdmVudD4odGhpcy5kcm9wWm9uZS5uYXRpdmVFbGVtZW50LCAnZHJhZ292ZXInKTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogTXVzdCBjYW5jZWwgdGhlIGRyYWdvdmVyIGV2ZW50IGluIG9yZGVyIGZvciB0aGUgZHJvcCBldmVudCB0byB3b3JrLlxuICAgICAgICAgKi9cbiAgICAgICAgZHJhZ092ZXJTdHJlYW0ucGlwZShtYXAoZXZ0ID0+IHtcbiAgICAgICAgICAgIHJldHVybiBldmVudDtcbiAgICAgICAgfSkpLnN1YnNjcmliZShldnQgPT4ge1xuICAgICAgICAgICAgLy8gY29uc29sZS5sb2coJ0NhbmNlbCBkcmFnb3ZlciBldmVudC4nKTtcbiAgICAgICAgICAgIGV2dC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICB9KTtcblxuICAgICAgICBjb25zdCBkcm9wU3RyZWFtID0gZnJvbUV2ZW50PERyYWdFdmVudD4odGhpcy5kcm9wWm9uZS5uYXRpdmVFbGVtZW50LCAnZHJvcCcpO1xuICAgICAgICBjb25zdCBmaWxlc0FycmF5RnJvbURyb3AgPSBkcm9wU3RyZWFtLnBpcGUoXG4gICAgICAgICAgICBtYXAoXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBldmVudC5kYXRhVHJhbnNmZXIuZmlsZXM7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgKSk7XG5cbiAgICAgICAgY29uc3QgYnJvd3NlRmlsZVN0cmVhbSA9IGZyb21FdmVudDxFdmVudD4odGhpcy5icm93c2VGaWxlUmVmLm5hdGl2ZUVsZW1lbnQsICdjaGFuZ2UnKTtcbiAgICAgICAgLy8gY29uc3QgY2FwdHVyZUZpbGVTdHJlYW0gPSBmcm9tRXZlbnQ8RXZlbnQ+KHRoaXMuY2FwdHVyZUZpbGVSZWYubmF0aXZlRWxlbWVudCwgJ2NoYW5nZScpO1xuXG4gICAgICAgIG1lcmdlKG1lcmdlKGJyb3dzZUZpbGVTdHJlYW0pLnBpcGUoXG4gICAgICAgICAgICBtYXAoXG4gICAgICAgICAgICAgICAgKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBldmVudC50YXJnZXRbJ2ZpbGVzJ107XG5cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICApKSxcbiAgICAgICAgICAgIGZpbGVzQXJyYXlGcm9tRHJvcCkucGlwZShcbiAgICAgICAgICAgICAgICBmaWx0ZXIoZmlsZXMgPT4ge1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygnZmlsZXMnKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICEhZmlsZXMgJiYgZmlsZXMubGVuZ3RoICYmIGZpbGVzLmxlbmd0aCA+IDA7XG4gICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgZmxhdE1hcChcbiAgICAgICAgICAgICAgICAgICAgKGZpbGVMaXN0OiBGaWxlTGlzdCkgPT4ge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5vYnNlcnZhYmxlRnJvbUZpbGVzKGZpbGVMaXN0LCBuZXcgQ29tbW9uSW1hZ2VTY2FsZUZhY3RvcnNJbXBsKDEsIDEpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgICAgZmlsdGVyKFxuICAgICAgICAgICAgICAgICAgICAobXNwSW1hZ2U6IENvbW1vbkltYWdlKSA9PiB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGltYWdlRXhpc3RzID0gRmlsZVVwbG9hZGVyQ29tcG9uZW50LmNoZWNrSW1hZ2VFeGlzdHMobXNwSW1hZ2UsIHRoaXMuaW1hZ2VzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpbWFnZUV4aXN0cykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuaGFuZGxlRXJyb3IoQ29tbW9uSW1hZ2VFcnJvci5BbHJlYWR5RXhpc3RzLCBtc3BJbWFnZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5yZXNldElucHV0RmllbGRzKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gIWltYWdlRXhpc3RzO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgICAvLyBUT0RPIC0gSXMgdGhpcyBuZWNlc3Nhcnk/IENhbiBsaWtlbHkgYmUgcmVtb3ZlZCBhcyBpdCdzIGV4YWN0bHkgaWRlbnRpY2FsIHRvIHRoZSBwcmVjZWRpbmcuXG4gICAgICAgICAgICAgICAgZmlsdGVyKChtc3BJbWFnZTogQ29tbW9uSW1hZ2UpID0+IHtcblxuICAgICAgICAgICAgICAgICAgICBjb25zdCBpbWFnZUV4aXN0cyA9IEZpbGVVcGxvYWRlckNvbXBvbmVudC5jaGVja0ltYWdlRXhpc3RzKG1zcEltYWdlLCB0aGlzLmltYWdlcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaW1hZ2VFeGlzdHMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmhhbmRsZUVycm9yKENvbW1vbkltYWdlRXJyb3IuQWxyZWFkeUV4aXN0cywgbXNwSW1hZ2UpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucmVzZXRJbnB1dEZpZWxkcygpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICFpbWFnZUV4aXN0cztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgICAgZmlsdGVyKChtc3BJbWFnZTogQ29tbW9uSW1hZ2UpID0+IHtcblxuICAgICAgICAgICAgICAgICAgICBjb25zdCBpbWFnZVNpemVPayA9IHRoaXMuY2hlY2tJbWFnZURpbWVuc2lvbnMobXNwSW1hZ2UpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFpbWFnZVNpemVPaykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuaGFuZGxlRXJyb3IoQ29tbW9uSW1hZ2VFcnJvci5Ub29TbWFsbCwgbXNwSW1hZ2UpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucmVzZXRJbnB1dEZpZWxkcygpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGltYWdlU2l6ZU9rO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgKS5zdWJzY3JpYmUoXG4gICAgICAgICAgICAoZmlsZTogQ29tbW9uSW1hZ2UpID0+IHtcblxuICAgICAgICAgICAgICAgIHRoaXMuaGFuZGxlSW1hZ2VGaWxlKGZpbGUpO1xuICAgICAgICAgICAgICAgIHRoaXMucmVzZXRJbnB1dEZpZWxkcygpO1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgKGVycm9yKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coJ0Vycm9yIGluIGxvYWRpbmcgaW1hZ2U6ICVvJywgZXJyb3IpO1xuXG4gICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICogSGFuZGxlIHRoZSBlcnJvciBpZiB0aGUgaW1hZ2UgaXMgZ2lnYW50aWMgdGhhdCBhZnRlclxuICAgICAgICAgICAgICAgICAqIDEwMCB0aW1lcyBvZiBzY2FsaW5nIGRvd24gYnkgMzAlIG9uIGVhY2ggc3RlcCwgdGhlIGltYWdlXG4gICAgICAgICAgICAgICAgICogaXMgc3RpbGwgb3ZlciAxIE1CLlxuICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgIGlmIChlcnJvci5lcnJvckNvZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKENvbW1vbkltYWdlRXJyb3IuVG9vQmlnID09PSBlcnJvci5lcnJvckNvZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuaGFuZGxlRXJyb3IoQ29tbW9uSW1hZ2VFcnJvci5Ub29CaWcsIGVycm9yLmltYWdlKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChDb21tb25JbWFnZUVycm9yLkNhbm5vdE9wZW4gPT09IGVycm9yLmVycm9yQ29kZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFlcnJvci5pbWFnZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yLmltYWdlID0gbmV3IENvbW1vbkltYWdlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVycm9yLnJhd0ltYWdlRmlsZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlcnJvci5pbWFnZS5uYW1lID0gZXJyb3IucmF3SW1hZ2VGaWxlLm5hbWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5oYW5kbGVFcnJvcihDb21tb25JbWFnZUVycm9yLkNhbm5vdE9wZW4sIGVycm9yLmltYWdlKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChDb21tb25JbWFnZUVycm9yLkNhbm5vdE9wZW5QREYgPT09IGVycm9yLmVycm9yQ29kZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5oYW5kbGVFcnJvcihDb21tb25JbWFnZUVycm9yLkNhbm5vdE9wZW5QREYsIGVycm9yLmltYWdlLCBlcnJvci5lcnJvckRlc2NyaXB0aW9uKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG5cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAoKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coJ2NvbXBsZXRlZCBsb2FkaW5nIGltYWdlJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICk7XG4gICAgfVxuXG4gICAgdGVzdCh2YXIxKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKHZhcjEpO1xuICAgIH1cblxuICAgIG5nQWZ0ZXJDb250ZW50SW5pdCgpIHtcblxuICAgICAgICBjb25zdCBpbWFnZVBsYWNlaG9sZGVyRW50ZXJLZXlTdHJlYW0gPSBtZXJnZShcbiAgICAgICAgICAgIGZyb21FdmVudDxFdmVudD4odGhpcy5pbWFnZVBsYWNlaG9sZGVyUmVmLm5hdGl2ZUVsZW1lbnQsICdrZXl1cCcpLFxuICAgICAgICAgICAgZnJvbUV2ZW50PEV2ZW50Pih0aGlzLnNlbGVjdEZpbGVMYWJlbFJlZi5uYXRpdmVFbGVtZW50LCAna2V5dXAnKSxcbiAgICAgICAgICAgIC8vIGZyb21FdmVudDxFdmVudD4odGhpcy51cGxvYWRJbnN0cnVjdGlvblJlZi5uYXRpdmVFbGVtZW50LCAna2V5dXAnKVxuICAgICAgICApLnBpcGUoZmlsdGVyKChldnQ6IEtleWJvYXJkRXZlbnQpID0+IGV2dC5rZXkgPT09ICdFbnRlcicpKTtcblxuICAgICAgICBtZXJnZShcbiAgICAgICAgICAgIGZyb21FdmVudDxFdmVudD4odGhpcy5pbWFnZVBsYWNlaG9sZGVyUmVmLm5hdGl2ZUVsZW1lbnQsICdjbGljaycpLFxuICAgICAgICAgICAgLy8gZnJvbUV2ZW50PEV2ZW50Pih0aGlzLnVwbG9hZEluc3RydWN0aW9uUmVmLm5hdGl2ZUVsZW1lbnQsICdjbGljaycpLFxuICAgICAgICAgICAgaW1hZ2VQbGFjZWhvbGRlckVudGVyS2V5U3RyZWFtXG4gICAgICAgICkucGlwZShcbiAgICAgICAgICAgIG1hcCgoZXZlbnQpID0+IHtcbiAgICAgICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgIHJldHVybiBldmVudDtcbiAgICAgICAgICAgIH0pXG4gICAgICAgICkuc3Vic2NyaWJlKCAoZXZlbnQpID0+IHsgdGhpcy5icm93c2VGaWxlUmVmLm5hdGl2ZUVsZW1lbnQuY2xpY2soKTsgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU29sdmUgc2l6ZSBpbiB0aGlzIGVxdWF0aW9uOiBzaXplICogMC44dG8tdGhlLXBvd2VyLW9mMzAgPCAxTUIsIHNpemVcbiAgICAgKiB3aWxsIGJlIHRoZSBtYXggaW1hZ2Ugc2l6ZSB0aGlzIGFwcGxpY2F0aW9uIGNhbiBhY2NlcHQgYW5kIHNjYWxlIGRvd25cbiAgICAgKiB0byB1bmRlciAxTUIuIEluIHRoaXMgY2FzZTogc2l6ZSA8IDgwNyBNQlxuICAgICAqXG4gICAgICogMzAgaXMgdGhlIG51bWJlciBvZiByZXRyaWVzLiB0aGUgdmFsdWUgZm9yIG1heFJldHJ5IHBhc3NlZCB0byByZXRyeVN0cmF0ZWd5XG4gICAgICogZnVuY3Rpb24uXG4gICAgICpcbiAgICAgKiBJZjogc2l6ZSAqIDAuOHRvLXRoZS1wb3dlci1vZjQwIDwgMU1CLCB0aGVuIHNpemUgPCAxMjYyIE1CLlxuICAgICAqXG4gICAgICogTm90ZTogMC44IGlzIHRoZSBzZWxmLmFwcENvbnN0YW50cy5pbWFnZXMucmVkdWN0aW9uU2NhbGVGYWN0b3IgZGVmaW5lZCBpbiBnbG9iYWwuanNcbiAgICAgKlxuICAgICAqXG4gICAgICogQHBhcmFtIGZpbGVcbiAgICAgKiBAcGFyYW0gc2NhbGVGYWN0b3JzXG4gICAgICovXG4gICAgb2JzZXJ2YWJsZUZyb21GaWxlcyhmaWxlTGlzdDogRmlsZUxpc3QsIHNjYWxlRmFjdG9yczogQ29tbW9uSW1hZ2VTY2FsZUZhY3RvcnMpIHtcbiAgICAgICAgLyoqIFByZXZpb3VzbHkgdGhpcyB3YXMgc2V0IGluIGFwcENvbnN0YW50cywgYnV0IHRoYXQncyByZW1vdmVkIGZyb20gdGhlIGNvbW1vbiBsaWIuICovXG4gICAgICAgIGNvbnN0IHJlZHVjdGlvblNjYWxlRmFjdG9yID0gMC44O1xuXG4gICAgICAgIGNvbnNvbGUubG9nKCdvYnNlcmFibHZlRnJvbUZpbGVzJyk7XG5cbiAgICAgICAgLy8gSW5pdFxuICAgICAgICBjb25zdCBzZWxmID0gdGhpcztcbiAgICAvLyAgICBsZXQgIHBhZ2VOdW1iZXIgPSBNYXRoLm1heCguLi5zZWxmLmltYWdlcy5jb25jYXQoIHNlbGYuYXBwbGljYXRpb24uZ2V0QWxsSW1hZ2VzKCkpLm1hcChmdW5jdGlvbihvKSB7cmV0dXJuIG8uYXR0YWNobWVudE9yZGVyOyB9KSwgMCkgKyAxIDtcbiAgICAgICBsZXQgcGFnZU51bWJlciA9IE1hdGgubWF4KC4uLnNlbGYuaW1hZ2VzLm1hcChmdW5jdGlvbihvKSB7cmV0dXJuIG8uYXR0YWNobWVudE9yZGVyOyB9KSwgMCkgKyAxIDtcblxuICAgICAgICAvLyBDcmVhdGUgb3VyIG9ic2VydmVyXG4gICAgICAgIGNvbnN0IGZpbGVPYnNlcnZhYmxlID0gT2JzZXJ2YWJsZS5jcmVhdGUoKG9ic2VydmVyOiBPYnNlcnZlcjxDb21tb25JbWFnZT4pID0+IHtcbiAgICAgICAgICAgIGNvbnN0IG1zcEltYWdlcyA9IFtdO1xuICAgICAgICAgICAgc2NhbGVGYWN0b3JzID0gc2NhbGVGYWN0b3JzLnNjYWxlRG93bihyZWR1Y3Rpb25TY2FsZUZhY3Rvcik7XG4gICAgICAgICAgICBmb3IgKGxldCBmaWxlSW5kZXggPSAwOyBmaWxlSW5kZXggPCBmaWxlTGlzdC5sZW5ndGg7IGZpbGVJbmRleCsrKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZmlsZSA9IGZpbGVMaXN0W2ZpbGVJbmRleF07XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coJ1N0YXJ0IHByb2Nlc3NpbmcgZmlsZSAnICsgZmlsZUluZGV4ICsgJyBvZiAnICsgZmlsZUxpc3QubGVuZ3RoICsgJyAlcyBvZiBzaXplICVzIGJ5dGVzICVzIHR5cGUnLCBmaWxlLm5hbWUsIGZpbGUuc2l6ZSwgZmlsZS50eXBlKTtcblxuXG4gICAgICAgICAgICAgICAgLyogUHJldmlvdXNseSBzZXQgaW4gYXBwQ29uc3RhbnRzICovXG4gICAgICAgICAgICAgICAgY29uc3QgcGRmU2NhbGVGYWN0b3IgPSAyLjA7XG5cbiAgICAgICAgICAgICAgICAvLyBsZXQgbXNwSW1hZ2U6IE1zcEltYWdlID0gbmV3IE1zcEltYWdlKCk7XG4gICAgICAgICAgICAgICAgLy8gbGV0IHJlYWRlcjogRmlsZVJlYWRlciA9IG5ldyBGaWxlUmVhZGVyKCk7XG5cbiAgICAgICAgICAgICAgICAvLyAvLyBDb3B5IGZpbGUgcHJvcGVydGllc1xuICAgICAgICAgICAgICAgIC8vIG1zcEltYWdlLm5hbWUgPSBmaWxlLm5hbWU7XG4gICAgICAgICAgICAgICAgaWYgKGZpbGUudHlwZSA9PT0gJ2FwcGxpY2F0aW9uL3BkZicpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gdGhpcy5sb2dTZXJ2aWNlLmxvZyh7bmFtZTogZmlsZS5uYW1lICsgJyBSZWNlaXZlZCBpbiBVcGxvYWQnLFxuICAgICAgICAgICAgICAgICAgICAvLyAgICAgVVVJRDogc2VsZi5kYXRhU2VydmljZS5nZXRNc3BVdWlkKCl9LCAnRmlsZV9VcGxvYWQnKTtcblxuICAgICAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgICAgICogIFBhZ2UgbnVtYmVyIGxvZ2ljIDpcbiAgICAgICAgICAgICAgICAgICAgICogICAgICBJbWFnZXMgLSBBc3NpZ24gY3VycmVudCBwYWdlIG51bWJlciB3aGljaGV2ZXIgaXMgYXZhaWxhYmxlLi5zbyBnZXQgdGhlIGN1cnJlbnQgcGFnZSBudW1iZXIgLCBwYXNzIGl0IHRvIGNhbGwgYmFjayBbcmVzZXJ2ZSBpdF0gYW5kIGluY3JlbWVudFxuICAgICAgICAgICAgICAgICAgICAgKiAgICAgIFBERiAgICAtICB3ZSBkb250IGtub3cgaG93IG1hbnkgcGFnZXMuLnNvIGNhbnQgZ2V0IGN1cnJlbnQgbnVtYmVyIGFuZCBrZWVwIGl0IHNpbmNlIGl0IGNhbiBiZSBtdWx0aXBsZSBwYWdlcy4uLiBzbyBzdGFydCBhc3NpZ25pbmcgbGF0ZXIgcG9pbnRcbiAgICAgICAgICAgICAgICAgICAgICogICAgICB3aGVuIFBERiBpcyB0b3RhbGx5IHJlYWQuLlxuICAgICAgICAgICAgICAgICAgICAgKlxuICAgICAgICAgICAgICAgICAgICAgKiAgKi9cblxuICAgICAgICAgICAgICAgICAgICB0aGlzLnJlYWRQREYoZmlsZSwgcGRmU2NhbGVGYWN0b3IsIChpbWFnZXM6IEhUTUxJbWFnZUVsZW1lbnRbXSAsIHBkZkZpbGU6IEZpbGUpID0+IHtcblxuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyB0aGlzLmxvZ1NlcnZpY2UubG9nKHtuYW1lOiBmaWxlLm5hbWUgKyAnaXMgc3VjY2Vzc2Z1bGx5IHNwbGl0IGludG8gJyArIGltYWdlcy5sZW5ndGggKyAnIGltYWdlcycsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gVVVJRDogc2VsZi5kYXRhU2VydmljZS5nZXRNc3BVdWlkKCl9LCAnRmlsZV9VcGxvYWQnKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgaW1hZ2VzLm1hcCgoaW1hZ2UsIGluZGV4KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaW1hZ2UubmFtZSA9IHBkZkZpbGUubmFtZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnJlc2l6ZUltYWdlKCBpbWFnZSwgc2VsZiwgc2NhbGVGYWN0b3JzLCBvYnNlcnZlciwgcGFnZU51bWJlciAsIHRydWUpOyAvLyBpbmRleCBzdGFydHMgZnJvbSB6ZXJvXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFnZU51bWJlciA9IHBhZ2VOdW1iZXIgKyAxICA7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfSwgKGVycm9yOiBzdHJpbmcpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdlcnJvcicgKyBKU09OLnN0cmluZ2lmeShlcnJvcikpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgaW1hZ2VSZWFkRXJyb3I6IENvbW1vbkltYWdlUHJvY2Vzc2luZ0Vycm9yID1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXcgQ29tbW9uSW1hZ2VQcm9jZXNzaW5nRXJyb3IoQ29tbW9uSW1hZ2VFcnJvci5DYW5ub3RPcGVuUERGLCBlcnJvcik7XG4gICAgICAgICAgICAgICAgICAgICAgICBvYnNlcnZlci5lcnJvcihpbWFnZVJlYWRFcnJvcik7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIExvYWQgaW1hZ2UgaW50byBpbWcgZWxlbWVudCB0byByZWFkIG5hdHVyYWwgaGVpZ2h0IGFuZCB3aWR0aFxuICAgICAgICAgICAgICAgICAgICB0aGlzLnJlYWRJbWFnZShmaWxlLCBwYWdlTnVtYmVyICwgKGltYWdlOiBIVE1MSW1hZ2VFbGVtZW50ICwgaW1hZ2VGaWxlOiBGaWxlICwgbmV4dFBhZ2VOdW1iZXI6IG51bWJlcikgID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbWFnZS5pZCA9IGltYWdlRmlsZS5uYW1lOyAvLyAubmFtZSBkZXByZWNhdGVkLCBjaGFuZ2VkIGltYWdlLm5hbWUgdG8gaW1hZ2UuaWRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnJlc2l6ZUltYWdlKGltYWdlLCBzZWxmLCBzY2FsZUZhY3RvcnMsIG9ic2VydmVyICwgbmV4dFBhZ2VOdW1iZXIgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGNhbiBiZSBpZ25vcmVkIGZvciBidWcsIHRoZSBsb2cgbGluZSBpcyBuZXZlciBjYWxsZWRcbiAgICAgICAgICAgICAgICAgICAgICAgIChlcnJvcjogQ29tbW9uSW1hZ2VQcm9jZXNzaW5nRXJyb3IpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygnZXJyb3InICsgSlNPTi5zdHJpbmdpZnkoZXJyb3IpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvYnNlcnZlci5lcnJvcihlcnJvcik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgcGFnZU51bWJlciA9IHBhZ2VOdW1iZXIgKyAxICA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyByZXRyeVdoZW4gaXMgcG90ZW50aWFsIGlzc3VlIVxuICAgICAgICB9KS5waXBlKHJldHJ5V2hlbih0aGlzLnJldHJ5U3RyYXRlZ3koMzIpKSk7XG4gICAgICAgIHJldHVybiBmaWxlT2JzZXJ2YWJsZTtcbiAgICB9XG5cblxuICAgIHByaXZhdGUgcmVzaXplSW1hZ2UoIGltYWdlOiBIVE1MSW1hZ2VFbGVtZW50LCBzZWxmOiB0aGlzLCBzY2FsZUZhY3RvcnM6IENvbW1vbkltYWdlU2NhbGVGYWN0b3JzLCBvYnNlcnZlcjogT2JzZXJ2ZXI8Q29tbW9uSW1hZ2U+LCBwYWdlTnVtYmVyOiBudW1iZXIgPSAwICwgaXNQZGY6IGJvb2xlYW4gPSBmYWxzZSkge1xuLy8gV2hpbGUgaXQncyBzdGlsbCBpbiBhbiBpbWFnZSwgZ2V0IGl0J3MgaGVpZ2h0IGFuZCB3aWR0aFxuICAgICAgICBjb25zdCBtc3BJbWFnZTogQ29tbW9uSW1hZ2UgPSBuZXcgQ29tbW9uSW1hZ2UoKTtcbiAgICAgICAgY29uc3QgcmVhZGVyOiBGaWxlUmVhZGVyID0gbmV3IEZpbGVSZWFkZXIoKTtcbiAgICAgICAgY29uc29sZS5sb2coJ2ltYWdlLm5hbWU6JyArIGltYWdlLmlkKTsgLy8gLm5hbWUgZGVwcmVjYXRlZCwgY2hhbmdlZCBpbWFnZS5uYW1lIHRvIGltYWdlLmlkXG4gICAgICAgIC8vIENvcHkgZmlsZSBwcm9wZXJ0aWVzXG4gICAgICAgIG1zcEltYWdlLm5hbWUgPSBpbWFnZS5pZCA7XG4gICAgICAgIGlmIChpc1BkZikge1xuICAgICAgICAgICAgbXNwSW1hZ2UubmFtZSA9IGltYWdlLm5hbWUgKyAnLXBhZ2UnICsgcGFnZU51bWJlcjsgIC8vIEp1c3QgZ2l2ZSBuYW1lIHRvIHBkZlxuICAgICAgICB9XG4gICAgICAgIC8vIFRlbXBvcmFyeSBzbyB3ZSBkb24ndCBoYXZlIGR1cGxpY2F0ZSBmaWxlIG5hbWVzLiBUT0RPOiBJbXByb3ZlLlxuICAgICAgICAvLyAgIG1zcEltYWdlLm5hbWUgKz0gTWF0aC5jZWlsKE1hdGgucmFuZG9tKCkqMTAwKTtcbiAgICAgICAgbXNwSW1hZ2UuYXR0YWNobWVudE9yZGVyID0gcGFnZU51bWJlciA7XG5cblxuICAgICAgICBtc3BJbWFnZS5uYXR1cmFsV2lkdGggPSBpbWFnZS5uYXR1cmFsV2lkdGg7XG4gICAgICAgIG1zcEltYWdlLm5hdHVyYWxIZWlnaHQgPSBpbWFnZS5uYXR1cmFsSGVpZ2h0O1xuXG4gICAgICAgIGNvbnNvbGUubG9nKGBpbWFnZSBmaWxlIG5hdHVyYWwgaGVpZ2h0IGFuZCB3aWR0aDpcbiAgICAgICAgICAgICR7bXNwSW1hZ2UubmF0dXJhbEhlaWdodH0geCAke21zcEltYWdlLm5hdHVyYWxXaWR0aH1gKTtcblxuICAgICAgICAvLyBDYW52YXMgd2lsbCBmb3JjZSB0aGUgY2hhbmdlIHRvIGEgSlBFR1xuICAgICAgICBtc3BJbWFnZS5jb250ZW50VHlwZSA9ICdpbWFnZS9qcGVnJzsgLy8gcHJldmlvdXNseSBpbiBhcHBDb25zdGFudHNcblxuICAgICAgICAvLyBTY2FsZSB0aGUgaW1hZ2UgYnkgbG9hZGluZyBpbnRvIGEgY2FudmFzXG5cbiAgICAgICAgY29uc29sZS5sb2coJ1N0YXJ0IHNjYWxpbmcgZG93biB0aGUgaW1hZ2UgdXNpbmcgYmx1ZWltcC1sb2FkLWltYWdlIGxpYjogJyk7XG4gICAgICAgIGNvbnN0IHNjYWxlZEltYWdlID0gbG9hZEltYWdlKFxuICAgICAgICAgICAgaW1hZ2Uuc3JjLCAvLyBOT1RFOiB3ZSBwYXNzIHRoZSBGaWxlIHJlZiBoZXJlIGFnYWluIGV2ZW4gdGhvdWdoIGl0cyBhbHJlYWR5IHJlYWQgYmVjYXVzZSB3ZSBuZWVkIHRoZSBYSUZGIG1ldGFkYXRhXG4gICAgICAgICAgICBmdW5jdGlvbiAoY2FudmFzOiBIVE1MQ2FudmFzRWxlbWVudCwgbWV0YWRhdGE6IGFueSkge1xuXG4gICAgICAgICAgICAgICAgLy8gQ2FudmFzIG1heSBiZSBhbiBFdmVudCB3aGVuIGVycm9ycyBoYXBwZW5zXG4gICAgICAgICAgICAgICAgaWYgKGNhbnZhcyBpbnN0YW5jZW9mIEV2ZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIHNlbGYuaGFuZGxlRXJyb3IoQ29tbW9uSW1hZ2VFcnJvci5Xcm9uZ1R5cGUsIG1zcEltYWdlKTtcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5yZXNldElucHV0RmllbGRzKCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gQ29udmVydCB0byBibG9iIHRvIGdldCBzaXplXG4gICAgICAgICAgICAgICAgY2FudmFzLnRvQmxvYigoYmxvYjogQmxvYikgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQ29weSB0aGUgYmxvYiBwcm9wZXJ0aWVzXG4gICAgICAgICAgICAgICAgICAgICAgICBtc3BJbWFnZS5zaXplID0gYmxvYi5zaXplO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBsb2cgaW1hZ2UgaW5mbyAoYnV0IG9ubHkgZm9yIHRoZSBmaXJzdCB0aW1lIGJlZm9yZSBhbnkgc2NhbGluZylcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGlmIChzXG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGZpbGVOYW1lID0gbXNwSW1hZ2UubmFtZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IG5CeXRlcyA9IG1zcEltYWdlLnNpemU7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgZmlsZVNpemUgPSAnJztcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBmaWxlU2l6ZVVuaXQgPSAnJztcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBzT3V0cHV0OiBzdHJpbmcgPSBuQnl0ZXMgKyAnIGJ5dGVzJztcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIG9wdGlvbmFsIGNvZGUgZm9yIG11bHRpcGxlcyBhcHByb3hpbWF0aW9uXG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBhTXVsdGlwbGVzID0gWydLaUInLCAnTWlCJywgJ0dpQicsICdUaUInLCAnUGlCJywgJ0VpQicsICdaaUInLCAnWWlCJ10sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuTXVsdGlwbGUgPSAwLCBuQXBwcm94ID0gbkJ5dGVzIC8gMTAyNDsgbkFwcHJveCA+IDE7IG5BcHByb3ggLz0gMTAyNCwgbk11bHRpcGxlKyspIHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNPdXRwdXQgPSBuQXBwcm94LnRvRml4ZWQoMykgKyAnICcgKyBhTXVsdGlwbGVzW25NdWx0aXBsZV0gKyAnICgnICsgbkJ5dGVzICsgJyBieXRlcyknO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpbGVTaXplID0gbkFwcHJveC50b0ZpeGVkKDApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpbGVTaXplVW5pdCA9IGFNdWx0aXBsZXNbbk11bHRpcGxlXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtc3BJbWFnZS5zaXplVW5pdCA9IGZpbGVTaXplVW5pdDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coYEZpbGUgJHtmaWxlTmFtZX0gaXMgc2NhbGVkIGRvd24gdG86ICR7c091dHB1dH1gKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1zcEltYWdlLnNpemVUeHQgPSBzT3V0cHV0O1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBjYWxsIHJlYWRlciB3aXRoIG5ldyB0cmFuc2Zvcm1lZCBpbWFnZVxuICAgICAgICAgICAgICAgICAgICAgICAgcmVhZGVyLm9ubG9hZCA9IGZ1bmN0aW9uIChldnQ6IGFueSkge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbXNwSW1hZ2UuZmlsZUNvbnRlbnQgPSBldnQudGFyZ2V0LnJlc3VsdDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtc3BJbWFnZS5pZCA9IHNoYTEobXNwSW1hZ2UuZmlsZUNvbnRlbnQpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8ga2VlcCBzY2FsaW5nIGRvd24gdGhlIGltYWdlIHVudGlsIHRoZSBpbWFnZSBzaXplIGlzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gdW5kZXIgbWF4IGltYWdlIHNpemVcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8qKiBwcmV2aW91c2x5IGluIGFwcENvbnN0YW50cyAqL1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IG1heFNpemVCeXRlcyA9IDEwNDg1NzY7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG1zcEltYWdlLnNpemUgPiBtYXhTaXplQnl0ZXMpIHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygnRmlsZSBzaXplIGFmdGVyIHNjYWxpbmcgZG93bjogJWQsIG1heCBmaWxlIHNpemUgYWxsb3dlZDogJWQnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbXNwSW1hZ2Uuc2l6ZSwgbWF4U2l6ZUJ5dGVzKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBpbWFnZVRvb0JpZ0Vycm9yOiBDb21tb25JbWFnZVByb2Nlc3NpbmdFcnJvciA9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXcgQ29tbW9uSW1hZ2VQcm9jZXNzaW5nRXJyb3IoQ29tbW9uSW1hZ2VFcnJvci5Ub29CaWcpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGltYWdlVG9vQmlnRXJyb3IubWF4U2l6ZUFsbG93ZWQgPSBtYXhTaXplQnl0ZXM7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGltYWdlVG9vQmlnRXJyb3IuY29tbW9uSW1hZ2UgPSBtc3BJbWFnZTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvYnNlcnZlci5lcnJvcihpbWFnZVRvb0JpZ0Vycm9yKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBsb2cgaW1hZ2UgaW5mb1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyAgIHNlbGYubG9nSW1hZ2VJbmZvKFwibXNwX2ZpbGUtdXBsb2FkZXJfYWZ0ZXJfcmVzaXplX2F0dHJpYnV0ZXNcIiwgc2VsZi5kYXRhU2VydmljZS5nZXRNc3BVdWlkKCksIG1zcEltYWdlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb2JzZXJ2ZXIubmV4dChtc3BJbWFnZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlYWRlci5yZWFkQXNEYXRhVVJMKGJsb2IpO1xuICAgICAgICAgICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICAgICAgICAgIC8vIFdoYXQgbWltZSB0eXBlIHRvIG1ha2UgdGhlIGJsb2IgYXMgYW5kIGpwZWcgcXVhbGl0eVxuICAgICAgICAgICAgICAgICAgICAnaW1hZ2UvanBlZycsIDAuNSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIG1heFdpZHRoOiAyNjAwICogc2NhbGVGYWN0b3JzLndpZHRoRmFjdG9yLFxuICAgICAgICAgICAgICAgIG1heEhlaWdodDogMzMwMCAqIHNjYWxlRmFjdG9ycy5oZWlnaHRGYWN0b3IsXG4gICAgICAgICAgICAgICAgY29udGFpbjogdHJ1ZSxcbiAgICAgICAgICAgICAgICBjYW52YXM6IHRydWUsXG4gICAgICAgICAgICAgICAgbWV0YTogdHJ1ZSxcbiAgICAgICAgICAgICAgICBvcmllbnRhdGlvbjogdHJ1ZVxuICAgICAgICAgICAgfVxuICAgICAgICApO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE1heCByZXRyeSBzY2FsaW5nIGRvd24gZm9yIG1heFJldHJ5IHRpbWVzLlxuICAgICAqL1xuICAgIHJldHJ5U3RyYXRlZ3kobWF4UmV0cnk6IG51bWJlcikge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGVycm9yczogT2JzZXJ2YWJsZTxDb21tb25JbWFnZVByb2Nlc3NpbmdFcnJvcj4pIHtcblxuICAgICAgICAgICAgLyoqRG9uZTogQ09NUExFVEUgVEhJUyEgRm9yIHNvbWUgcmVhc29uIGNhbid0IGdldCBzY2FuKCkgdG8gd29yaywgdHlwZXMgYWx3YXlzIG1hbGZvcm1lZC4qL1xuXG4gICAgICAgICAgICAvLyByZXR1cm4gZXJyb3JzLnBpcGUoXG4gICAgICAgICAgICAvLyAgICAgLy8gc2NhbigoYWNjLCBjdXJyKSA9PiB7YWNjICsgY3Vycn0sIDApXG4gICAgICAgICAgICAvLyAgICAgc2NhbigoYWNjLCBlcnJvciwgaW5kZXgpID0+IHtcbiAgICAgICAgICAgIC8vICAgICAgICAgcmV0dXJuIGFjYyArIGVycm9yO1xuICAgICAgICAgICAgLy8gICAgIH0sIDApXG4gICAgICAgICAgICAvLyApO1xuXG4gICAgICAgICAgICAvLyBEb25lOiBVbnN1cmUgaWYgd2UgaGF2ZSB0byByZS1pbXBsZW1lbnQgdGhpcyBsaW5lLiBJdCBjYXVzZXMgZXJyb3JzLCBidXQgc2ltcGx5IHJlbW92aW5nIGl0IG1heSBub3QgYmUgYXBwcm9wcmlhdGUuXG4gICAgICAgICAgICAvLyBOT1RFOiBSeEpTLWNvbXBhdCBtaWdodCBiZSBzYXZpbmcgdXMgaGVyZSBhbmQgXCJmaXhpbmdcIiB0aGUgZXJyb3JzLiBTZWUgaWYgZXJyb3JzIHJldHVybiB3aGVuIHdlIHJlbW92ZSByeGpzLWNvbXBhdC5cbiAgICAgICAgICAgIC8vIHJldHVybiBlcnJvcnMucGlwZShzY2FuKChhY2MsIGN1cnIpID0+IGFjYyArIGN1cnIsIDApKVxuXG5cbiAgICAgICAgICAgIHJldHVybiBlcnJvcnMucGlwZShzY2FuKFxuICAgICAgICAgICAgICAgIC8vIHJldHVybiBlcnJvcnMucGlwZShcbiAgICAgICAgICAgICAgICAoYWNjLCBlcnJvcjogYW55LCBpbmRleCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAvLyBjb25zb2xlLmxvZygnRXJyb3IgZW5jb3VudGVyZWQ6ICVvJywgZXJyb3IpOztcblxuICAgICAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgICAgICogSWYgdGhlIGVycm9yIGlzIGFib3V0IGZpbGUgdG9vIGJpZyBhbmQgd2UgaGF2ZSBub3QgcmVhY2ggbWF4IHJldHJ5XG4gICAgICAgICAgICAgICAgICAgICAqIHlldCwgdGhleXQga2VlcCBnb2luZyB0byBzY2FsaW5nIGRvd24uXG4gICAgICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgICAgICBpZiAoYWNjIDwgbWF4UmV0cnkgJiYgZXJyb3IuZXJyb3JDb2RlID09PSBDb21tb25JbWFnZUVycm9yLlRvb0JpZykge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gY29uc29sZS5sb2coJ1Byb2dyZXNzaXZlbHkgc2NhbGluZyBkb3duIHRoZSBpbWFnZSwgc3RlcCAlZC4nLCBpbmRleCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gYWNjICsgMTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAgICAgICAgICogRm9yIGVpdGhlciBjb25kaXRpb25zIHRlcm1pbmF0ZSB0aGUgcmV0cnksIHByb3BvZ2F0ZVxuICAgICAgICAgICAgICAgICAgICAgICAgICogdGhlIGVycm9yLlxuICAgICAgICAgICAgICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAgICAgICAgICAgICAqIDEuIGVycm9ycyBzdWNoIGFzIENhbm5vdFJlYWQgb3IgYW55IG90aGVyIHVua25vd24gZXJyb3JzXG4gICAgICAgICAgICAgICAgICAgICAgICAgKiBub3QgbGlzdGVkIGluIE1zcEltYWdlRXJyb3IgZW51bVxuICAgICAgICAgICAgICAgICAgICAgICAgICogMi4gRXhjZWVkZWQgbWF4UmV0cnlcbiAgICAgICAgICAgICAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdSZS10aHJvdyB0aGlzIGltYWdlIHByb2Nlc3MgZXJyb3I6ICVvJywgZXJyb3IpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9LCAwXG4gICAgICAgICAgICApLCBkZWxheSgyKSk7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgcHJpdmF0ZSByZWFkSW1hZ2UoaW1hZ2VGaWxlOiBGaWxlLCBuZXh0UGFnZU51bWJlcjogbnVtYmVyICxcbiAgICAgICAgICAgICAgICAgICAgICBjYWxsYmFjazogKGltYWdlOiBIVE1MSW1hZ2VFbGVtZW50LCBpbWFnZUZpbGU6IEZpbGUgLCBuZXh0UGFnZU51bWJlcjogbnVtYmVyKSA9PiB2b2lkLFxuICAgICAgICAgICAgICAgICAgICAgIGludmFsaWRJbWFnZUhhbmxkZXI6IChlcnJvcjogQ29tbW9uSW1hZ2VQcm9jZXNzaW5nRXJyb3IpID0+IHZvaWQpIHtcbiAgICAgICAgY29uc3QgcmVhZGVyID0gbmV3IEZpbGVSZWFkZXIoKTtcblxuICAgICAgICByZWFkZXIub25sb2FkID0gZnVuY3Rpb24gKHByb2dyZXNzRXZ0OiBQcm9ncmVzc0V2ZW50KSB7XG5cbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCdsb2FkaW5nIGltYWdlIGludG8gYW4gaW1nIHRhZzogJW8nLCBwcm9ncmVzc0V2dCk7XG4gICAgICAgICAgICAvLyBMb2FkIGludG8gYW4gaW1hZ2UgZWxlbWVudFxuICAgICAgICAgICAgY29uc3QgaW1nRWw6IEhUTUxJbWFnZUVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdpbWcnKTtcbiAgICAgICAgICAgIGltZ0VsLnNyYyA9IChyZWFkZXIucmVzdWx0IGFzIHN0cmluZyk7XG5cbiAgICAgICAgICAgIC8vIFdhaXQgZm9yIG9ubG9hZCBzbyBhbGwgcHJvcGVydGllcyBhcmUgcG9wdWxhdGVkXG4gICAgICAgICAgICBpbWdFbC5vbmxvYWQgPSAoYXJncykgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdDb21wbGV0ZWQgaW1hZ2UgbG9hZGluZyBpbnRvIGFuIGltZyB0YWc6ICVvJywgYXJncyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGltZ0VsLCBpbWFnZUZpbGUsIG5leHRQYWdlTnVtYmVyKTtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIGltZ0VsLm9uZXJyb3IgPVxuICAgICAgICAgICAgICAgIChhcmdzKSA9PiB7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gbG9nIGl0IHRvIHRoZSBjb25zb2xlXG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdUaGlzIGltYWdlIGNhbm5vdCBiZSBvcGVuZWQvcmVhZCwgaXQgaXMgcHJvYmFibHkgYW4gaW52YWxpZCBpbWFnZS4gJW8nLCBhcmdzKTtcblxuICAgICAgICAgICAgICAgICAgICAvLyB0aHJvdyBuZXcgRXJyb3IoJ1RoaXMgaW1hZ2UgY2Fubm90IGJlIG9wZW5lZC9yZWFkJyk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGltYWdlUmVhZEVycm9yOiBDb21tb25JbWFnZVByb2Nlc3NpbmdFcnJvciA9XG4gICAgICAgICAgICAgICAgICAgICAgICBuZXcgQ29tbW9uSW1hZ2VQcm9jZXNzaW5nRXJyb3IoQ29tbW9uSW1hZ2VFcnJvci5DYW5ub3RPcGVuKTtcblxuICAgICAgICAgICAgICAgICAgICBpbWFnZVJlYWRFcnJvci5yYXdJbWFnZUZpbGUgPSBpbWFnZUZpbGU7XG5cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGludmFsaWRJbWFnZUhhbmxkZXIoaW1hZ2VSZWFkRXJyb3IpO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgIH07XG5cbiAgICAgICAgcmVhZGVyLnJlYWRBc0RhdGFVUkwoaW1hZ2VGaWxlKTtcbiAgICB9XG5cbiAgICBwcml2YXRlIHJlYWRQREYocGRmRmlsZTogRmlsZSwgcGRmU2NhbGVGYWN0b3I6IG51bWJlcixcbiAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2s6IChpbWFnZTogSFRNTEltYWdlRWxlbWVudFtdLCBwZGZGaWxlOiBGaWxlKSA9PiB2b2lkLCBlcnJvcjogKGVycm9yUmVhc29uOiBhbnkpID0+IHZvaWQpIHtcblxuICAgICAgICBQREZKUy5kaXNhYmxlV29ya2VyID0gdHJ1ZTtcbiAgICAgICAgUERGSlMuZGlzYWJsZVN0cmVhbSA9IHRydWU7XG5cbiAgICAgICAgY29uc3QgcmVhZGVyID0gbmV3IEZpbGVSZWFkZXIoKTtcbiAgICAgICAgbGV0IGN1cnJlbnRQYWdlID0gMTtcbiAgICAgICAgY29uc3QgY2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7XG4gICAgICAgIGNvbnN0IGltZ0Vsc0FycmF5OiBIVE1MSW1hZ2VFbGVtZW50W10gPSBbXTtcbiAgICAgICAgY29uc3QgY3R4ID0gY2FudmFzLmdldENvbnRleHQoJzJkJyk7XG4gICAgICAgIHJlYWRlci5vbmxvYWQgPSBmdW5jdGlvbiAocHJvZ3Jlc3NFdnQ6IFByb2dyZXNzRXZlbnQpIHtcblxuICAgICAgICAgICAgY29uc3QgZG9jSW5pdFBhcmFtcyA9IHtkYXRhOiByZWFkZXIucmVzdWx0fTtcbiAgICAgICAgICAgIC8vIFRPRE8gLSBUaGUgJ2FzIGFueScgd2FzIGFkZGVkIHdoZW4gcG9ydGluZyB0byBjb21tb24gbGlicmFyeSBmcm9tIE1TUFxuICAgICAgICAgICAgUERGSlMuZ2V0RG9jdW1lbnQoKGRvY0luaXRQYXJhbXMgYXMgYW55KSkudGhlbigocGRmZG9jKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgbnVtUGFnZXMgPSBwZGZkb2MubnVtUGFnZXM7XG4gICAgICAgICAgICAgICAgaWYgKGN1cnJlbnRQYWdlIDw9IHBkZmRvYy5udW1QYWdlcykgeyBnZXRQYWdlKCk7IH1cblxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIGdldFBhZ2UoKSB7XG4gICAgICAgICAgICAgICAgICAgIHBkZmRvYy5nZXRQYWdlKGN1cnJlbnRQYWdlKS50aGVuKGZ1bmN0aW9uIChwYWdlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB2aWV3cG9ydCA9IHBhZ2UuZ2V0Vmlld3BvcnQocGRmU2NhbGVGYWN0b3IpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBjYW52YXMuaGVpZ2h0ID0gdmlld3BvcnQuaGVpZ2h0O1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FudmFzLndpZHRoID0gdmlld3BvcnQud2lkdGg7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlbmRlckNvbnRleHQgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FudmFzQ29udGV4dDogY3R4LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZpZXdwb3J0OiB2aWV3cG9ydFxuICAgICAgICAgICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgcGFnZS5yZW5kZXIocmVuZGVyQ29udGV4dCkudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgaW1nRWw6IEhUTUxJbWFnZUVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdpbWcnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbWdFbC5zcmMgPSBjYW52YXMudG9EYXRhVVJMKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaW1nRWxzQXJyYXkucHVzaChpbWdFbCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGN1cnJlbnRQYWdlIDwgbnVtUGFnZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudFBhZ2UrKztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZ2V0UGFnZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKGltZ0Vsc0FycmF5LCBwZGZGaWxlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9LCBmdW5jdGlvbiAoZXJyb3JSZWFzb246IHN0cmluZykge1xuICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3IoZXJyb3JSZWFzb24pO1xuXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIGZ1bmN0aW9uIChlcnJvclJlYXNvbjogc3RyaW5nKSB7XG4gICAgICAgICAgICAgICAgZXJyb3IoZXJyb3JSZWFzb24pO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgfTtcbiAgICAgICAgcmVhZGVyLnJlYWRBc0FycmF5QnVmZmVyKHBkZkZpbGUpO1xuXG4gICAgfVxuXG5cbiAgICAvKipcbiAgICAgKiBOb24gcmV2ZXJzaWJsZSBpbWFnZSBmaWx0ZXIgdG8gdGFrZSBhbiBleGlzdGluZyBjYW52YXMgYW5kIG1ha2UgaXQgZ3JheSBzY2FsZVxuICAgICAqIEBwYXJhbSBjYW52YXNcbiAgICAgKi9cbiAgICBtYWtlR3JheVNjYWxlKGNhbnZhczogSFRNTENhbnZhc0VsZW1lbnQpOiB2b2lkIHtcbiAgICAgICAgY29uc3QgY29udGV4dCA9IGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xuXG4gICAgICAgIGNvbnN0IGltYWdlRGF0YSA9IGNvbnRleHQuZ2V0SW1hZ2VEYXRhKDAsIDAsIGNhbnZhcy53aWR0aCwgY2FudmFzLmhlaWdodCk7XG4gICAgICAgIGNvbnN0IGRhdGEgPSBpbWFnZURhdGEuZGF0YTtcblxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGRhdGEubGVuZ3RoOyBpICs9IDQpIHtcbiAgICAgICAgICAgIGNvbnN0IGJyaWdodG5lc3MgPSAwLjM0ICogZGF0YVtpXSArIDAuNSAqIGRhdGFbaSArIDFdICsgMC4xNiAqIGRhdGFbaSArIDJdO1xuICAgICAgICAgICAgLy8gcmVkXG4gICAgICAgICAgICBkYXRhW2ldID0gYnJpZ2h0bmVzcztcbiAgICAgICAgICAgIC8vIGdyZWVuXG4gICAgICAgICAgICBkYXRhW2kgKyAxXSA9IGJyaWdodG5lc3M7XG4gICAgICAgICAgICAvLyBibHVlXG4gICAgICAgICAgICBkYXRhW2kgKyAyXSA9IGJyaWdodG5lc3M7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBvdmVyd3JpdGUgb3JpZ2luYWwgaW1hZ2VcbiAgICAgICAgY29udGV4dC5wdXRJbWFnZURhdGEoaW1hZ2VEYXRhLCAwLCAwKTtcbiAgICB9XG5cblxuICAgIGhhbmRsZUltYWdlRmlsZShtc3BJbWFnZTogQ29tbW9uSW1hZ2UpIHtcbiAgICAgICAgY29uc29sZS5sb2coJ2ltYWdlIHNpemUgKGJ5dGVzKSBhZnRlciBjb21wcmVzc2lvbjogJyArIG1zcEltYWdlLnNpemUpO1xuICAgICAgICBpZiAodGhpcy5pbWFnZXMubGVuZ3RoID49IDUwKSB7XG5cbiAgICAgICAgICAgIC8vIGxvZyBpdFxuICAgICAgICAgICAgLy8gdGhpcy5sb2dJbWFnZUluZm8oJ21zcF9maWxlLXVwbG9hZGVyX2Vycm9yJywgdGhpcy5kYXRhU2VydmljZS5nZXRNc3BVdWlkKCksXG4gICAgICAgICAgICAvLyAgICAgbXNwSW1hZ2UsIGBOdW1iZXIgb2YgaW1hZ2UgZmlsZXMgZXhjZWVkcyBtYXggb2YgJHs1MH1gKTtcblxuICAgICAgICAgICAgLy8gbG9nIHRvIGNvbnNvbGVcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKGBNYXggbnVtYmVyIG9mIGltYWdlIGZpbGUgeW91IGNhbiB1cGxvYWQgaXMgJHs1MH0uXG4gICAgICBUaGlzIGZpbGUgJHttc3BJbWFnZS5uYW1lfSB3YXMgbm90IHVwbG9hZGVkLmApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5pbWFnZXMucHVzaChtc3BJbWFnZSk7XG4gICAgICAgICAgICB0aGlzLmltYWdlc0NoYW5nZS5lbWl0KHRoaXMuaW1hZ2VzKTtcbiAgICAgICAgICAgIHRoaXMuc2hvd0Vycm9yID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLm5vSWRJbWFnZSA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgaGFuZGxlRXJyb3IoZXJyb3I6IENvbW1vbkltYWdlRXJyb3IsIG1zcEltYWdlOiBDb21tb25JbWFnZSwgZXJyb3JEZXNjcmlwdGlvbj86IHN0cmluZykge1xuXG4gICAgICAgIGlmICghbXNwSW1hZ2UpIHtcbiAgICAgICAgICAgIG1zcEltYWdlID0gbmV3IENvbW1vbkltYWdlKCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8ganVzdCBhZGQgdGhlIGVycm9yIHRvIG1zcEltYWdlXG4gICAgICAgIG1zcEltYWdlLmVycm9yID0gZXJyb3I7XG5cbiAgICAgICAgLy8gbG9nIHRoZSBlcnJvclxuICAgICAgICBpZiAoZXJyb3IgIT09IENvbW1vbkltYWdlRXJyb3IuUERGbm90U3VwcG9ydGVkKSB7XG4gICAgICAgICAgICAvLyB0aGlzLmxvZ0ltYWdlSW5mbygnbXNwX2ZpbGUtdXBsb2FkZXJfZXJyb3InLCB0aGlzLmRhdGFTZXJ2aWNlLmdldE1zcFV1aWQoKSwgbXNwSW1hZ2UsXG4gICAgICAgICAgICAvLyAgICAgJyAgbXNwSW1hZ2VGaWxlOiAnICsgbXNwSW1hZ2UubmFtZSArICcgIG1zcEVycm9yTnVtOiAnICsgZXJyb3IgKyAnICBtc3BFcnJvcjogJyArXG4gICAgICAgICAgICAvLyAgICAgZXJyb3IgKyAnLScgKyBlcnJvckRlc2NyaXB0aW9uKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGNvbnNvbGUubG9nKFwiZXJyb3Igd2l0aCBpbWFnZTogXCIsIG1zcEltYWdlKTtcbiAgICAgICAgdGhpcy5lcnJvckRvY3VtZW50LmVtaXQobXNwSW1hZ2UpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlc2V0IGlucHV0IGZpZWxkcyBzbyB0aGF0IHVzZXIgY2FuIGRlbGV0ZSBhIGZpbGUgYW5kXG4gICAgICogaW1tZWRpYXRlbHkgdXBsb2FkIHRoYXQgZmlsZSBhZ2Fpbi5cbiAgICAgKi9cbiAgICByZXNldElucHV0RmllbGRzKCkge1xuICAgICAgICAvLyBsZXQgYnJvc3dlRmlsZUlucHV0RWxlbWVudCA9IHRoaXMuYnJvd3NlRmlsZVJlZi5uYXRpdmVFbGVtZW50O1xuICAgICAgICAvLyBsZXQgY2FwdHVyZUZpbGVJbnB1dEVsZW1lbnQgPSB0aGlzLmNhcHR1cmVGaWxlUmVmLm5hdGl2ZUVsZW1lbnQ7XG4gICAgICAgIHRoaXMuYnJvd3NlRmlsZVJlZi5uYXRpdmVFbGVtZW50LnZhbHVlID0gJyc7XG4gICAgICAgIC8vIHRoaXMuY2FwdHVyZUZpbGVSZWYubmF0aXZlRWxlbWVudC52YWx1ZSA9ICcnO1xuICAgIH1cblxuICAgIGRlbGV0ZUltYWdlKG1zcEltYWdlOiBDb21tb25JbWFnZSkge1xuICAgICAgICB0aGlzLnJlc2V0SW5wdXRGaWVsZHMoKTtcbiAgICAgICAgdGhpcy5pbWFnZXMgPSB0aGlzLmltYWdlcy5maWx0ZXIoeCA9PiB4LnV1aWQgIT09IG1zcEltYWdlLnV1aWQpO1xuICAgICAgICB0aGlzLmltYWdlc0NoYW5nZS5lbWl0KHRoaXMuaW1hZ2VzKTtcblxuICAgICAgICAvLyBJZiB0aGVyZSBhcmUgbm8gaW1hZ2VzIHlldCwgd2UgaGF2ZSB0byByZXNldCB0aGUgaW5wdXQgc28gaXQgdHJpZ2dlcnMgJ3JlcXVpcmVkJy5cbiAgICAgICAgaWYgKCB0aGlzLnJlcXVpcmVkICYmIHRoaXMuaW1hZ2VzLmxlbmd0aCA8PSAwICkge1xuICAgICAgICAgICAgY29uc29sZS5sb2coJ05vIGltYWdlcywgcmVzZXR0aW5nIGlucHV0Jyk7XG4gICAgICAgICAgICAvLyB0aGlzLmZpbGVDb250cm9sLnZhbHVlID0gJyc7XG4gICAgICAgICAgICB0aGlzLmZpbGVDb250cm9sLnNldEVycm9ycyh7J3JlcXVpcmVkJzogdHJ1ZX0pO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTG9nIGltYWdlIGF0dHJpYnV0ZXNcbiAgICAgKiBAcGFyYW0gbXNwSW1hZ2VcbiAgICAgKi9cbiAgICBwcml2YXRlIGxvZ0ltYWdlSW5mbyh0aXRsZTogc3RyaW5nLCBhcHBsaWNhdGlvbklkOiBzdHJpbmcsIG1zcEltYWdlOiBDb21tb25JbWFnZSwgYWRkaXRpb25hbEluZm8/OiBzdHJpbmcpIHtcblxuICAgICAgICAvLyBUT0RPIVxuICAgICAgICAvLyAvLyBjcmVhdGUgbG9nIGVudHJ5XG4gICAgICAgIC8vIGNvbnN0IGxvZzogTG9nRW50cnkgPSBuZXcgTG9nRW50cnkoKTtcbiAgICAgICAgLy8gbG9nLmFwcGxpY2F0aW9uSWQgPSBhcHBsaWNhdGlvbklkO1xuICAgICAgICAvLyBjb25zdCBub3cgPSBtb21lbnQoKTtcbiAgICAgICAgLy8gbG9nLm1zcFRpbWVzdGFtcCA9IG5vdy50b0lTT1N0cmluZygpO1xuICAgICAgICAvLyBsb2cuYXBwbGljYXRpb25QaGFzZSA9IHRpdGxlICsgJzogIG1zcEltYWdlSWQ6ICcgKyBtc3BJbWFnZS5pZFxuICAgICAgICAvLyAgICAgKyAnICBtc3BJbWFnZVV1aWQ6ICcgKyBtc3BJbWFnZS51dWlkXG4gICAgICAgIC8vICAgICArICcgIG1zcEltYWdlU2l6ZTogJyArIG1zcEltYWdlLnNpemVcbiAgICAgICAgLy8gICAgICsgJyAgbXNwSW1hZ2VXaWR0aDogJyArIG1zcEltYWdlLm5hdHVyYWxXaWR0aFxuICAgICAgICAvLyAgICAgKyAnICBtc3BJbWFnZUhlaWdodDogJyArIG1zcEltYWdlLm5hdHVyYWxIZWlnaHRcbiAgICAgICAgLy8gICAgICsgJyAgbXNwSW1hZ2VDb250ZW50VHlwZTogJyArIG1zcEltYWdlLmNvbnRlbnRUeXBlXG4gICAgICAgIC8vICAgICArIChhZGRpdGlvbmFsSW5mbyA/ICcgICcgKyBhZGRpdGlvbmFsSW5mbyA6ICcnKTtcblxuICAgICAgICAvLyAvLyBzZW5kIGl0IHdoaWxlIHN1YnNjcmliaW5nIHRvIHJlc3BvbnNlXG4gICAgICAgIC8vIHRoaXMubG9nU2VydmljZS5sb2dJdChsb2csIHRpdGxlKS5zdWJzY3JpYmUoXG4gICAgICAgIC8vICAgICAocmVzcG9uc2UpID0+IHtcbiAgICAgICAgLy8gICAgICAgICAvLyBjb25zb2xlLmxvZygnbG9nIHJlc3Qgc2VydmljZSByZXNwb25zZTogJyk7XG4gICAgICAgIC8vICAgICAgICAgLy8gY29uc29sZS5sb2cocmVzcG9uc2UpO1xuICAgICAgICAvLyAgICAgfSxcbiAgICAgICAgLy8gICAgIChlcnJvcikgPT4ge1xuICAgICAgICAvLyAgICAgICAgIGNvbnNvbGUubG9nKCdIVFRQIGVycm9yIHJlc3BvbnNlIGZyb20gbG9nZ2luZyBzZXJ2aWNlOiAnKTtcbiAgICAgICAgLy8gICAgICAgICBjb25zb2xlLmxvZyhlcnJvcik7XG4gICAgICAgIC8vICAgICB9LFxuICAgICAgICAvLyAgICAgKCkgPT4ge1xuICAgICAgICAvLyAgICAgICAgIC8vIGNvbnNvbGUubG9nKCdsb2cgcmVzdCBzZXJ2aWNlIGNvbXBsZXRlZCEnKTtcbiAgICAgICAgLy8gICAgIH1cbiAgICAgICAgLy8gKTtcbiAgICB9XG5cblxuXG4gICAgLyoqXG4gICAgICogUmV0dXJuIHRydWUgaWYgdGhlIGltYWdlIHNpemUgaXMgd2l0aGluIHJhbmdlXG4gICAgICogQHBhcmFtIGZpbGVcbiAgICAgKi9cbiAgICBjaGVja0ltYWdlRGltZW5zaW9ucyhmaWxlOiBDb21tb25JbWFnZSk6IGJvb2xlYW4ge1xuICAgICAgICBpZiAoZmlsZS5uYXR1cmFsSGVpZ2h0IDwgMCB8fFxuICAgICAgICAgICAgZmlsZS5uYXR1cmFsV2lkdGggPCAwICkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIGlzVmFsaWQoKTogYm9vbGVhbiB7XG4gICAgICAgIGNvbnNvbGUubG9nKCdpc1ZhbGlkJywgdGhpcy5pbWFnZXMpO1xuICAgICAgICBpZiAodGhpcy5yZXF1aXJlZCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuaW1hZ2VzICYmIHRoaXMuaW1hZ2VzLmxlbmd0aCA+IDA7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIC8vIGdldEFwcGxpY2F0aW9uVHlwZSgpOiBBcHBsaWNhdGlvbkJhc2UgIHtcbiAgICAvLyAgICAgaWYgKHRoaXMucm91dGVyLnVybC5pbmRleE9mKCcvYXNzaXN0YW5jZS8nKSAhPT0gLTEpIHtcbiAgICAvLyAgICAgICAgIHJldHVybiB0aGlzLmRhdGFTZXJ2aWNlLmZpbkFzc2lzdEFwcDtcbiAgICAvLyAgICAgfVxuICAgIC8vICAgICBpZiAodGhpcy5yb3V0ZXIudXJsLmluZGV4T2YoJy9hcHBsaWNhdGlvbi8nKSAhPT0gLTEpIHtcbiAgICAvLyAgICAgICAgIHJldHVybiB0aGlzLmRhdGFTZXJ2aWNlLmdldE1zcEFwcGxpY2F0aW9uKCk7XG4gICAgLy8gICAgIH1cbiAgICAvLyAgICAgaWYgKHRoaXMucm91dGVyLnVybC5pbmRleE9mKCcvYWNjb3VudC8nKSAhPT0gLTEpIHtcbiAgICAvLyAgICAgICAgIHJldHVybiB0aGlzLmRhdGFTZXJ2aWNlLmdldE1zcEFjY291bnRBcHAoKTtcbiAgICAvLyAgICAgfVxuICAgIC8vIH1cblxuXG59XG5cbiJdfQ==