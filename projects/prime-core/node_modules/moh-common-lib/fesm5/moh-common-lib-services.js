import { catchError, tap, map } from 'rxjs/operators';
import { __extends } from 'tslib';
import { Injectable, defineInjectable, inject } from '@angular/core';
import { HttpClient, HttpHeaders, HttpParams } from '@angular/common/http';
import { throwError } from 'rxjs';
import * as moment_ from 'moment';

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * Abstract class for HTTP Service
 * @abstract
 */
var  /**
 * Abstract class for HTTP Service
 * @abstract
 */
AbstractHttpService = /** @class */ (function () {
    function AbstractHttpService(http) {
        this.http = http;
        this.logHTTPRequestsToConsole = false;
    }
    /**
     * Makes a GET request to the specified URL, using headers and HTTP options specified in their respective methods.
     * @param url Target URL to make the GET request
     */
    /**
     * Makes a GET request to the specified URL, using headers and HTTP options specified in their respective methods.
     * @protected
     * @template T
     * @param {?} url Target URL to make the GET request
     * @param {?=} queryParams
     * @return {?}
     */
    AbstractHttpService.prototype.get = /**
     * Makes a GET request to the specified URL, using headers and HTTP options specified in their respective methods.
     * @protected
     * @template T
     * @param {?} url Target URL to make the GET request
     * @param {?=} queryParams
     * @return {?}
     */
    function (url, queryParams) {
        /**
         * The HTTP request observer with always on error handling
         * @type {?}
         */
        var httpOpts = this.httpOptions;
        httpOpts.params = queryParams ? queryParams : undefined;
        /** @type {?} */
        var observable = this.http.get(url, httpOpts);
        return this.setupRequest(observable);
    };
    /**
     * @protected
     * @template T
     * @param {?} url
     * @param {?} body
     * @return {?}
     */
    AbstractHttpService.prototype.post = /**
     * @protected
     * @template T
     * @param {?} url
     * @param {?} body
     * @return {?}
     */
    function (url, body) {
        if (this.logHTTPRequestsToConsole) {
            console.log('Post Request: ', body);
        }
        /** @type {?} */
        var observable = this.http.post(url, body, this.httpOptions);
        return this.setupRequest(observable);
    };
    /**
     * @protected
     * @template T
     * @param {?} observable
     * @return {?}
     */
    AbstractHttpService.prototype.setupRequest = /**
     * @protected
     * @template T
     * @param {?} observable
     * @return {?}
     */
    function (observable) {
        // All failed requests should trigger the abstract method handleError
        observable = observable.pipe(catchError(this.handleError.bind(this)));
        // Optionally add console logging
        if (this.logHTTPRequestsToConsole) {
            observable = observable.pipe(tap((/**
             * @param {?} data
             * @return {?}
             */
            function (data) { return console.log('HTTP Success: ', data); }), (/**
             * @param {?} error
             * @return {?}
             */
            function (error) { return console.log('HTTP Error: ', error); })));
        }
        return observable;
    };
    Object.defineProperty(AbstractHttpService.prototype, "httpOptions", {
        /** The HttpOptions object that Angular takes for GET and POST requests. Used in every HTTP request from this service. */
        get: /**
         * The HttpOptions object that Angular takes for GET and POST requests. Used in every HTTP request from this service.
         * @protected
         * @return {?}
         */
        function () {
            return {
                headers: this._headers
            };
        },
        enumerable: true,
        configurable: true
    });
    return AbstractHttpService;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var GeocoderService = /** @class */ (function (_super) {
    __extends(GeocoderService, _super);
    function GeocoderService(http) {
        var _this = _super.call(this, http) || this;
        _this.http = http;
        _this._headers = new HttpHeaders();
        _this.BASE_URL = 'https://geocoder.api.gov.bc.ca';
        _this.ADDRESS_URL = _this.BASE_URL + "/addresses.json?";
        /**
         * Defaults for service
         */
        _this.defaultCountry = 'Canada';
        _this.defaultProv = 'British Columbia';
        return _this;
    }
    // https://geocoder.api.gov.bc.ca/addresses.json?minScore=50&maxResults=5&echo=false&brief=true&autoComplete=true&addressString=784+Hock
    // https://geocoder.api.gov.bc.ca/addresses.json?minScore=50&maxResults=5&echo=false&brief=true&autoComplete=true&addressString=784+Hock
    /**
     * @param {?} address
     * @return {?}
     */
    GeocoderService.prototype.lookup = 
    // https://geocoder.api.gov.bc.ca/addresses.json?minScore=50&maxResults=5&echo=false&brief=true&autoComplete=true&addressString=784+Hock
    /**
     * @param {?} address
     * @return {?}
     */
    function (address) {
        /** @type {?} */
        var params = new HttpParams()
            .set('minScore', '50')
            .set('maxResults', '10')
            .set('echo', 'false')
            .set('brief', 'false') // API splits address string up into sub-attributes, like city  / street name
            .set('autoComplete', 'true')
            .set('matchPrecisionNot', 'LOCALITY,STREET,BLOCK,INTERSECTION')
            .set('addressString', address);
        return this.get(this.ADDRESS_URL, params).pipe(map(this.processResponse));
    };
    /**
     * Formats the response from ADDRESS_URL, trimming irrelevant fields.
     *
     * This works for other requests for the same API too, however it may error
     * out on some items if matchPrecisionNot is not set.
     *
     * @param obj The response from ADDRESS_URL
     */
    /**
     * Formats the response from ADDRESS_URL, trimming irrelevant fields.
     *
     * This works for other requests for the same API too, however it may error
     * out on some items if matchPrecisionNot is not set.
     *
     * @private
     * @param {?} obj The response from ADDRESS_URL
     * @return {?}
     */
    GeocoderService.prototype.processResponse = /**
     * Formats the response from ADDRESS_URL, trimming irrelevant fields.
     *
     * This works for other requests for the same API too, however it may error
     * out on some items if matchPrecisionNot is not set.
     *
     * @private
     * @param {?} obj The response from ADDRESS_URL
     * @return {?}
     */
    function (obj) {
        var _this = this;
        return obj.features.map((/**
         * @param {?} feature
         * @return {?}
         */
        function (feature) {
            /** @type {?} */
            var props = feature.properties;
            /** @type {?} */
            var city = props.localityName;
            // We get street just by trimming everything before city, more
            // stable than looking for commas, etc.
            /** @type {?} */
            var cityIndex = props.fullAddress.indexOf(", " + city);
            /** @type {?} */
            var street = props.fullAddress.slice(0, cityIndex);
            return {
                fullAddress: props.fullAddress,
                city: city,
                street: street,
                country: _this.defaultCountry,
                // Default to Canada
                province: _this.defaultProv // Default to BC
            };
        }));
    };
    /**
     * @protected
     * @param {?} error
     * @return {?}
     */
    GeocoderService.prototype.handleError = /**
     * @protected
     * @param {?} error
     * @return {?}
     */
    function (error) {
        console.error('GeoCoder network error', { error: error });
        return throwError('Geocoder error');
    };
    GeocoderService.decorators = [
        { type: Injectable, args: [{
                    providedIn: 'root'
                },] }
    ];
    /** @nocollapse */
    GeocoderService.ctorParameters = function () { return [
        { type: HttpClient }
    ]; };
    /** @nocollapse */ GeocoderService.ngInjectableDef = defineInjectable({ factory: function GeocoderService_Factory() { return new GeocoderService(inject(HttpClient)); }, token: GeocoderService, providedIn: "root" });
    return GeocoderService;
}(AbstractHttpService));

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
var moment = moment_;
var CommonLogger = /** @class */ (function (_super) {
    __extends(CommonLogger, _super);
    function CommonLogger(http) {
        var _this = _super.call(this, http) || this;
        _this.http = http;
        /**
         * The HTTP Headers which go with each request.  These MUST be set if you are
         * using the logger.  Fields include:
         *
         * - program (REQUIRED, the application wide code)
         * - applicationId (REQUIRED, like sessionId)
         * - request_method (REQUIRED, 'POST')
         * - logsource: (REQUIRED, window.location.hostname)
         * - http_x_forwarded_host (REQUIRED, window.location.hostname)
         *
         */
        _this._headers = new HttpHeaders({
            request_method: 'POST',
            logsource: window.location.hostname,
            http_x_forwarded_host: window.location.hostname
        });
        _this.url = null;
        return _this;
    }
    Object.defineProperty(CommonLogger.prototype, "applicationId", {
        get: /**
         * @return {?}
         */
        function () {
            return this._headers.get('applicationId');
        },
        set: /**
         * @param {?} id
         * @return {?}
         */
        function (id) {
            this._headers = this._headers.set('applicationId', id);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(CommonLogger.prototype, "programName", {
        get: /**
         * @return {?}
         */
        function () {
            return this._headers.get('name');
        },
        set: /**
         * @param {?} name
         * @return {?}
         */
        function (name) {
            this._headers = this._headers.set('program', name);
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @param {?} newURL
     * @return {?}
     */
    CommonLogger.prototype.setURL = /**
     * @param {?} newURL
     * @return {?}
     */
    function (newURL) {
        this.url = newURL;
    };
    /**
     * @param {?} message
     * @return {?}
     */
    CommonLogger.prototype.log = /**
     * @param {?} message
     * @return {?}
     */
    function (message) {
        this._log((/** @type {?} */ (message)));
    };
    /**
     * @param {?} errorMessage
     * @return {?}
     */
    CommonLogger.prototype.logError = /**
     * @param {?} errorMessage
     * @return {?}
     */
    function (errorMessage) {
        this._logError((/** @type {?} */ (errorMessage)));
    };
    /**
     * Log a message to Splunk. This is the main way to send logs and
     * automatically includes meta-data. You do **not** need to subscribe to the
     * response, as the service already does that. The input object must have an
     * 'event' property set, everything else is optional.
     *
     * Example:
     * ```
      this.logService.log({
         event: 'submission',
         dateObj: new Date()
      });
      ```
     * @param message A JavaScript object, nesting is fine, with `event` property
     * set.
     */
    /**
     * Log a message to Splunk. This is the main way to send logs and
     * automatically includes meta-data. You do **not** need to subscribe to the
     * response, as the service already does that. The input object must have an
     * 'event' property set, everything else is optional.
     *
     * Example:
     * ```
     * this.logService.log({
     * event: 'submission',
     * dateObj: new Date()
     * });
     * ```
     * @protected
     * @param {?} message A JavaScript object, nesting is fine, with `event` property
     * set.
     * @return {?}
     */
    CommonLogger.prototype._log = /**
     * Log a message to Splunk. This is the main way to send logs and
     * automatically includes meta-data. You do **not** need to subscribe to the
     * response, as the service already does that. The input object must have an
     * 'event' property set, everything else is optional.
     *
     * Example:
     * ```
     * this.logService.log({
     * event: 'submission',
     * dateObj: new Date()
     * });
     * ```
     * @protected
     * @param {?} message A JavaScript object, nesting is fine, with `event` property
     * set.
     * @return {?}
     */
    function (message) {
        this.setSeverity(SeverityLevels.INFO);
        return this._sendLog(message);
    };
    /**
     * @protected
     * @param {?} errorMessage
     * @return {?}
     */
    CommonLogger.prototype._logError = /**
     * @protected
     * @param {?} errorMessage
     * @return {?}
     */
    function (errorMessage) {
        this.setSeverity(SeverityLevels.ERROR);
        return this._sendLog(errorMessage);
    };
    /**
     * Log HTTP errors, e.g. when losing network connectivity or receiving an
     * error response code.
     */
    /**
     * Log HTTP errors, e.g. when losing network connectivity or receiving an
     * error response code.
     * @param {?} error
     * @return {?}
     */
    CommonLogger.prototype.logHttpError = /**
     * Log HTTP errors, e.g. when losing network connectivity or receiving an
     * error response code.
     * @param {?} error
     * @return {?}
     */
    function (error) {
        return this._logError({
            event: 'error',
            message: error.message,
            errorName: error.name,
            statusText: error.statusText
        });
    };
    /**
     * Internal method to send logs to Splunk, includes meta-data except that's
     * consistent across all requests, but not specific values like severity
     * level.
     *
     * @param message A JavaScript object or anything that can be toString()'d,
     * like Date
     */
    /**
     * Internal method to send logs to Splunk, includes meta-data except that's
     * consistent across all requests, but not specific values like severity
     * level.
     *
     * @private
     * @param {?} message A JavaScript object or anything that can be toString()'d,
     * like Date
     * @return {?}
     */
    CommonLogger.prototype._sendLog = /**
     * Internal method to send logs to Splunk, includes meta-data except that's
     * consistent across all requests, but not specific values like severity
     * level.
     *
     * @private
     * @param {?} message A JavaScript object or anything that can be toString()'d,
     * like Date
     * @return {?}
     */
    function (message) {
        // Update headers
        this.setTimestamp();
        this.setTags(message.event);
        if (this.url === null) {
            /** @type {?} */
            var msg = 'Unable to send logs as URL as not been set via setURL()';
            console.error(msg);
            return throwError(msg);
        }
        // Configure request
        /** @type {?} */
        var body = { message: message };
        // We call .subscribe() here because we don't care about the response and
        // we want to ensure that we never forget to call subscribe.
        return this.post(this.url, body).subscribe();
    };
    /**
     * @protected
     * @param {?} error
     * @return {?}
     */
    CommonLogger.prototype.handleError = /**
     * @protected
     * @param {?} error
     * @return {?}
     */
    function (error) {
        console.log('logService handleError()', error);
        if (error.error instanceof ErrorEvent) {
            // Client-side / network error occured
            console.error('An error occured: ', error.error.message);
        }
        else {
            // The backend returned an unsuccessful response code
            console.error("Backend returned error code: " + error.status + ".  Error body: " + error.error);
        }
        return throwError(error);
    };
    Object.defineProperty(CommonLogger.prototype, "httpOptions", {
        /**
         * Overwrite the inherited httpOptions so we can set responseType to text.
         * This updates Angular's parsing, and it won't error out due to the server
         * not responding with JSON.
         */
        get: /**
         * Overwrite the inherited httpOptions so we can set responseType to text.
         * This updates Angular's parsing, and it won't error out due to the server
         * not responding with JSON.
         * @protected
         * @return {?}
         */
        function () {
            return {
                headers: this._headers,
                responseType: 'text'
            };
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @private
     * @return {?}
     */
    CommonLogger.prototype.setTimestamp = /**
     * @private
     * @return {?}
     */
    function () {
        this._headers = this._headers.set('timestamp', moment().toISOString());
    };
    /**
     * @private
     * @param {?} severity
     * @return {?}
     */
    CommonLogger.prototype.setSeverity = /**
     * @private
     * @param {?} severity
     * @return {?}
     */
    function (severity) {
        this._headers = this._headers.set('severity', severity);
    };
    /**
     * The headers are easier to search in splunk, and we aren't using tags, so
     * repurpose it to event type.
     */
    /**
     * The headers are easier to search in splunk, and we aren't using tags, so
     * repurpose it to event type.
     * @private
     * @param {?} message
     * @return {?}
     */
    CommonLogger.prototype.setTags = /**
     * The headers are easier to search in splunk, and we aren't using tags, so
     * repurpose it to event type.
     * @private
     * @param {?} message
     * @return {?}
     */
    function (message) {
        this._headers = this._headers.set('tags', message);
    };
    CommonLogger.decorators = [
        { type: Injectable, args: [{
                    providedIn: 'root'
                },] }
    ];
    /** @nocollapse */
    CommonLogger.ctorParameters = function () { return [
        { type: HttpClient }
    ]; };
    /** @nocollapse */ CommonLogger.ngInjectableDef = defineInjectable({ factory: function CommonLogger_Factory() { return new CommonLogger(inject(HttpClient)); }, token: CommonLogger, providedIn: "root" });
    return CommonLogger;
}(AbstractHttpService));
/** @enum {string} */
var SeverityLevels = {
    INFO: 'info',
    ERROR: 'error',
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

export { GeocoderService, AbstractHttpService, CommonLogger };

//# sourceMappingURL=moh-common-lib-services.js.map