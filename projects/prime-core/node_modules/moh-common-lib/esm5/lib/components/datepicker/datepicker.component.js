/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
import { Component, Input, Output, EventEmitter, ViewChild, forwardRef } from '@angular/core';
import { NgxMyDatePickerDirective } from 'ngx-mydatepicker';
import * as moment_ from 'moment';
import { NgForm, ControlContainer, NG_VALUE_ACCESSOR } from '@angular/forms';
/** @type {?} */
var moment = moment_;
/**
 * PRIME datepicker component. Largely a wrapper for ngx-mydatepicker
 * https://github.com/kekeh/ngx-mydatepicker
 *
 * NOTE - YOU MUST INCLUDE NGX-MYDATEPICKER IN YOUR PARENT APPLICATION TO USE
 * THIS COMPONENT!  This is due to some poor implementation in ngx-mydatepicker.
 * Make sure to use the same version that this library uses.
 */
var DatepickerComponent = /** @class */ (function () {
    function DatepickerComponent() {
        /**
         * Component size can be reduced, see Datepickersizes for options
         */
        this.size = DatepickerSizes.DEFAULT;
        this.dateChange = new EventEmitter();
        this.required = false;
        /**
         * Control visibility of the clear 'x' button on the mini datepicker.
         *
         * **'visible'** is default, button exists
         *
         * **'none'** means the element does not exist
         *
         * **'invisible'** means the element takes up space but is not visible / cannot be
         * used.
         *
         * Invisible is useful when you want to make sure a datepicker is the same
         * size as a visible one.
         */
        this.clearButton = 'visible';
        /**
         * Format for how to display the date to the user.
         */
        this.dateFormat = 'yyyy/mm/dd';
        // Make enum accessible in HTML
        this.DatepickerSizes = DatepickerSizes;
        this._onChange = (/**
         * @param {?} _
         * @return {?}
         */
        function (_) { });
        this._onTouched = (/**
         * @return {?}
         */
        function () { });
    }
    /**
     * @param {?} date
     * @return {?}
     */
    DatepickerComponent.prototype.convertDateToSimpleDate = /**
     * @param {?} date
     * @return {?}
     */
    function (date) {
        if (date === null || date === undefined) {
            return null;
        }
        return {
            year: date.getFullYear(),
            month: date.getMonth() + 1,
            day: date.getDate(),
        };
    };
    /**
     * @param {?} date
     * @return {?}
     */
    DatepickerComponent.prototype.convertSimpleDateToDate = /**
     * @param {?} date
     * @return {?}
     */
    function (date) {
        // When ngx-mydatepicker is cleared, it returns {year: 0, month: 0, day: 0}
        if (date.year === 0) {
            return null;
        }
        return new Date(date.year, date.month - 1, date.day);
    };
    /**
     * @param {?} x
     * @return {?}
     */
    DatepickerComponent.prototype.isDate = /**
     * @param {?} x
     * @return {?}
     */
    function (x) {
        if (!x) {
            return false;
        }
        return x.getDate !== undefined;
    };
    /**
     * @return {?}
     */
    DatepickerComponent.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
        if (!this.errorMessages) {
            this.errorMessages = {
                required: this.labelText + ' is required.',
                dayOutOfRange: 'Invalid ' + this.labelText + '.',
                yearDistantPast: 'Invalid ' + this.labelText + '.',
                yearDistantFuture: 'Invalid ' + this.labelText + '.',
                noFutureDatesAllowed: 'Invalid ' + this.labelText + '.',
                invalidValue: 'Invalid ' + this.labelText + '.'
            };
        }
        this.datepickerOptions = {
            dateFormat: this.dateFormat,
            sunHighlight: false,
            appendSelectorToBody: true,
        };
        if (this.size === DatepickerSizes.MINI) {
            // Set width/height to 4/5 of default
            this.datepickerOptions.selectorHeight = '185px';
            this.datepickerOptions.selectorWidth = '201px';
        }
        if (this.isDate(this.disableSince)) {
            this.datepickerOptions.disableSince = this.convertDateToSimpleDate(this.disableSince);
        }
        if (this.isDate(this.disableUntil)) {
            this.datepickerOptions.disableUntil = this.convertDateToSimpleDate(this.disableSince);
        }
        if (this.onlyFutureDates) {
            /** @type {?} */
            var today = new Date();
            this.datepickerOptions.disableUntil = this.convertDateToSimpleDate(today);
        }
        console.log('Datepicker ngOnInit', this.date);
        if (this.date) {
            // Even if jsdate winds up being undefined, even defining this.model will
            // set the input as non-empty and it'll satisfy the 'required' validation.
            // So, we only add the model if there's actual data.
            this.model = {
                jsdate: this.date
            };
        }
    };
    /**
     * @param {?} changes
     * @return {?}
     */
    DatepickerComponent.prototype.ngOnChanges = /**
     * @param {?} changes
     * @return {?}
     */
    function (changes) {
        // Parent component has passed in null, so we have to manually clear the input. This leads to 2 change detection cycles.
        // We could refactor it down to one, but the performance hit is minimal for such a simple component.
        if (this.date === null) {
            this.clearDate();
            this._onChange(null);
            this._onTouched();
        }
    };
    /**
     * @param {?} event
     * @return {?}
     */
    DatepickerComponent.prototype.onDateChanged = /**
     * @param {?} event
     * @return {?}
     */
    function (event) {
        if (event.jsdate || event.jsdate === null) {
            // Always emit a Date (or null)
            this.dateChange.emit(event.jsdate);
            this._onChange(event.jsdate);
            this._onTouched();
        }
    };
    /**
     * @return {?}
     */
    DatepickerComponent.prototype.clearDate = /**
     * @return {?}
     */
    function () {
        if (this.ngxdp) {
            // We don't need to emit here, because by changing date we'll trigger onDateChanged automatically.
            this.date = null;
            this.ngxdp.clearDate();
        }
    };
    /**
     * @param {?} fn
     * @return {?}
     */
    DatepickerComponent.prototype.registerOnChange = /**
     * @param {?} fn
     * @return {?}
     */
    function (fn) {
        this._onChange = fn;
    };
    /**
     * @param {?} fn
     * @return {?}
     */
    DatepickerComponent.prototype.registerOnTouched = /**
     * @param {?} fn
     * @return {?}
     */
    function (fn) {
        this._onTouched = fn;
    };
    /**
     * @param {?} obj
     * @return {?}
     */
    DatepickerComponent.prototype.writeValue = /**
     * @param {?} obj
     * @return {?}
     */
    function (obj) {
        this.model = {
            jsdate: obj
        };
    };
    DatepickerComponent.decorators = [
        { type: Component, args: [{
                    selector: 'common-datepicker',
                    template: "<div>\n    <label><span>{{labelText}}</span>\n        <div class=\"input-group\">\n            \n                <input class=\"form-control\" placeholder=\"YYYY/MM/DD\"\n                ngx-mydatepicker name=\"datepicker-{{labelText}}\"\n                [(ngModel)]=\"model\"\n                [options]=\"datepickerOptions\"\n                #dp=\"ngx-mydatepicker\"\n                #dateEl='ngModel'\n                (dateChanged)=\"onDateChanged($event)\"\n                [required]='required'\n                [disabled]=\"disabled\"/>\n\n            <span class=\"input-group-append float-label-append\">\n                <button type=\"button\" class=\"btn btn-default\" (click)=\"dp.toggleCalendar()\">\n                    <i class=\"fa fa-calendar\"></i>\n                </button>\n            </span>\n        </div>\n    </label>\n</div>\n\n<!-- InvalidDateFormat comes from ngxmydatepicker, so we have a little less control over it. -->\n<div *ngIf=\"!disabled && dateEl.touched\"\n    role=\"alert\"\n    class='error-container'\n    aria-live=\"assertive\">\n  <div class=\"text-danger\"\n       *ngIf=\"(dateEl?.errors?.required) && errorMessages?.required && !dateEl?.errors?.invalidDateFormat\">\n       {{errorMessages.required}}\n  </div>\n  <!-- ngx-mydatepicker has it's own errors and we can't easily add our own, so we have reduced error messages. -->\n  <!-- <div class=\"text-danger\"\n      *ngIf=\"dateEl?.errors?.dayOutOfRange && errorMessages?.dayOutOfRange\">\n       {{errorMessages.dayOutOfRange}}\n  </div>\n  <div class=\"text-danger\"\n       *ngIf=\"dateEl?.errors?.yearDistantPast && errorMessages?.yearDistantPast\">\n       {{errorMessages.yearDistantPast}}\n  </div>\n  <div class=\"text-danger\"\n       *ngIf=\"dateEl?.errors?.yearDistantFuture && errorMessages?.yearDistantFuture\">\n       {{errorMessages.yearDistantFuture}}\n  </div>\n  <div class=\"text-danger\"\n        *ngIf=\"dateEl?.errors?.noPastDatesAllowed && errorMessages?.noPastDatesAllowed\">\n        {{errorMessages.noPastDatesAllowed}}\n  </div>\n  \n  <div class=\"text-danger\"\n       *ngIf=\"dateEl?.errors?.noFutureDatesAllowed && errorMessages?.noFutureDatesAllowed\">\n       {{errorMessages.noFutureDatesAllowed}}\n  </div> -->\n  <div class=\"text-danger\"\n       *ngIf=\"(dateEl?.errors?.invalidValue || dateEl?.errors?.invalidDateFormat) && errorMessages?.invalidValue\">\n       {{errorMessages.invalidValue}}\n  </div>\n</div>",
                    /* Re-use the same ngForm that it's parent is using. The component will show
                       * up in its parents `this.form`, and will auto-update `this.form.valid`
                       */
                    viewProviders: [{ provide: ControlContainer, useExisting: forwardRef((/**
                             * @return {?}
                             */
                            function () { return NgForm; })) }],
                    providers: [
                        {
                            provide: NG_VALUE_ACCESSOR,
                            multi: true,
                            useExisting: forwardRef((/**
                             * @return {?}
                             */
                            function () { return DatepickerComponent; }))
                        }
                    ],
                    styles: [".datepicker--mini{display:flex;flex-wrap:nowrap}.datepicker--mini:not(.hide-clear)>.btn{border-top-right-radius:0;border-bottom-right-radius:0}.datepicker--mini .input-group-append .btn{padding:0 .5rem}.input-group-append{z-index:0}.float-label-append{margin-bottom:calc(.5rem + 2px)}.has-float-label{flex-basis:calc(100% - 36px)}"]
                }] }
    ];
    /** @nocollapse */
    DatepickerComponent.ctorParameters = function () { return []; };
    DatepickerComponent.propDecorators = {
        size: [{ type: Input }],
        date: [{ type: Input }],
        dateChange: [{ type: Output }],
        disabled: [{ type: Input }],
        labelText: [{ type: Input }],
        required: [{ type: Input }],
        disableUntil: [{ type: Input }],
        disableSince: [{ type: Input }],
        onlyFutureDates: [{ type: Input }],
        clearButton: [{ type: Input }],
        dateFormat: [{ type: Input }],
        errorMessages: [{ type: Input }],
        ngxdp: [{ type: ViewChild, args: ['dp',] }]
    };
    return DatepickerComponent;
}());
export { DatepickerComponent };
if (false) {
    /**
     * Component size can be reduced, see Datepickersizes for options
     * @type {?}
     */
    DatepickerComponent.prototype.size;
    /** @type {?} */
    DatepickerComponent.prototype.date;
    /** @type {?} */
    DatepickerComponent.prototype.dateChange;
    /** @type {?} */
    DatepickerComponent.prototype.disabled;
    /** @type {?} */
    DatepickerComponent.prototype.labelText;
    /** @type {?} */
    DatepickerComponent.prototype.required;
    /**
     * Dates **before** disableUntil will not be valid selections.  Maps to a ngx-mydatepicker option, but we convert IMyDate to Date
     * @type {?}
     */
    DatepickerComponent.prototype.disableUntil;
    /**
     * Dates **after** disableSince will not be valid selections.  Maps to a ngx-mydatepicker option, but we convert IMyDate to Date
     * @type {?}
     */
    DatepickerComponent.prototype.disableSince;
    /**
     * Equivalent to setting disableBefore to tomorrow.
     * @type {?}
     */
    DatepickerComponent.prototype.onlyFutureDates;
    /**
     * Control visibility of the clear 'x' button on the mini datepicker.
     *
     * **'visible'** is default, button exists
     *
     * **'none'** means the element does not exist
     *
     * **'invisible'** means the element takes up space but is not visible / cannot be
     * used.
     *
     * Invisible is useful when you want to make sure a datepicker is the same
     * size as a visible one.
     * @type {?}
     */
    DatepickerComponent.prototype.clearButton;
    /**
     * Format for how to display the date to the user.
     * @type {?}
     */
    DatepickerComponent.prototype.dateFormat;
    /** @type {?} */
    DatepickerComponent.prototype.errorMessages;
    /**
     * Datetime model used to interface with ngx-datepicker.
     * @type {?}
     */
    DatepickerComponent.prototype.model;
    /** @type {?} */
    DatepickerComponent.prototype.DatepickerSizes;
    /** @type {?} */
    DatepickerComponent.prototype.ngxdp;
    /**
     * Default options for wrapped ngx-datepicker.
     * @type {?}
     */
    DatepickerComponent.prototype.datepickerOptions;
    /** @type {?} */
    DatepickerComponent.prototype._onChange;
    /** @type {?} */
    DatepickerComponent.prototype._onTouched;
}
/** @enum {string} */
var DatepickerSizes = {
    MINI: 'mini',
    DEFAULT: 'default',
};
export { DatepickerSizes };
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZGF0ZXBpY2tlci5jb21wb25lbnQuanMiLCJzb3VyY2VSb290Ijoibmc6Ly9tb2gtY29tbW9uLWxpYi8iLCJzb3VyY2VzIjpbImxpYi9jb21wb25lbnRzL2RhdGVwaWNrZXIvZGF0ZXBpY2tlci5jb21wb25lbnQudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7OztBQUFBLE9BQU8sRUFBRSxTQUFTLEVBQVUsS0FBSyxFQUFFLE1BQU0sRUFBRSxZQUFZLEVBQWlCLFNBQVMsRUFBYSxVQUFVLEVBQUUsTUFBTSxlQUFlLENBQUM7QUFDaEksT0FBTyxFQUE0Qix3QkFBd0IsRUFBRSxNQUFNLGtCQUFrQixDQUFDO0FBQ3RGLE9BQU8sS0FBSyxPQUFPLE1BQU0sUUFBUSxDQUFDO0FBQ2xDLE9BQU8sRUFBRSxNQUFNLEVBQUUsZ0JBQWdCLEVBQWUsaUJBQWlCLEVBQXdCLE1BQU0sZ0JBQWdCLENBQUM7O0lBRTFHLE1BQU0sR0FBRyxPQUFPOzs7Ozs7Ozs7QUFXdEI7SUF5RUU7Ozs7UUF2RFMsU0FBSSxHQUFvQixlQUFlLENBQUMsT0FBTyxDQUFDO1FBRS9DLGVBQVUsR0FBRyxJQUFJLFlBQVksRUFBUSxDQUFDO1FBSXZDLGFBQVEsR0FBWSxLQUFLLENBQUM7Ozs7Ozs7Ozs7Ozs7O1FBeUIxQixnQkFBVyxHQUFxQyxTQUFTLENBQUM7Ozs7UUFLMUQsZUFBVSxHQUFXLFlBQVksQ0FBQzs7UUFTM0Msb0JBQWUsR0FBMkIsZUFBZSxDQUFDO1FBT25ELGNBQVM7Ozs7UUFBRyxVQUFDLENBQU0sSUFBTSxDQUFDLEVBQUM7UUFDM0IsZUFBVTs7O1FBQUcsY0FBTyxDQUFDLEVBQUM7SUFFYixDQUFDOzs7OztJQUVqQixxREFBdUI7Ozs7SUFBdkIsVUFBd0IsSUFBVTtRQUNoQyxJQUFJLElBQUksS0FBSyxJQUFJLElBQUksSUFBSSxLQUFLLFNBQVMsRUFBRTtZQUFFLE9BQU8sSUFBSSxDQUFDO1NBQUU7UUFDekQsT0FBTztZQUNMLElBQUksRUFBRSxJQUFJLENBQUMsV0FBVyxF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bnB1dCwgT3V0cHV0LCBFdmVudEVtaXR0ZXIsIFNpbXBsZUNoYW5nZXMsIFZpZXdDaGlsZCwgT25DaGFuZ2VzLCBmb3J3YXJkUmVmIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBJTmd4TXlEcE9wdGlvbnMsIElNeURhdGUsIE5neE15RGF0ZVBpY2tlckRpcmVjdGl2ZSB9IGZyb20gJ25neC1teWRhdGVwaWNrZXInO1xuaW1wb3J0ICogYXMgbW9tZW50XyBmcm9tICdtb21lbnQnO1xuaW1wb3J0IHsgTmdGb3JtLCBDb250cm9sQ29udGFpbmVyLCBGb3JtQ29udHJvbCwgTkdfVkFMVUVfQUNDRVNTT1IsIENvbnRyb2xWYWx1ZUFjY2Vzc29yIH0gZnJvbSAnQGFuZ3VsYXIvZm9ybXMnO1xuaW1wb3J0IHsgRGF0ZUVycm9yTXNnIH0gZnJvbSAnLi4vZGF0ZS9kYXRlLmNvbXBvbmVudCc7XG5jb25zdCBtb21lbnQgPSBtb21lbnRfO1xuXG5cbi8qKlxuICogUFJJTUUgZGF0ZXBpY2tlciBjb21wb25lbnQuIExhcmdlbHkgYSB3cmFwcGVyIGZvciBuZ3gtbXlkYXRlcGlja2VyXG4gKiBodHRwczovL2dpdGh1Yi5jb20va2VrZWgvbmd4LW15ZGF0ZXBpY2tlclxuICpcbiAqIE5PVEUgLSBZT1UgTVVTVCBJTkNMVURFIE5HWC1NWURBVEVQSUNLRVIgSU4gWU9VUiBQQVJFTlQgQVBQTElDQVRJT04gVE8gVVNFXG4gKiBUSElTIENPTVBPTkVOVCEgIFRoaXMgaXMgZHVlIHRvIHNvbWUgcG9vciBpbXBsZW1lbnRhdGlvbiBpbiBuZ3gtbXlkYXRlcGlja2VyLlxuICogTWFrZSBzdXJlIHRvIHVzZSB0aGUgc2FtZSB2ZXJzaW9uIHRoYXQgdGhpcyBsaWJyYXJ5IHVzZXMuXG4gKi9cbkBDb21wb25lbnQoe1xuICBzZWxlY3RvcjogJ2NvbW1vbi1kYXRlcGlja2VyJyxcbiAgdGVtcGxhdGVVcmw6ICcuL2RhdGVwaWNrZXIuY29tcG9uZW50Lmh0bWwnLFxuICBzdHlsZVVybHM6IFsnLi9kYXRlcGlja2VyLmNvbXBvbmVudC5zY3NzJ10sXG4gIC8qIFJlLXVzZSB0aGUgc2FtZSBuZ0Zvcm0gdGhhdCBpdCdzIHBhcmVudCBpcyB1c2luZy4gVGhlIGNvbXBvbmVudCB3aWxsIHNob3dcbiAgICogdXAgaW4gaXRzIHBhcmVudHMgYHRoaXMuZm9ybWAsIGFuZCB3aWxsIGF1dG8tdXBkYXRlIGB0aGlzLmZvcm0udmFsaWRgXG4gICAqL1xuICB2aWV3UHJvdmlkZXJzOiBbIHsgcHJvdmlkZTogQ29udHJvbENvbnRhaW5lciwgdXNlRXhpc3Rpbmc6IGZvcndhcmRSZWYoKCkgPT4gTmdGb3JtICkgfSBdLFxuICBwcm92aWRlcnM6IFtcbiAgICB7XG4gICAgICBwcm92aWRlOiBOR19WQUxVRV9BQ0NFU1NPUixcbiAgICAgIG11bHRpOiB0cnVlLFxuICAgICAgdXNlRXhpc3Rpbmc6IGZvcndhcmRSZWYoKCkgPT4gRGF0ZXBpY2tlckNvbXBvbmVudClcbiAgICB9XG4gIF1cbn0pXG5leHBvcnQgY2xhc3MgRGF0ZXBpY2tlckNvbXBvbmVudCBpbXBsZW1lbnRzIE9uSW5pdCwgT25DaGFuZ2VzLCBDb250cm9sVmFsdWVBY2Nlc3NvciB7XG4gIC8qKiBDb21wb25lbnQgc2l6ZSBjYW4gYmUgcmVkdWNlZCwgc2VlIERhdGVwaWNrZXJzaXplcyBmb3Igb3B0aW9ucyAqL1xuICBASW5wdXQoKSBzaXplOiBEYXRlcGlja2VyU2l6ZXMgPSBEYXRlcGlja2VyU2l6ZXMuREVGQVVMVDtcbiAgQElucHV0KCkgZGF0ZTogRGF0ZTtcbiAgQE91dHB1dCgpIGRhdGVDaGFuZ2UgPSBuZXcgRXZlbnRFbWl0dGVyPERhdGU+KCk7XG4gIEBJbnB1dCgpIGRpc2FibGVkOiBib29sZWFuO1xuICBASW5wdXQoKSBsYWJlbFRleHQ6IHN0cmluZztcblxuICBASW5wdXQoKSByZXF1aXJlZDogYm9vbGVhbiA9IGZhbHNlO1xuXG5cbiAgLyoqIERhdGVzICoqYmVmb3JlKiogZGlzYWJsZVVudGlsIHdpbGwgbm90IGJlIHZhbGlkIHNlbGVjdGlvbnMuICBNYXBzIHRvIGEgbmd4LW15ZGF0ZXBpY2tlciBvcHRpb24sIGJ1dCB3ZSBjb252ZXJ0IElNeURhdGUgdG8gRGF0ZSAgKi9cbiAgQElucHV0KCkgZGlzYWJsZVVudGlsOiBEYXRlO1xuXG4gIC8qKiBEYXRlcyAqKmFmdGVyKiogZGlzYWJsZVNpbmNlIHdpbGwgbm90IGJlIHZhbGlkIHNlbGVjdGlvbnMuICBNYXBzIHRvIGEgbmd4LW15ZGF0ZXBpY2tlciBvcHRpb24sIGJ1dCB3ZSBjb252ZXJ0IElNeURhdGUgdG8gRGF0ZSAqL1xuICBASW5wdXQoKSBkaXNhYmxlU2luY2U6IERhdGU7XG5cbiAgLyoqIEVxdWl2YWxlbnQgdG8gc2V0dGluZyBkaXNhYmxlQmVmb3JlIHRvIHRvbW9ycm93LiAqL1xuICBASW5wdXQoKSBvbmx5RnV0dXJlRGF0ZXM6IGJvb2xlYW47XG5cbiAgLyoqXG4gICAqIENvbnRyb2wgdmlzaWJpbGl0eSBvZiB0aGUgY2xlYXIgJ3gnIGJ1dHRvbiBvbiB0aGUgbWluaSBkYXRlcGlja2VyLlxuICAgKlxuICAgKiAqKid2aXNpYmxlJyoqIGlzIGRlZmF1bHQsIGJ1dHRvbiBleGlzdHNcbiAgICpcbiAgICogKionbm9uZScqKiBtZWFucyB0aGUgZWxlbWVudCBkb2VzIG5vdCBleGlzdFxuICAgKlxuICAgKiAqKidpbnZpc2libGUnKiogbWVhbnMgdGhlIGVsZW1lbnQgdGFrZXMgdXAgc3BhY2UgYnV0IGlzIG5vdCB2aXNpYmxlIC8gY2Fubm90IGJlXG4gICAqIHVzZWQuXG4gICAqXG4gICAqIEludmlzaWJsZSBpcyB1c2VmdWwgd2hlbiB5b3Ugd2FudCB0byBtYWtlIHN1cmUgYSBkYXRlcGlja2VyIGlzIHRoZSBzYW1lXG4gICAqIHNpemUgYXMgYSB2aXNpYmxlIG9uZS5cbiAgICovXG4gIEBJbnB1dCgpIGNsZWFyQnV0dG9uOiAndmlzaWJsZScgfCAnaW52aXNpYmxlJyB8ICdub25lJyA9ICd2aXNpYmxlJztcblxuXG5cbiAgLyoqIEZvcm1hdCBmb3IgaG93IHRvIGRpc3BsYXkgdGhlIGRhdGUgdG8gdGhlIHVzZXIuICovXG4gIEBJbnB1dCgpIGRhdGVGb3JtYXQ6IHN0cmluZyA9ICd5eXl5L21tL2RkJztcblxuICBASW5wdXQoKSBlcnJvck1lc3NhZ2VzOiBEYXRlRXJyb3JNc2c7XG5cbiAgLyoqIERhdGV0aW1lIG1vZGVsIHVzZWQgdG8gaW50ZXJmYWNlIHdpdGggbmd4LWRhdGVwaWNrZXIuICovXG4gIC8vIG1vZGVsOiBhbnk7XG4gIG1vZGVsOiBhbnk7XG5cbiAgLy8gTWFrZSBlbnVtIGFjY2Vzc2libGUgaW4gSFRNTFxuICBEYXRlcGlja2VyU2l6ZXM6IHR5cGVvZiBEYXRlcGlja2VyU2l6ZXMgPSBEYXRlcGlja2VyU2l6ZXM7XG5cbiAgQFZpZXdDaGlsZCgnZHAnKSBuZ3hkcDogTmd4TXlEYXRlUGlja2VyRGlyZWN0aXZlO1xuXG4gIC8qKiBEZWZhdWx0IG9wdGlvbnMgZm9yIHdyYXBwZWQgbmd4LWRhdGVwaWNrZXIuICovXG4gIGRhdGVwaWNrZXJPcHRpb25zOiBJTmd4TXlEcE9wdGlvbnM7XG5cbiAgcHVibGljIF9vbkNoYW5nZSA9IChfOiBhbnkpID0+IHt9O1xuICBwdWJsaWMgX29uVG91Y2hlZCA9ICgpID0+IHt9O1xuXG4gIGNvbnN0cnVjdG9yKCkgeyB9XG5cbiAgY29udmVydERhdGVUb1NpbXBsZURhdGUoZGF0ZTogRGF0ZSk6IElNeURhdGUge1xuICAgIGlmIChkYXRlID09PSBudWxsIHx8IGRhdGUgPT09IHVuZGVmaW5lZCkgeyByZXR1cm4gbnVsbDsgfVxuICAgIHJldHVybiB7XG4gICAgICB5ZWFyOiBkYXRlLmdldEZ1bGxZZWFyKCksXG4gICAgICBtb250aDogZGF0ZS5nZXRNb250aCgpICsgMSxcbiAgICAgIGRheTogZGF0ZS5nZXREYXRlKCksXG4gICAgfTtcbiAgfVxuICBjb252ZXJ0U2ltcGxlRGF0ZVRvRGF0ZShkYXRlOiBJTXlEYXRlKTogRGF0ZSB7XG4gICAgLy8gV2hlbiBuZ3gtbXlkYXRlcGlja2VyIGlzIGNsZWFyZWQsIGl0IHJldHVybnMge3llYXI6IDAsIG1vbnRoOiAwLCBkYXk6IDB9XG4gICAgaWYgKGRhdGUueWVhciA9PT0gMCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiBuZXcgRGF0ZShkYXRlLnllYXIsIGRhdGUubW9udGggLSAxLCBkYXRlLmRheSk7XG4gIH1cblxuICBpc0RhdGUoeDogYW55KTogeCBpcyBEYXRlIHtcbiAgICBpZiAoIXgpIHsgcmV0dXJuIGZhbHNlOyB9XG4gICAgcmV0dXJuIHguZ2V0RGF0ZSAhPT0gdW5kZWZpbmVkO1xuICB9XG5cbiAgbmdPbkluaXQoKSB7XG4gICAgaWYgKCF0aGlzLmVycm9yTWVzc2FnZXMpIHtcbiAgICAgIHRoaXMuZXJyb3JNZXNzYWdlcyA9IHtcbiAgICAgICAgcmVxdWlyZWQ6IHRoaXMubGFiZWxUZXh0ICsgJyBpcyByZXF1aXJlZC4nLFxuICAgICAgICBkYXlPdXRPZlJhbmdlOiAnSW52YWxpZCAnICsgdGhpcy5sYWJlbFRleHQgKyAnLicsXG4gICAgICAgIHllYXJEaXN0YW50UGFzdDogJ0ludmFsaWQgJyArIHRoaXMubGFiZWxUZXh0ICsgJy4nLFxuICAgICAgICB5ZWFyRGlzdGFudEZ1dHVyZTogJ0ludmFsaWQgJyArIHRoaXMubGFiZWxUZXh0ICsgJy4nLFxuICAgICAgICBub0Z1dHVyZURhdGVzQWxsb3dlZDogJ0ludmFsaWQgJyArIHRoaXMubGFiZWxUZXh0ICsgJy4nLFxuICAgICAgICBpbnZhbGlkVmFsdWU6ICdJbnZhbGlkICcgKyB0aGlzLmxhYmVsVGV4dCArICcuJ1xuICAgICAgfTtcbiAgICB9XG5cbiAgICB0aGlzLmRhdGVwaWNrZXJPcHRpb25zID0ge1xuICAgICAgZGF0ZUZvcm1hdDogdGhpcy5kYXRlRm9ybWF0LFxuICAgICAgc3VuSGlnaGxpZ2h0OiBmYWxzZSxcbiAgICAgIGFwcGVuZFNlbGVjdG9yVG9Cb2R5OiB0cnVlLFxuICAgIH07XG5cbiAgICBpZiAodGhpcy5zaXplID09PSBEYXRlcGlja2VyU2l6ZXMuTUlOSSkge1xuICAgICAgLy8gU2V0IHdpZHRoL2hlaWdodCB0byA0LzUgb2YgZGVmYXVsdFxuICAgICAgdGhpcy5kYXRlcGlja2VyT3B0aW9ucy5zZWxlY3RvckhlaWdodCA9ICcxODVweCc7XG4gICAgICB0aGlzLmRhdGVwaWNrZXJPcHRpb25zLnNlbGVjdG9yV2lkdGggPSAnMjAxcHgnO1xuICAgIH1cblxuICAgIGlmICh0aGlzLmlzRGF0ZSh0aGlzLmRpc2FibGVTaW5jZSkpIHtcbiAgICAgIHRoaXMuZGF0ZXBpY2tlck9wdGlvbnMuZGlzYWJsZVNpbmNlID0gdGhpcy5jb252ZXJ0RGF0ZVRvU2ltcGxlRGF0ZSh0aGlzLmRpc2FibGVTaW5jZSk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuaXNEYXRlKHRoaXMuZGlzYWJsZVVudGlsKSkge1xuICAgICAgdGhpcy5kYXRlcGlja2VyT3B0aW9ucy5kaXNhYmxlVW50aWwgPSB0aGlzLmNvbnZlcnREYXRlVG9TaW1wbGVEYXRlKHRoaXMuZGlzYWJsZVNpbmNlKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5vbmx5RnV0dXJlRGF0ZXMpIHtcbiAgICAgIGNvbnN0IHRvZGF5ID0gbmV3IERhdGUoKTtcbiAgICAgIHRoaXMuZGF0ZXBpY2tlck9wdGlvbnMuZGlzYWJsZVVudGlsID0gdGhpcy5jb252ZXJ0RGF0ZVRvU2ltcGxlRGF0ZSh0b2RheSk7XG4gICAgfVxuXG4gICAgY29uc29sZS5sb2coJ0RhdGVwaWNrZXIgbmdPbkluaXQnLCB0aGlzLmRhdGUpO1xuXG5cbiAgICBpZiAodGhpcy5kYXRlKSB7XG4gICAgICAvLyBFdmVuIGlmIGpzZGF0ZSB3aW5kcyB1cCBiZWluZyB1bmRlZmluZWQsIGV2ZW4gZGVmaW5pbmcgdGhpcy5tb2RlbCB3aWxsXG4gICAgICAvLyBzZXQgdGhlIGlucHV0IGFzIG5vbi1lbXB0eSBhbmQgaXQnbGwgc2F0aXNmeSB0aGUgJ3JlcXVpcmVkJyB2YWxpZGF0aW9uLlxuICAgICAgLy8gU28sIHdlIG9ubHkgYWRkIHRoZSBtb2RlbCBpZiB0aGVyZSdzIGFjdHVhbCBkYXRhLlxuICAgICAgdGhpcy5tb2RlbCA9IHtcbiAgICAgICAganNkYXRlOiB0aGlzLmRhdGVcbiAgICAgIH07XG4gICAgfVxuXG5cbiAgfVxuXG5cbiAgbmdPbkNoYW5nZXMoY2hhbmdlczogU2ltcGxlQ2hhbmdlcykge1xuICAgIC8vIFBhcmVudCBjb21wb25lbnQgaGFzIHBhc3NlZCBpbiBudWxsLCBzbyB3ZSBoYXZlIHRvIG1hbnVhbGx5IGNsZWFyIHRoZSBpbnB1dC4gVGhpcyBsZWFkcyB0byAyIGNoYW5nZSBkZXRlY3Rpb24gY3ljbGVzLlxuICAgIC8vIFdlIGNvdWxkIHJlZmFjdG9yIGl0IGRvd24gdG8gb25lLCBidXQgdGhlIHBlcmZvcm1hbmNlIGhpdCBpcyBtaW5pbWFsIGZvciBzdWNoIGEgc2ltcGxlIGNvbXBvbmVudC5cbiAgICBpZiAodGhpcy5kYXRlID09PSBudWxsKSB7XG4gICAgICB0aGlzLmNsZWFyRGF0ZSgpO1xuICAgICAgdGhpcy5fb25DaGFuZ2UobnVsbCk7XG4gICAgICB0aGlzLl9vblRvdWNoZWQoKTtcbiAgICB9XG4gIH1cblxuICBvbkRhdGVDaGFuZ2VkKGV2ZW50KTogdm9pZCB7XG4gICAgaWYgKGV2ZW50LmpzZGF0ZSB8fCBldmVudC5qc2RhdGUgPT09IG51bGwpIHtcbiAgICAgIC8vIEFsd2F5cyBlbWl0IGEgRGF0ZSAob3IgbnVsbClcbiAgICAgIHRoaXMuZGF0ZUNoYW5nZS5lbWl0KGV2ZW50LmpzZGF0ZSk7XG4gICAgICB0aGlzLl9vbkNoYW5nZShldmVudC5qc2RhdGUpO1xuICAgICAgdGhpcy5fb25Ub3VjaGVkKCk7XG4gICAgfVxuICB9XG5cbiAgY2xlYXJEYXRlKCkge1xuICAgIGlmICh0aGlzLm5neGRwKSB7XG4gICAgICAvLyBXZSBkb24ndCBuZWVkIHRvIGVtaXQgaGVyZSwgYmVjYXVzZSBieSBjaGFuZ2luZyBkYXRlIHdlJ2xsIHRyaWdnZXIgb25EYXRlQ2hhbmdlZCBhdXRvbWF0aWNhbGx5LlxuICAgICAgdGhpcy5kYXRlID0gbnVsbDtcbiAgICAgIHRoaXMubmd4ZHAuY2xlYXJEYXRlKCk7XG4gICAgfVxuICB9XG5cbiAgcmVnaXN0ZXJPbkNoYW5nZShmbjogYW55KTogdm9pZCB7XG4gICAgdGhpcy5fb25DaGFuZ2UgPSBmbjtcbiAgfVxuXG4gIHJlZ2lzdGVyT25Ub3VjaGVkKGZuOiBhbnkpOiB2b2lkIHtcbiAgICB0aGlzLl9vblRvdWNoZWQgPSBmbjtcbiAgfVxuXG4gIHdyaXRlVmFsdWUob2JqOiBhbnkpOiB2b2lkIHtcbiAgICB0aGlzLm1vZGVsID0ge1xuICAgICAganNkYXRlOiBvYmpcbiAgICB9O1xuICB9XG5cbn1cblxuZXhwb3J0IGVudW0gRGF0ZXBpY2tlclNpemVzIHtcbiAgTUlOSSA9ICdtaW5pJyxcbiAgREVGQVVMVCA9ICdkZWZhdWx0J1xufVxuIl19