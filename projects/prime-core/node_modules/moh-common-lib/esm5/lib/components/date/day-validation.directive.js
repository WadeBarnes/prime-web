/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
import { Directive, forwardRef } from '@angular/core';
import { NG_VALIDATORS } from '@angular/forms';
import * as moment_ from 'moment';
/** @type {?} */
var moment = moment_;
var DayValidationDirective = /** @class */ (function () {
    function DayValidationDirective() {
    }
    /**
     * @param {?} control
     * @return {?}
     */
    DayValidationDirective.prototype.validate = /**
     * @param {?} control
     * @return {?}
     */
    function (control) {
        /** @type {?} */
        var date = control.parent.value;
        if (!control.value) {
            return null; // empty value
        }
        /** @type {?} */
        var day = parseInt(control.value, 10);
        // console.log( 'day: ', day );
        if (!isNaN(day)) {
            // console.log( 'parent: ', date );
            // Only process of value is numeric
            if (!isNaN(date.month) && !isNaN(date.year)) {
                // Determine days in month
                /** @type {?} */
                var str = date.year + "-" + date.month;
                /** @type {?} */
                var daysInMonth = moment(str, 'YYYY-MM').daysInMonth();
                // console.log( 'str: ', str + ', dayInMonth: ', daysInMonth );
                if (isNaN(daysInMonth)) {
                    daysInMonth = 31;
                }
                // Validate days
                if (day > daysInMonth || day < 1) {
                    return { 'dayOutOfRange': true };
                }
            }
            return null;
        }
        return { 'invalidValue': true };
    };
    DayValidationDirective.decorators = [
        { type: Directive, args: [{
                    selector: '[commonDayValidation]',
                    providers: [
                        { provide: NG_VALIDATORS, useExisting: forwardRef((/**
                             * @return {?}
                             */
                            function () { return DayValidationDirective; })), multi: true }
                    ]
                },] }
    ];
    return DayValidationDirective;
}());
export { DayValidationDirective };
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZGF5LXZhbGlkYXRpb24uZGlyZWN0aXZlLmpzIiwic291cmNlUm9vdCI6Im5nOi8vbW9oLWNvbW1vbi1saWIvIiwic291cmNlcyI6WyJsaWIvY29tcG9uZW50cy9kYXRlL2RheS12YWxpZGF0aW9uLmRpcmVjdGl2ZS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7O0FBQUEsT0FBTyxFQUFFLFNBQVMsRUFBRSxVQUFVLEVBQUUsTUFBTSxlQUFlLENBQUM7QUFDdEQsT0FBTyxFQUFFLGFBQWEsRUFBMEIsTUFBTSxnQkFBZ0IsQ0FBQztBQUN2RSxPQUFPLEtBQUssT0FBTyxNQUFNLFFBQVEsQ0FBQzs7SUFDNUIsTUFBTSxHQUFHLE9BQU87QUFFdEI7SUFBQTtJQTZDQSxDQUFDOzs7OztJQXJDQyx5Q0FBUTs7OztJQUFSLFVBQVUsT0FBb0I7O1lBQ3RCLElBQUksR0FBRyxPQUFPLENBQUMsTUFBTSxDQUFDLEtBQUs7UUFFakMsSUFBSyxDQUFDLE9BQU8sQ0FBQyxLQUFLLEVBQUc7WUFDcEIsT0FBTyxJQUFJLENBQUMsQ0FBQyxjQUFjO1NBQzVCOztZQUVLLEdBQUcsR0FBVyxRQUFRLENBQUUsT0FBTyxDQUFDLEtBQUssRUFBRSxFQUFFLENBQUU7UUFDakQsK0JBQStCO1FBRS9CLElBQUssQ0FBQyxLQUFLLENBQUUsR0FBRyxDQUFFLEVBQUc7WUFFbkIsbUNBQW1DO1lBQ25DLG1DQUFtQztZQUNuQyxJQUFLLENBQUMsS0FBSyxDQUFFLElBQUksQ0FBQyxLQUFLLENBQUUsSUFBSyxDQUFDLEtBQUssQ0FBRSxJQUFJLENBQUMsSUFBSSxDQUFFLEVBQUc7OztvQkFHNUMsR0FBRyxHQUFNLElBQUksQ0FBQyxJQUFJLFNBQUksSUFBSSxDQUFDLEtBQU87O29CQUNwQyxXQUFXLEdBQVcsTUFBTSxDQUFDLEdBQUcsRUFBRSxTQUFTLENBQUMsQ0FBQyxXQUFXLEVBQUU7Z0JBQzlELCtEQUErRDtnQkFFL0QsSUFBSyxLQUFLLENBQUUsV0FBVyxDQUFFLEVBQUc7b0JBQzFCLFdBQVcsR0FBRyxFQUFFLENBQUM7aUJBQ2xCO2dCQUVELGdCQUFnQjtnQkFDaEIsSUFBSyxHQUFHLEdBQUcsV0FBVyxJQUFJLEdBQUcsR0FBRyxDQUFDLEVBQUc7b0JBQ2xDLE9BQU8sRUFBRSxlQUFlLEVBQUUsSUFBSSxFQUFFLENBQUM7aUJBQ2xDO2FBQ0Y7WUFFRCxPQUFPLElBQUksQ0FBQztTQUNiO1FBRUQsT0FBTyxFQUFFLGNBQWMsRUFBRSxJQUFJLEVBQUUsQ0FBQztJQUNsQyxDQUFDOztnQkEzQ0YsU0FBUyxTQUFDO29CQUNULFFBQVEsRUFBRSx1QkFBdUI7b0JBQ2pDLFNBQVMsRUFBRTt3QkFDVCxFQUFDLE9BQU8sRUFBRSxhQUFhLEVBQUUsV0FBVyxFQUFFLFVBQVU7Ozs0QkFBQyxjQUFNLE9BQUEsc0JBQXNCLEVBQXRCLENBQXNCLEVBQUMsRUFBRSxLQUFLLEVBQUUsSUFBSSxFQUFDO3FCQUM3RjtpQkFDRjs7SUF3Q0QsNkJBQUM7Q0FBQSxBQTdDRCxJQTZDQztTQXZDWSxzQkFBc0IiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBEaXJlY3RpdmUsIGZvcndhcmRSZWYgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IE5HX1ZBTElEQVRPUlMsIFZhbGlkYXRvciwgRm9ybUNvbnRyb2wgfSBmcm9tICdAYW5ndWxhci9mb3Jtcyc7XG5pbXBvcnQgKiBhcyBtb21lbnRfIGZyb20gJ21vbWVudCc7XG5jb25zdCBtb21lbnQgPSBtb21lbnRfO1xuXG5ARGlyZWN0aXZlKHtcbiAgc2VsZWN0b3I6ICdbY29tbW9uRGF5VmFsaWRhdGlvbl0nLFxuICBwcm92aWRlcnM6IFtcbiAgICB7cHJvdmlkZTogTkdfVkFMSURBVE9SUywgdXNlRXhpc3Rpbmc6IGZvcndhcmRSZWYoKCkgPT4gRGF5VmFsaWRhdGlvbkRpcmVjdGl2ZSksIG11bHRpOiB0cnVlfVxuICBdXG59KVxuZXhwb3J0IGNsYXNzIERheVZhbGlkYXRpb25EaXJlY3RpdmUgaW1wbGVtZW50cyBWYWxpZGF0b3Ige1xuXG4gIHZhbGlkYXRlKCBjb250cm9sOiBGb3JtQ29udHJvbCApOiB7W2tleTogc3RyaW5nXTogYW55fSB8IG51bGwge1xuICAgIGNvbnN0IGRhdGUgPSBjb250cm9sLnBhcmVudC52YWx1ZTtcblxuICAgIGlmICggIWNvbnRyb2wudmFsdWUgKSB7XG4gICAgICByZXR1cm4gbnVsbDsgLy8gZW1wdHkgdmFsdWVcbiAgICB9XG5cbiAgICBjb25zdCBkYXk6IG51bWJlciA9IHBhcnNlSW50KCBjb250cm9sLnZhbHVlLCAxMCApO1xuICAgIC8vIGNvbnNvbGUubG9nKCAnZGF5OiAnLCBkYXkgKTtcblxuICAgIGlmICggIWlzTmFOKCBkYXkgKSApIHtcblxuICAgICAgLy8gY29uc29sZS5sb2coICdwYXJlbnQ6ICcsIGRhdGUgKTtcbiAgICAgIC8vIE9ubHkgcHJvY2VzcyBvZiB2YWx1ZSBpcyBudW1lcmljXG4gICAgICBpZiAoICFpc05hTiggZGF0ZS5tb250aCApICAmJiAhaXNOYU4oIGRhdGUueWVhciApICkge1xuXG4gICAgICAgIC8vIERldGVybWluZSBkYXlzIGluIG1vbnRoXG4gICAgICAgIGNvbnN0IHN0ciA9IGAke2RhdGUueWVhcn0tJHtkYXRlLm1vbnRofWA7XG4gICAgICAgIGxldCBkYXlzSW5Nb250aDogbnVtYmVyID0gbW9tZW50KHN0ciwgJ1lZWVktTU0nKS5kYXlzSW5Nb250aCgpO1xuICAgICAgICAvLyBjb25zb2xlLmxvZyggJ3N0cjogJywgc3RyICsgJywgZGF5SW5Nb250aDogJywgZGF5c0luTW9udGggKTtcblxuICAgICAgICBpZiAoIGlzTmFOKCBkYXlzSW5Nb250aCApICkge1xuICAgICAgICAgIGRheXNJbk1vbnRoID0gMzE7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBWYWxpZGF0ZSBkYXlzXG4gICAgICAgIGlmICggZGF5ID4gZGF5c0luTW9udGggfHwgZGF5IDwgMSApIHtcbiAgICAgICAgICByZXR1cm4geyAnZGF5T3V0T2ZSYW5nZSc6IHRydWUgfTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICByZXR1cm4geyAnaW52YWxpZFZhbHVlJzogdHJ1ZSB9O1xuICB9XG5cbn1cbiJdfQ==