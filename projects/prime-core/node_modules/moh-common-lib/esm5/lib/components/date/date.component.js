/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
import * as tslib_1 from "tslib";
import { Component, Input, Output, EventEmitter, ViewChild, ChangeDetectorRef, forwardRef } from '@angular/core';
import { Base } from '../../../models/src/base';
import { ControlContainer, NgForm, NgModel } from '@angular/forms';
import * as moment_ from 'moment';
/** @type {?} */
var moment = moment_;
/**
 * Component NPM package dependencies:
 * a) moment
 * @record
 */
export function DateErrorMsg() { }
if (false) {
    /** @type {?} */
    DateErrorMsg.prototype.required;
    /** @type {?|undefined} */
    DateErrorMsg.prototype.dayOutOfRange;
    /** @type {?|undefined} */
    DateErrorMsg.prototype.yearDistantPast;
    /** @type {?|undefined} */
    DateErrorMsg.prototype.yearDistantFuture;
    /** @type {?|undefined} */
    DateErrorMsg.prototype.noPastDatesAllowed;
    /** @type {?|undefined} */
    DateErrorMsg.prototype.noFutureDatesAllowed;
    /** @type {?|undefined} */
    DateErrorMsg.prototype.invalidValue;
}
var DateComponent = /** @class */ (function (_super) {
    tslib_1.__extends(DateComponent, _super);
    function DateComponent(form, cd) {
        var _this = _super.call(this) || this;
        _this.form = form;
        _this.cd = cd;
        _this.useCurrentDate = false;
        _this.required = true;
        _this.disabled = false;
        _this.label = 'Date';
        /**
         * Can be one of: "future", "past". "future" includes today, "past" does not.
         */
        _this.restrictDate = 'any';
        _this.dateChange = new EventEmitter();
        _this.monthList = [
            'January', 'February', 'March', 'April', 'May', 'June',
            'July', 'August', 'September', 'October', 'November', 'December'
        ];
        return _this;
    }
    /**
     * @return {?}
     */
    DateComponent.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
        if (!this.errorMessages) {
            // Use default messages
            this.errorMessages = {
                required: this.label + ' is required.',
                dayOutOfRange: 'Invalid ' + this.label + '.',
                yearDistantPast: 'Invalid ' + this.label + '.',
                yearDistantFuture: 'Invalid ' + this.label + '.',
                noFutureDatesAllowed: 'Invalid ' + this.label + '.',
                invalidValue: 'Invalid ' + this.label + '.'
            };
        }
        if (this.useCurrentDate) {
            // Set date to current date
            this.date.month = moment().month();
            this.date.day = moment().date();
            this.date.year = moment().year();
        }
    };
    /** Set the month and notify caller of change */
    /**
     * Set the month and notify caller of change
     * @param {?} value
     * @return {?}
     */
    DateComponent.prototype.setMonth = /**
     * Set the month and notify caller of change
     * @param {?} value
     * @return {?}
     */
    function (value) {
        /** @type {?} */
        var month = this.getNumericValue(value);
        // console.log( 'monthRef: ', this.monthRef );
        if (this.date) {
            this.date.month = month;
            this.triggerDayValidation();
            this.dateChange.emit(this.date);
        }
    };
    /** Set the day and notify caller of change */
    /**
     * Set the day and notify caller of change
     * @param {?} value
     * @return {?}
     */
    DateComponent.prototype.setDay = /**
     * Set the day and notify caller of change
     * @param {?} value
     * @return {?}
     */
    function (value) {
        /** @type {?} */
        var day = this.getNumericValue(value);
        // console.log(  'dayRef: ', this.dayRef );
        if (this.date) {
            this.date.day = day;
            this.dateChange.emit(this.date);
        }
    };
    /** Set the yera and notify caller of change */
    /**
     * Set the yera and notify caller of change
     * @param {?} value
     * @return {?}
     */
    DateComponent.prototype.setYear = /**
     * Set the yera and notify caller of change
     * @param {?} value
     * @return {?}
     */
    function (value) {
        /** @type {?} */
        var year = this.getNumericValue(value);
        // console.log( 'yearRef: ', this.yearRef );
        if (this.date) {
            this.date.year = year;
            this.triggerDayValidation();
            this.dateChange.emit(this.date);
        }
    };
    /**
     * Force the `day` input to run it's directives again. Important in cases
     * where user fills fields out of order, e.g. sets days to 31 then month to
     * Februrary.
     */
    /**
     * Force the `day` input to run it's directives again. Important in cases
     * where user fills fields out of order, e.g. sets days to 31 then month to
     * Februrary.
     * @private
     * @return {?}
     */
    DateComponent.prototype.triggerDayValidation = /**
     * Force the `day` input to run it's directives again. Important in cases
     * where user fills fields out of order, e.g. sets days to 31 then month to
     * Februrary.
     * @private
     * @return {?}
     */
    function () {
        var _this = this;
        // We have to wrap this in a timeout, otherwise it runs before Angular has updated the values
        setTimeout((/**
         * @return {?}
         */
        function () {
            if (_this.form.controls['day']) {
                // console.log( 'Trigger day validation' );
                _this.form.controls['day'].updateValueAndValidity();
                _this.cd.detectChanges();
            }
        }), 0);
    };
    /** Convert string to numeric value or null if not */
    /**
     * Convert string to numeric value or null if not
     * @private
     * @param {?} value
     * @return {?}
     */
    DateComponent.prototype.getNumericValue = /**
     * Convert string to numeric value or null if not
     * @private
     * @param {?} value
     * @return {?}
     */
    function (value) {
        /** @type {?} */
        var parsed = parseInt(value, 10);
        return (isNaN(parsed) ? null : parsed);
    };
    DateComponent.decorators = [
        { type: Component, args: [{
                    selector: 'common-date',
                    template: "<fieldset>\n  <legend class=\"date--legend\">{{label}}</legend>\n  <div class=\"form-group date-row\">\n\n    <label class=\"visuallyhidden\" for=\"month{{objectId}}\">Month</label>\n    <select class=\"form-control monthSelect\"\n            id=\"month{{objectId}}\"\n            name=\"month\"\n            [ngModel]=\"date?.month\"\n            (ngModelChange)=\"setMonth($event)\"\n            [disabled]='disabled'\n            #monthRef=\"ngModel\"\n            [required]=\"required\">\n      <!-- We show the blank option so the user can clear out their data.-->\n      <option value=\"null\" label=\"-- month --\" selected [disabled]='required'></option>\n      <option *ngFor=\"let month of monthList; let i = index;\" [value]=\"i + 1\">{{month}}</option>\n    </select>\n\n    <label class=\"visuallyhidden\" for=\"day{{objectId}}\">Day</label>\n    <input type=\"number\"\n           class=\"form-control dayInput\"\n           id=\"day{{objectId}}\"\n           name=\"day\"\n           placeholder=\"day\"\n           [ngModel]=\"date?.day\"\n           (ngModelChange)=\"setDay($event)\"\n           #dayRef=\"ngModel\"\n           [required]=\"required\"\n           commonDateFieldFormat\n           commonDayValidation\n           [disabled]='disabled'\n           maxlength=\"2\" />\n\n    <label class=\"visuallyhidden\" for=\"year{{objectId}}\">Year</label>\n    <input type=\"number\"\n           class=\"form-control yearInput\"\n           id=\"year{{objectId}}\"\n           name=\"year\"\n           placeholder=\"year\"\n           [ngModel]=\"date?.year\"\n           (ngModelChange)=\"setYear($event)\"\n           #yearRef=\"ngModel\"\n           [required]=\"required\"\n           commonDateFieldFormat\n           [commonYearValidate]=\"restrictDate\"\n           [disabled]='disabled'\n           maxlength=\"4\" />\n\n  </div>\n\n</fieldset>\n\n<!-- Error messages for component -->\n<div *ngIf=\"!disabled && (monthRef.touched || monthRef.dirty) && (dayRef.touched || dayRef.dirty) && (yearRef.touched || yearRef.dirty)\"\n    role=\"alert\"\n    class='error-container'\n    aria-live=\"assertive\">\n  <div class=\"text-danger\"\n       *ngIf=\"(monthRef?.errors?.required || dayRef?.errors?.required || yearRef?.errors?.required ) && errorMessages?.required\">\n       {{errorMessages.required}}\n  </div>\n  <div class=\"text-danger\"\n      *ngIf=\"dayRef?.errors?.dayOutOfRange && errorMessages?.dayOutOfRange\">\n       {{errorMessages.dayOutOfRange}}\n  </div>\n  <div class=\"text-danger\"\n       *ngIf=\"yearRef?.errors?.yearDistantPast && errorMessages?.yearDistantPast\">\n       {{errorMessages.yearDistantPast}}\n  </div>\n  <div class=\"text-danger\"\n       *ngIf=\"yearRef?.errors?.yearDistantFuture && errorMessages?.yearDistantFuture\">\n       {{errorMessages.yearDistantFuture}}\n  </div>\n  <div class=\"text-danger\"\n        *ngIf=\"yearRef?.errors?.noPastDatesAllowed && errorMessages?.noPastDatesAllowed\">\n        {{errorMessages.noPastDatesAllowed}}\n  </div>\n  <div class=\"text-danger\"\n       *ngIf=\"yearRef?.errors?.noFutureDatesAllowed && errorMessages?.noFutureDatesAllowed\">\n       {{errorMessages.noFutureDatesAllowed}}\n  </div>\n  <!-- Case should not happen until something is not formatted correctly-->\n  <div class=\"text-danger\"\n       *ngIf=\"(dayRef?.errors?.invalidValue || yearRef?.errors?.invalidValue) && errorMessages?.invalidValue\">\n       {{errorMessages.invalidValue}}\n  </div>\n</div>\n\n\n",
                    /* Re-use the same ngForm that it's parent is using. The component will show
                       * up in its parents `this.form`, and will auto-update `this.form.valid`
                       */
                    viewProviders: [{ provide: ControlContainer, useExisting: forwardRef((/**
                             * @return {?}
                             */
                            function () { return NgForm; })) }],
                    styles: [".date--legend{font-size:inherit;font-weight:700}.date-row{display:flex;flex-wrap:nowrap;justify-content:space-between}.monthSelect{max-width:50%;height:35px;margin-right:1em}.dayInput{max-width:25%;height:35px;margin-right:1em}.yearInput{max-width:25%;height:35px}.error-container{flex-basis:100%!important}input[type=number]::-webkit-inner-spin-button,input[type=number]::-webkit-outer-spin-button{-webkit-appearance:none;-moz-appearance:none;appearance:none;margin:0}select option[selected]{color:gray!important}"]
                }] }
    ];
    /** @nocollapse */
    DateComponent.ctorParameters = function () { return [
        { type: NgForm },
        { type: ChangeDetectorRef }
    ]; };
    DateComponent.propDecorators = {
        monthRef: [{ type: ViewChild, args: ['monthRef',] }],
        dayRef: [{ type: ViewChild, args: ['dayRef',] }],
        yearRef: [{ type: ViewChild, args: ['yearRef',] }],
        useCurrentDate: [{ type: Input }],
        required: [{ type: Input }],
        disabled: [{ type: Input }],
        label: [{ type: Input }],
        date: [{ type: Input }],
        restrictDate: [{ type: Input }],
        errorMessages: [{ type: Input }],
        dateChange: [{ type: Output }]
    };
    return DateComponent;
}(Base));
export { DateComponent };
if (false) {
    /** @type {?} */
    DateComponent.prototype.monthRef;
    /** @type {?} */
    DateComponent.prototype.dayRef;
    /** @type {?} */
    DateComponent.prototype.yearRef;
    /** @type {?} */
    DateComponent.prototype.useCurrentDate;
    /** @type {?} */
    DateComponent.prototype.required;
    /** @type {?} */
    DateComponent.prototype.disabled;
    /** @type {?} */
    DateComponent.prototype.label;
    /** @type {?} */
    DateComponent.prototype.date;
    /**
     * Can be one of: "future", "past". "future" includes today, "past" does not.
     * @type {?}
     */
    DateComponent.prototype.restrictDate;
    /** @type {?} */
    DateComponent.prototype.errorMessages;
    /** @type {?} */
    DateComponent.prototype.dateChange;
    /** @type {?} */
    DateComponent.prototype.monthList;
    /**
     * @type {?}
     * @private
     */
    DateComponent.prototype.form;
    /**
     * @type {?}
     * @private
     */
    DateComponent.prototype.cd;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZGF0ZS5jb21wb25lbnQuanMiLCJzb3VyY2VSb290Ijoibmc6Ly9tb2gtY29tbW9uLWxpYi8iLCJzb3VyY2VzIjpbImxpYi9jb21wb25lbnRzL2RhdGUvZGF0ZS5jb21wb25lbnQudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBQSxPQUFPLEVBQUUsU0FBUyxFQUFVLEtBQUssRUFBRSxNQUFNLEVBQUUsWUFBWSxFQUFFLFNBQVMsRUFBYyxpQkFBaUIsRUFBRSxVQUFVLEVBQUUsTUFBTSxlQUFlLENBQUM7QUFDckksT0FBTyxFQUFFLElBQUksRUFBRSxNQUFNLDBCQUEwQixDQUFDO0FBRWhELE9BQU8sRUFBRSxnQkFBZ0IsRUFBRSxNQUFNLEVBQUUsT0FBTyxFQUFFLE1BQU0sZ0JBQWdCLENBQUM7QUFDbkUsT0FBTyxLQUFLLE9BQU8sTUFBTSxRQUFRLENBQUM7O0lBQzVCLE1BQU0sR0FBRyxPQUFPOzs7Ozs7QUFPdEIsa0NBUUM7OztJQVBDLGdDQUFpQjs7SUFDakIscUNBQXVCOztJQUN2Qix1Q0FBeUI7O0lBQ3pCLHlDQUEyQjs7SUFDM0IsMENBQTRCOztJQUM1Qiw0Q0FBOEI7O0lBQzlCLG9DQUFzQjs7QUFHeEI7SUFTbUMseUNBQUk7SUFzQnJDLHVCQUFxQixJQUFZLEVBQ1osRUFBcUI7UUFEMUMsWUFFRSxpQkFBTyxTQUNSO1FBSG9CLFVBQUksR0FBSixJQUFJLENBQVE7UUFDWixRQUFFLEdBQUYsRUFBRSxDQUFtQjtRQWpCakMsb0JBQWMsR0FBWSxLQUFLLENBQUM7UUFDaEMsY0FBUSxHQUFZLElBQUksQ0FBQztRQUN6QixjQUFRLEdBQVksS0FBSyxDQUFDO1FBQzFCLFdBQUssR0FBVyxNQUFNLENBQUM7Ozs7UUFHdkIsa0JBQVksR0FBOEIsS0FBSyxDQUFDO1FBRy9DLGdCQUFVLEdBQTZCLElBQUksWUFBWSxFQUFjLENBQUM7UUFFekUsZUFBUyxHQUFhO1lBQzNCLFNBQVMsRUFBRSxVQUFVLEVBQUUsT0FBTyxFQUFFLE9BQU8sRUFBRSxL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O0lBRWhGLGtDQUdFOzs7OztJQUVXLDZCQUFvQjs7Ozs7SUFDcEIsMkJBQTZCIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgQ29tcG9uZW50LCBPbkluaXQsIElucHV0LCBPdXRwdXQsIEV2ZW50RW1pdHRlciwgVmlld0NoaWxkLCBFbGVtZW50UmVmLCBDaGFuZ2VEZXRlY3RvclJlZiwgZm9yd2FyZFJlZiB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgQmFzZSB9IGZyb20gJy4uLy4uLy4uL21vZGVscy9zcmMvYmFzZSc7XG5pbXBvcnQgeyBTaW1wbGVEYXRlIH0gZnJvbSAnLi4vLi4vLi4vbW9kZWxzL3NyYy9zaW1wbGUtZGF0ZS5pbnRlcmZhY2UnO1xuaW1wb3J0IHsgQ29udHJvbENvbnRhaW5lciwgTmdGb3JtLCBOZ01vZGVsIH0gZnJvbSAnQGFuZ3VsYXIvZm9ybXMnO1xuaW1wb3J0ICogYXMgbW9tZW50XyBmcm9tICdtb21lbnQnO1xuY29uc3QgbW9tZW50ID0gbW9tZW50XztcblxuLyoqXG4gKiBDb21wb25lbnQgTlBNIHBhY2thZ2UgZGVwZW5kZW5jaWVzOlxuICogYSkgbW9tZW50XG4gKi9cblxuZXhwb3J0IGludGVyZmFjZSBEYXRlRXJyb3JNc2cge1xuICByZXF1aXJlZDogc3RyaW5nO1xuICBkYXlPdXRPZlJhbmdlPzogc3RyaW5nO1xuICB5ZWFyRGlzdGFudFBhc3Q/OiBzdHJpbmc7XG4gIHllYXJEaXN0YW50RnV0dXJlPzogc3RyaW5nO1xuICBub1Bhc3REYXRlc0FsbG93ZWQ/OiBzdHJpbmc7XG4gIG5vRnV0dXJlRGF0ZXNBbGxvd2VkPzogc3RyaW5nO1xuICBpbnZhbGlkVmFsdWU/OiBzdHJpbmc7XG59XG5cbkBDb21wb25lbnQoe1xuICBzZWxlY3RvcjogJ2NvbW1vbi1kYXRlJyxcbiAgdGVtcGxhdGVVcmw6ICcuL2RhdGUuY29tcG9uZW50Lmh0bWwnLFxuICBzdHlsZVVybHM6IFsnLi9kYXRlLmNvbXBvbmVudC5zY3NzJ10sXG4gIC8qIFJlLXVzZSB0aGUgc2FtZSBuZ0Zvcm0gdGhhdCBpdCdzIHBhcmVudCBpcyB1c2luZy4gVGhlIGNvbXBvbmVudCB3aWxsIHNob3dcbiAgICogdXAgaW4gaXRzIHBhcmVudHMgYHRoaXMuZm9ybWAsIGFuZCB3aWxsIGF1dG8tdXBkYXRlIGB0aGlzLmZvcm0udmFsaWRgXG4gICAqL1xuICB2aWV3UHJvdmlkZXJzOiBbIHsgcHJvdmlkZTogQ29udHJvbENvbnRhaW5lciwgdXNlRXhpc3Rpbmc6IGZvcndhcmRSZWYoKCkgPT4gTmdGb3JtICkgfSBdXG59KVxuZXhwb3J0IGNsYXNzIERhdGVDb21wb25lbnQgZXh0ZW5kcyBCYXNlIGltcGxlbWVudHMgT25Jbml0IHtcbiAgLy8gRXhpc3RzIGZvciB1bml0IHRlc3RpbmcgdG8gdmFsaWRhdGUgZXJyb3JzIHNldFxuICBAVmlld0NoaWxkKCAnbW9udGhSZWYnICkgbW9udGhSZWY6IE5nTW9kZWw7XG4gIEBWaWV3Q2hpbGQoICdkYXlSZWYnICkgZGF5UmVmOiBOZ01vZGVsO1xuICBAVmlld0NoaWxkKCAneWVhclJlZicpIHllYXJSZWY6IE5nTW9kZWw7XG5cbiAgQElucHV0KCkgdXNlQ3VycmVudERhdGU6IGJvb2xlYW4gPSBmYWxzZTtcbiAgQElucHV0KCkgcmVxdWlyZWQ6IGJvb2xlYW4gPSB0cnVlO1xuICBASW5wdXQoKSBkaXNhYmxlZDogYm9vbGVhbiA9IGZhbHNlO1xuICBASW5wdXQoKSBsYWJlbDogc3RyaW5nID0gJ0RhdGUnO1xuICBASW5wdXQoKSBkYXRlOiBTaW1wbGVEYXRlO1xuICAvKiogQ2FuIGJlIG9uZSBvZjogXCJmdXR1cmVcIiwgXCJwYXN0XCIuIFwiZnV0dXJlXCIgaW5jbHVkZXMgdG9kYXksIFwicGFzdFwiIGRvZXMgbm90LiAqL1xuICBASW5wdXQoKSByZXN0cmljdERhdGU6ICdmdXR1cmUnIHwgJ3Bhc3QnIHwgJ2FueScgPSAnYW55JztcbiAgQElucHV0KCkgZXJyb3JNZXNzYWdlczogRGF0ZUVycm9yTXNnO1xuXG4gIEBPdXRwdXQoKSBkYXRlQ2hhbmdlOiBFdmVudEVtaXR0ZXI8U2ltcGxlRGF0ZT4gPSBuZXcgRXZlbnRFbWl0dGVyPFNpbXBsZURhdGU+KCk7XG5cbiAgcHVibGljIG1vbnRoTGlzdDogc3RyaW5nW10gPSBbXG4gICAgJ0phbnVhcnknLCAnRmVicnVhcnknLCAnTWFyY2gnLCAnQXByaWwnLCAnTWF5JywgJ0p1bmUnLFxuICAgICdKdWx5JywgJ0F1Z3VzdCcsICdTZXB0ZW1iZXInLCAnT2N0b2JlcicsICdOb3ZlbWJlcicsICdEZWNlbWJlcidcbiAgXTtcblxuICBjb25zdHJ1Y3RvciggcHJpdmF0ZSBmb3JtOiBOZ0Zvcm0sXG4gICAgICAgICAgICAgICBwcml2YXRlIGNkOiBDaGFuZ2VEZXRlY3RvclJlZiApIHtcbiAgICBzdXBlcigpO1xuICB9XG5cbiAgbmdPbkluaXQoKSB7XG4gICAgaWYgKCAhdGhpcy5lcnJvck1lc3NhZ2VzICkge1xuICAgICAgLy8gVXNlIGRlZmF1bHQgbWVzc2FnZXNcbiAgICAgIHRoaXMuZXJyb3JNZXNzYWdlcyA9IHtcbiAgICAgICAgcmVxdWlyZWQ6IHRoaXMubGFiZWwgKyAnIGlzIHJlcXVpcmVkLicsXG4gICAgICAgIGRheU91dE9mUmFuZ2U6ICdJbnZhbGlkICcgKyB0aGlzLmxhYmVsICsgJy4nLFxuICAgICAgICB5ZWFyRGlzdGFudFBhc3Q6ICdJbnZhbGlkICcgKyB0aGlzLmxhYmVsICsgJy4nLFxuICAgICAgICB5ZWFyRGlzdGFudEZ1dHVyZTogJ0ludmFsaWQgJyArIHRoaXMubGFiZWwgKyAnLicsXG4gICAgICAgIG5vRnV0dXJlRGF0ZXNBbGxvd2VkOiAnSW52YWxpZCAnICsgdGhpcy5sYWJlbCArICcuJyxcbiAgICAgICAgaW52YWxpZFZhbHVlOiAnSW52YWxpZCAnICsgdGhpcy5sYWJlbCArICcuJ1xuICAgICAgfTtcbiAgICB9XG5cbiAgICBpZiAoIHRoaXMudXNlQ3VycmVudERhdGUgKSB7XG4gICAgICAvLyBTZXQgZGF0ZSB0byBjdXJyZW50IGRhdGVcbiAgICAgIHRoaXMuZGF0ZS5tb250aCA9IG1vbWVudCgpLm1vbnRoKCk7XG4gICAgICB0aGlzLmRhdGUuZGF5ID0gbW9tZW50KCkuZGF0ZSgpO1xuICAgICAgdGhpcy5kYXRlLnllYXIgPSBtb21lbnQoKS55ZWFyKCk7XG4gICAgfVxuICB9XG5cbiAgLyoqIFNldCB0aGUgbW9udGggYW5kIG5vdGlmeSBjYWxsZXIgb2YgY2hhbmdlICovXG4gIHNldE1vbnRoKCB2YWx1ZTogc3RyaW5nICk6IHZvaWQge1xuICAgIGNvbnN0IG1vbnRoID0gdGhpcy5nZXROdW1lcmljVmFsdWUoIHZhbHVlICk7XG5cbiAgICAvLyBjb25zb2xlLmxvZyggJ21vbnRoUmVmOiAnLCB0aGlzLm1vbnRoUmVmICk7XG4gICAgaWYgKCB0aGlzLmRhdGUgKSB7XG4gICAgICB0aGlzLmRhdGUubW9udGggPSBtb250aDtcbiAgICAgIHRoaXMudHJpZ2dlckRheVZhbGlkYXRpb24oKTtcbiAgICAgIHRoaXMuZGF0ZUNoYW5nZS5lbWl0KCB0aGlzLmRhdGUgKTtcbiAgICB9XG4gIH1cblxuICAvKiogU2V0IHRoZSBkYXkgYW5kIG5vdGlmeSBjYWxsZXIgb2YgY2hhbmdlICovXG4gIHNldERheSggdmFsdWU6IHN0cmluZyApOiB2b2lkIHtcbiAgICBjb25zdCBkYXkgPSB0aGlzLmdldE51bWVyaWNWYWx1ZSggdmFsdWUgKTtcblxuICAgIC8vIGNvbnNvbGUubG9nKCAgJ2RheVJlZjogJywgdGhpcy5kYXlSZWYgKTtcbiAgICBpZiAoIHRoaXMuZGF0ZSApIHtcbiAgICAgIHRoaXMuZGF0ZS5kYXkgPSBkYXk7XG4gICAgICB0aGlzLmRhdGVDaGFuZ2UuZW1pdCggdGhpcy5kYXRlICk7XG4gICAgfVxuICB9XG5cbiAgLyoqIFNldCB0aGUgeWVyYSBhbmQgbm90aWZ5IGNhbGxlciBvZiBjaGFuZ2UgKi9cbiAgc2V0WWVhciggdmFsdWU6IHN0cmluZyApOiB2b2lkIHtcbiAgICBjb25zdCB5ZWFyID0gdGhpcy5nZXROdW1lcmljVmFsdWUoIHZhbHVlICk7XG5cbiAgICAvLyBjb25zb2xlLmxvZyggJ3llYXJSZWY6ICcsIHRoaXMueWVhclJlZiApO1xuICAgIGlmICggdGhpcy5kYXRlICkge1xuICAgICAgdGhpcy5kYXRlLnllYXIgPSB5ZWFyO1xuICAgICAgdGhpcy50cmlnZ2VyRGF5VmFsaWRhdGlvbigpO1xuICAgICAgdGhpcy5kYXRlQ2hhbmdlLmVtaXQoIHRoaXMuZGF0ZSApO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBGb3JjZSB0aGUgYGRheWAgaW5wdXQgdG8gcnVuIGl0J3MgZGlyZWN0aXZlcyBhZ2Fpbi4gSW1wb3J0YW50IGluIGNhc2VzXG4gICAqIHdoZXJlIHVzZXIgZmlsbHMgZmllbGRzIG91dCBvZiBvcmRlciwgZS5nLiBzZXRzIGRheXMgdG8gMzEgdGhlbiBtb250aCB0b1xuICAgKiBGZWJydXJhcnkuXG4gICAqL1xuICBwcml2YXRlIHRyaWdnZXJEYXlWYWxpZGF0aW9uKCkge1xuICAgIC8vIFdlIGhhdmUgdG8gd3JhcCB0aGlzIGluIGEgdGltZW91dCwgb3RoZXJ3aXNlIGl0IHJ1bnMgYmVmb3JlIEFuZ3VsYXIgaGFzIHVwZGF0ZWQgdGhlIHZhbHVlc1xuICAgIHNldFRpbWVvdXQoICgpID0+IHtcbiAgICAgIGlmICggdGhpcy5mb3JtLmNvbnRyb2xzWydkYXknXSApIHtcbiAgICAgICAgLy8gY29uc29sZS5sb2coICdUcmlnZ2VyIGRheSB2YWxpZGF0aW9uJyApO1xuICAgICAgICB0aGlzLmZvcm0uY29udHJvbHNbJ2RheSddLnVwZGF0ZVZhbHVlQW5kVmFsaWRpdHkoKTtcbiAgICAgICAgdGhpcy5jZC5kZXRlY3RDaGFuZ2VzKCk7XG4gICAgICB9XG4gICAgfSwgMCk7XG4gIH1cblxuICAvKiogQ29udmVydCBzdHJpbmcgdG8gbnVtZXJpYyB2YWx1ZSBvciBudWxsIGlmIG5vdCAqL1xuICBwcml2YXRlIGdldE51bWVyaWNWYWx1ZSggdmFsdWU6IHN0cmluZyApOiBudW1iZXIgfCBudWxsIHtcbiAgICBjb25zdCBwYXJzZWQgPSBwYXJzZUludCggdmFsdWUsIDEwICk7XG4gICAgcmV0dXJuICggaXNOYU4oIHBhcnNlZCApID8gbnVsbCA6IHBhcnNlZCApO1xuICB9XG59XG4iXX0=