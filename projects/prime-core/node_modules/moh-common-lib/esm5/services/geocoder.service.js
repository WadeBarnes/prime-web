/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
import * as tslib_1 from "tslib";
import { Injectable } from '@angular/core';
import { AbstractHttpService } from './abstract-api-service';
import { HttpClient, HttpHeaders, HttpParams } from '@angular/common/http';
import { map } from 'rxjs/operators';
import { throwError } from 'rxjs';
import * as i0 from "@angular/core";
import * as i1 from "@angular/common/http";
/**
 * @record
 */
export function GeoAddressResult() { }
if (false) {
    /**
     * String from the API that includes street, city, province, and country.
     * @type {?}
     */
    GeoAddressResult.prototype.fullAddress;
    /** @type {?} */
    GeoAddressResult.prototype.city;
    /** @type {?} */
    GeoAddressResult.prototype.street;
    /** @type {?} */
    GeoAddressResult.prototype.country;
    /** @type {?} */
    GeoAddressResult.prototype.province;
}
var GeocoderService = /** @class */ (function (_super) {
    tslib_1.__extends(GeocoderService, _super);
    function GeocoderService(http) {
        var _this = _super.call(this, http) || this;
        _this.http = http;
        _this._headers = new HttpHeaders();
        _this.BASE_URL = 'https://geocoder.api.gov.bc.ca';
        _this.ADDRESS_URL = _this.BASE_URL + "/addresses.json?";
        /**
         * Defaults for service
         */
        _this.defaultCountry = 'Canada';
        _this.defaultProv = 'British Columbia';
        return _this;
    }
    // https://geocoder.api.gov.bc.ca/addresses.json?minScore=50&maxResults=5&echo=false&brief=true&autoComplete=true&addressString=784+Hock
    // https://geocoder.api.gov.bc.ca/addresses.json?minScore=50&maxResults=5&echo=false&brief=true&autoComplete=true&addressString=784+Hock
    /**
     * @param {?} address
     * @return {?}
     */
    GeocoderService.prototype.lookup = 
    // https://geocoder.api.gov.bc.ca/addresses.json?minScore=50&maxResults=5&echo=false&brief=true&autoComplete=true&addressString=784+Hock
    /**
     * @param {?} address
     * @return {?}
     */
    function (address) {
        /** @type {?} */
        var params = new HttpParams()
            .set('minScore', '50')
            .set('maxResults', '10')
            .set('echo', 'false')
            .set('brief', 'false') // API splits address string up into sub-attributes, like city  / street name
            .set('autoComplete', 'true')
            .set('matchPrecisionNot', 'LOCALITY,STREET,BLOCK,INTERSECTION')
            .set('addressString', address);
        return this.get(this.ADDRESS_URL, params).pipe(map(this.processResponse));
    };
    /**
     * Formats the response from ADDRESS_URL, trimming irrelevant fields.
     *
     * This works for other requests for the same API too, however it may error
     * out on some items if matchPrecisionNot is not set.
     *
     * @param obj The response from ADDRESS_URL
     */
    /**
     * Formats the response from ADDRESS_URL, trimming irrelevant fields.
     *
     * This works for other requests for the same API too, however it may error
     * out on some items if matchPrecisionNot is not set.
     *
     * @private
     * @param {?} obj The response from ADDRESS_URL
     * @return {?}
     */
    GeocoderService.prototype.processResponse = /**
     * Formats the response from ADDRESS_URL, trimming irrelevant fields.
     *
     * This works for other requests for the same API too, however it may error
     * out on some items if matchPrecisionNot is not set.
     *
     * @private
     * @param {?} obj The response from ADDRESS_URL
     * @return {?}
     */
    function (obj) {
        var _this = this;
        return obj.features.map((/**
         * @param {?} feature
         * @return {?}
         */
        function (feature) {
            /** @type {?} */
            var props = feature.properties;
            /** @type {?} */
            var city = props.localityName;
            // We get street just by trimming everything before city, more
            // stable than looking for commas, etc.
            /** @type {?} */
            var cityIndex = props.fullAddress.indexOf(", " + city);
            /** @type {?} */
            var street = props.fullAddress.slice(0, cityIndex);
            return {
                fullAddress: props.fullAddress,
                city: city,
                street: street,
                country: _this.defaultCountry,
                // Default to Canada
                province: _this.defaultProv // Default to BC
            };
        }));
    };
    /**
     * @protected
     * @param {?} error
     * @return {?}
     */
    GeocoderService.prototype.handleError = /**
     * @protected
     * @param {?} error
     * @return {?}
     */
    function (error) {
        console.error('GeoCoder network error', { error: error });
        return throwError('Geocoder error');
    };
    GeocoderService.decorators = [
        { type: Injectable, args: [{
                    providedIn: 'root'
                },] }
    ];
    /** @nocollapse */
    GeocoderService.ctorParameters = function () { return [
        { type: HttpClient }
    ]; };
    /** @nocollapse */ GeocoderService.ngInjectableDef = i0.defineInjectable({ factory: function GeocoderService_Factory() { return new GeocoderService(i0.inject(i1.HttpClient)); }, token: GeocoderService, providedIn: "root" });
    return GeocoderService;
}(AbstractHttpService));
export { GeocoderService };
if (false) {
    /**
     * @type {?}
     * @protected
     */
    GeocoderService.prototype._headers;
    /**
     * @type {?}
     * @private
     */
    GeocoderService.prototype.BASE_URL;
    /**
     * @type {?}
     * @private
     */
    GeocoderService.prototype.ADDRESS_URL;
    /**
     * Defaults for service
     * @type {?}
     */
    GeocoderService.prototype.defaultCountry;
    /** @type {?} */
    GeocoderService.prototype.defaultProv;
    /**
     * @type {?}
     * @protected
     */
    GeocoderService.prototype.http;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZ2VvY29kZXIuc2VydmljZS5qcyIsInNvdXJjZVJvb3QiOiJuZzovL21vaC1jb21tb24tbGliL3NlcnZpY2VzLyIsInNvdXJjZXMiOlsiZ2VvY29kZXIuc2VydmljZS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7OztBQUFBLE9BQU8sRUFBRSxVQUFVLEVBQUUsTUFBTSxlQUFlLENBQUM7QUFDM0MsT0FBTyxFQUFFLG1CQUFtQixFQUFFLE1BQU0sd0JBQXdCLENBQUM7QUFDN0QsT0FBTyxFQUFFLFVBQVUsRUFBRSxXQUFXLEVBQXFCLFVBQVUsRUFBRSxNQUFNLHNCQUFzQixDQUFDO0FBQzlGLE9BQU8sRUFBRSxHQUFHLEVBQUUsTUFBTSxnQkFBZ0IsQ0FBQztBQUNyQyxPQUFPLEVBQWMsVUFBVSxFQUFFLE1BQU0sTUFBTSxDQUFDOzs7Ozs7QUFFOUMsc0NBUUM7Ozs7OztJQU5HLHVDQUFvQjs7SUFDcEIsZ0NBQWE7O0lBQ2Isa0NBQWU7O0lBRWYsbUNBQWdCOztJQUNoQixvQ0FBaUI7O0FBR3JCO0lBR3FDLDJDQUFtQjtJQVdwRCx5QkFBc0IsSUFBZ0I7UUFBdEMsWUFDSSxrQkFBTSxJQUFJLENBQUMsU0FDZDtRQUZxQixVQUFJLEdBQUosSUFBSSxDQUFZO1FBVDVCLGNBQVEsR0FBZ0IsSUFBSSxXQUFXLEVBQUUsQ0FBQztRQUM1QyxjQUFRLEdBQUcsZ0NBQWdDLENBQUM7UUFDNUMsaUJBQVcsR0FBTSxLQUFJLENBQUMsUUFBUSxxQkFBa0IsQ0FBQzs7OztRQUlsRCxvQkFBYyxHQUFXLFFBQVEsQ0FBQztRQUNsQyxpQkFBVyxHQUFXLGtCQUFrQixDQUFDOztJQUloRCxDQUFDO0lBR0Qsd0lBQXdJOzs7Ozs7SUFDeEksZ0NBQU07Ozs7OztJQUFOLFVBQU8sT0FBZTs7WUFDWixNQUFNLEdBQUcsSUFBSSxVQUFVLEVBQUU7YUFDMUIsR0FBRyxDQUFDLFVBQVUsRUFBRSxJQUFJLENBQUM7YUFDckIsR0FBRyxDQUFDLFlBQVksRUFBRSxJQUFJLENBQUM7YUFDdkIsR0FBRyxDQUFDLE1BQU0sRUFBRSxPQUFPLENBQUM7YUFDcEIsR0FBRyxDQUFDLE9BQU8sRUFBRSxPQUFPLENBQUMsQ0FBQyw2RUFBNkU7YUFDbkcsR0FBRyxDQUFDLGNBQWMsRUFBRSxNQUFNLENBQUM7YUFDM0IsR0FBRyxDQUFDLG1CQUFtQixFQUFFLG9DQUFvQyxDQUFDO2FBQzlELEdBQUcsQ0FBQyxlQUFlLEVBQUUsT0FBTyxDQUFDO1FBRWxDLE9BQU8sSUFBSSxDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUMsV0FBVyxFQUFFLE1BQU0sQ0FBQyxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLGVBQWUsQ0FBQyxDQUFDLENBQUM7SUFDOUUsQ0FBQztJQUVEOzs7Ozs7O09BT0c7Ozs7Ozs7Ozs7O0lBQ0sseUNBQWU7Ozs7Ozs7Ozs7SUFBdkIsVUFBd0IsR0FBRztRQUEzQixpQkFnQkM7UUFmRyxPQUFPLEdBQUcsQ0FBQyxRQUFRLENBQUMsR0FBRzs7OztRQUFDLFVBQUEsT0FBTzs7Z0JBQ3JCLEtBQUssR0FBRyxPQUFPLENBQUMsVUFBVTs7Z0JBQzFCLElBQUksR0FBRyxLQUFLLENBQUMsWUFBWTs7OztnQkFHekIsU0FBUyxHQUFHLEtBQUssQ0FBQyxXQUFXLENBQUMsT0FBTyxDQUFDLE9BQUssSUFBTSxDQUFDOztnQkFDbEQsTUFBTSxHQUFHLEtBQUssQ0FBQyxXQUFXLENBQUMsS0FBSyxDQUFDLENBQUMsRUFBRSxTQUFTLENBQUM7WUFDcEQsT0FBTztnQkFDSCxXQUFXLEVBQUUsS0FBSyxDQUFDLFdBQVc7Z0JBQzlCLElBQUksTUFBQTtnQkFDSixNQUFNLFFBQUE7Z0JBQ04sT0FBTyxFQUFFLEtBQUksQ0FBQyxjQUFjOztnQkFDNUIsUUFBUSxFQUFFLEtBQUksQ0FBQyxXQUFXLENBQUksZ0JBQWdCO2FBQ2pELENBQUM7UUFDTixDQUFDLEVBQUMsQ0FBQztJQUNQLENBQUM7Ozs7OztJQUVTLHFDQUFXOzs7OztJQUFyQixVQUFzQixLQUF3QjtRQUMxQyxPQUFPLENBQUMsS0FBSyxDQUFDLHdCQUF3QixFQUFFLEVBQUUsS0FBSyxPQUFBLEVBQUUsQ0FBQyxDQUFDO1FBQ25ELE9BQU8sVUFBVSxDQUFDLGdCQUFnQixDQUFDLENBQUM7SUFDeEMsQ0FBQzs7Z0JBOURKLFVBQVUsU0FBQztvQkFDUixVQUFVLEVBQUUsTUFBTTtpQkFDckI7Ozs7Z0JBaEJRLFVBQVU7OzswQkFGbkI7Q0ErRUMsQUEvREQsQ0FHcUMsbUJBQW1CLEdBNER2RDtTQTVEWSxlQUFlOzs7Ozs7SUFFeEIsbUNBQW9EOzs7OztJQUNwRCxtQ0FBb0Q7Ozs7O0lBQ3BELHNDQUF5RDs7Ozs7SUFJekQseUNBQXlDOztJQUN6QyxzQ0FBZ0Q7Ozs7O0lBRXBDLCtCQUEwQiIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEluamVjdGFibGUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IEFic3RyYWN0SHR0cFNlcnZpY2UgfSBmcm9tICcuL2Fic3RyYWN0LWFwaS1zZXJ2aWNlJztcbmltcG9ydCB7IEh0dHBDbGllbnQsIEh0dHBIZWFkZXJzLCBIdHRwRXJyb3JSZXNwb25zZSwgSHR0cFBhcmFtcyB9IGZyb20gJ0Bhbmd1bGFyL2NvbW1vbi9odHRwJztcbmltcG9ydCB7IG1hcCB9IGZyb20gJ3J4anMvb3BlcmF0b3JzJztcbmltcG9ydCB7IE9ic2VydmFibGUsIHRocm93RXJyb3IgfSBmcm9tICdyeGpzJztcblxuZXhwb3J0IGludGVyZmFjZSBHZW9BZGRyZXNzUmVzdWx0IHtcbiAgICAvKiogU3RyaW5nIGZyb20gdGhlIEFQSSB0aGF0IGluY2x1ZGVzIHN0cmVldCwgY2l0eSwgcHJvdmluY2UsIGFuZCBjb3VudHJ5LiAqL1xuICAgIGZ1bGxBZGRyZXNzOiBzdHJpbmc7XG4gICAgY2l0eTogc3RyaW5nO1xuICAgIHN0cmVldDogc3RyaW5nO1xuICAgIC8vIFNldCB0byBkZWZhdWx0cyBpbiByZXNwb25zZVxuICAgIGNvdW50cnk6IHN0cmluZztcbiAgICBwcm92aW5jZTogc3RyaW5nO1xufVxuXG5ASW5qZWN0YWJsZSh7XG4gICAgcHJvdmlkZWRJbjogJ3Jvb3QnXG59KVxuZXhwb3J0IGNsYXNzIEdlb2NvZGVyU2VydmljZSBleHRlbmRzIEFic3RyYWN0SHR0cFNlcnZpY2Uge1xuXG4gICAgcHJvdGVjdGVkIF9oZWFkZXJzOiBIdHRwSGVhZGVycyA9IG5ldyBIdHRwSGVhZGVycygpO1xuICAgIHByaXZhdGUgQkFTRV9VUkwgPSAnaHR0cHM6Ly9nZW9jb2Rlci5hcGkuZ292LmJjLmNhJztcbiAgICBwcml2YXRlIEFERFJFU1NfVVJMID0gYCR7dGhpcy5CQVNFX1VSTH0vYWRkcmVzc2VzLmpzb24/YDtcblxuXG4gICAgLyoqIERlZmF1bHRzIGZvciBzZXJ2aWNlICovXG4gICAgcHVibGljIGRlZmF1bHRDb3VudHJ5OiBzdHJpbmcgPSAnQ2FuYWRhJztcbiAgICBwdWJsaWMgZGVmYXVsdFByb3Y6IHN0cmluZyA9ICdCcml0aXNoIENvbHVtYmlhJztcblxuICAgIGNvbnN0cnVjdG9yKHByb3RlY3RlZCBodHRwOiBIdHRwQ2xpZW50KSB7XG4gICAgICAgIHN1cGVyKGh0dHApO1xuICAgIH1cblxuXG4gICAgLy8gaHR0cHM6Ly9nZW9jb2Rlci5hcGkuZ292LmJjLmNhL2FkZHJlc3Nlcy5qc29uP21pblNjb3JlPTUwJm1heFJlc3VsdHM9NSZlY2hvPWZhbHNlJmJyaWVmPXRydWUmYXV0b0NvbXBsZXRlPXRydWUmYWRkcmVzc1N0cmluZz03ODQrSG9ja1xuICAgIGxvb2t1cChhZGRyZXNzOiBzdHJpbmcpOiBPYnNlcnZhYmxlPEdlb0FkZHJlc3NSZXN1bHRbXT4ge1xuICAgICAgICBjb25zdCBwYXJhbXMgPSBuZXcgSHR0cFBhcmFtcygpXG4gICAgICAgICAgICAuc2V0KCdtaW5TY29yZScsICc1MCcpXG4gICAgICAgICAgICAuc2V0KCdtYXhSZXN1bHRzJywgJzEwJylcbiAgICAgICAgICAgIC5zZXQoJ2VjaG8nLCAnZmFsc2UnKVxuICAgICAgICAgICAgLnNldCgnYnJpZWYnLCAnZmFsc2UnKSAvLyBBUEkgc3BsaXRzIGFkZHJlc3Mgc3RyaW5nIHVwIGludG8gc3ViLWF0dHJpYnV0ZXMsIGxpa2UgY2l0eSAgLyBzdHJlZXQgbmFtZVxuICAgICAgICAgICAgLnNldCgnYXV0b0NvbXBsZXRlJywgJ3RydWUnKVxuICAgICAgICAgICAgLnNldCgnbWF0Y2hQcmVjaXNpb25Ob3QnLCAnTE9DQUxJVFksU1RSRUVULEJMT0NLLElOVEVSU0VDVElPTicpXG4gICAgICAgICAgICAuc2V0KCdhZGRyZXNzU3RyaW5nJywgYWRkcmVzcyk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0KHRoaXMuQUREUkVTU19VUkwsIHBhcmFtcykucGlwZShtYXAodGhpcy5wcm9jZXNzUmVzcG9uc2UpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBGb3JtYXRzIHRoZSByZXNwb25zZSBmcm9tIEFERFJFU1NfVVJMLCB0cmltbWluZyBpcnJlbGV2YW50IGZpZWxkcy5cbiAgICAgKlxuICAgICAqIFRoaXMgd29ya3MgZm9yIG90aGVyIHJlcXVlc3RzIGZvciB0aGUgc2FtZSBBUEkgdG9vLCBob3dldmVyIGl0IG1heSBlcnJvclxuICAgICAqIG91dCBvbiBzb21lIGl0ZW1zIGlmIG1hdGNoUHJlY2lzaW9uTm90IGlzIG5vdCBzZXQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gb2JqIFRoZSByZXNwb25zZSBmcm9tIEFERFJFU1NfVVJMXG4gICAgICovXG4gICAgcHJpdmF0ZSBwcm9jZXNzUmVzcG9uc2Uob2JqKTogR2VvQWRkcmVzc1Jlc3VsdFtdIHtcbiAgICAgICAgcmV0dXJuIG9iai5mZWF0dXJlcy5tYXAoZmVhdHVyZSA9PiB7XG4gICAgICAgICAgICBjb25zdCBwcm9wcyA9IGZlYXR1cmUucHJvcGVydGllcztcbiAgICAgICAgICAgIGNvbnN0IGNpdHkgPSBwcm9wcy5sb2NhbGl0eU5hbWU7XG4gICAgICAgICAgICAvLyBXZSBnZXQgc3RyZWV0IGp1c3QgYnkgdHJpbW1pbmcgZXZlcnl0aGluZyBiZWZvcmUgY2l0eSwgbW9yZVxuICAgICAgICAgICAgLy8gc3RhYmxlIHRoYW4gbG9va2luZyBmb3IgY29tbWFzLCBldGMuXG4gICAgICAgICAgICBjb25zdCBjaXR5SW5kZXggPSBwcm9wcy5mdWxsQWRkcmVzcy5pbmRleE9mKGAsICR7Y2l0eX1gKTtcbiAgICAgICAgICAgIGNvbnN0IHN0cmVldCA9IHByb3BzLmZ1bGxBZGRyZXNzLnNsaWNlKDAsIGNpdHlJbmRleCk7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGZ1bGxBZGRyZXNzOiBwcm9wcy5mdWxsQWRkcmVzcyxcbiAgICAgICAgICAgICAgICBjaXR5LFxuICAgICAgICAgICAgICAgIHN0cmVldCxcbiAgICAgICAgICAgICAgICBjb3VudHJ5OiB0aGlzLmRlZmF1bHRDb3VudHJ5LCAvLyBEZWZhdWx0IHRvIENhbmFkYVxuICAgICAgICAgICAgICAgIHByb3ZpbmNlOiB0aGlzLmRlZmF1bHRQcm92ICAgIC8vIERlZmF1bHQgdG8gQkNcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIHByb3RlY3RlZCBoYW5kbGVFcnJvcihlcnJvcjogSHR0cEVycm9yUmVzcG9uc2UpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcignR2VvQ29kZXIgbmV0d29yayBlcnJvcicsIHsgZXJyb3IgfSk7XG4gICAgICAgIHJldHVybiB0aHJvd0Vycm9yKCdHZW9jb2RlciBlcnJvcicpO1xuICAgIH1cbn1cbiJdfQ==