import { catchError, tap, map } from 'rxjs/operators';
import { Injectable, defineInjectable, inject } from '@angular/core';
import { HttpClient, HttpHeaders, HttpParams } from '@angular/common/http';
import { throwError } from 'rxjs';
import * as moment_ from 'moment';

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * Abstract class for HTTP Service
 * @abstract
 */
class AbstractHttpService {
    /**
     * @param {?} http
     */
    constructor(http) {
        this.http = http;
        this.logHTTPRequestsToConsole = false;
    }
    /**
     * Makes a GET request to the specified URL, using headers and HTTP options specified in their respective methods.
     * @protected
     * @template T
     * @param {?} url Target URL to make the GET request
     * @param {?=} queryParams
     * @return {?}
     */
    get(url, queryParams) {
        /**
         * The HTTP request observer with always on error handling
         * @type {?}
         */
        const httpOpts = this.httpOptions;
        httpOpts.params = queryParams ? queryParams : undefined;
        /** @type {?} */
        const observable = this.http.get(url, httpOpts);
        return this.setupRequest(observable);
    }
    /**
     * @protected
     * @template T
     * @param {?} url
     * @param {?} body
     * @return {?}
     */
    post(url, body) {
        if (this.logHTTPRequestsToConsole) {
            console.log('Post Request: ', body);
        }
        /** @type {?} */
        const observable = this.http.post(url, body, this.httpOptions);
        return this.setupRequest(observable);
    }
    /**
     * @protected
     * @template T
     * @param {?} observable
     * @return {?}
     */
    setupRequest(observable) {
        // All failed requests should trigger the abstract method handleError
        observable = observable.pipe(catchError(this.handleError.bind(this)));
        // Optionally add console logging
        if (this.logHTTPRequestsToConsole) {
            observable = observable.pipe(tap((/**
             * @param {?} data
             * @return {?}
             */
            data => console.log('HTTP Success: ', data)), (/**
             * @param {?} error
             * @return {?}
             */
            error => console.log('HTTP Error: ', error))));
        }
        return observable;
    }
    /**
     * The HttpOptions object that Angular takes for GET and POST requests. Used in every HTTP request from this service.
     * @protected
     * @return {?}
     */
    get httpOptions() {
        return {
            headers: this._headers
        };
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class GeocoderService extends AbstractHttpService {
    /**
     * @param {?} http
     */
    constructor(http) {
        super(http);
        this.http = http;
        this._headers = new HttpHeaders();
        this.BASE_URL = 'https://geocoder.api.gov.bc.ca';
        this.ADDRESS_URL = `${this.BASE_URL}/addresses.json?`;
        /**
         * Defaults for service
         */
        this.defaultCountry = 'Canada';
        this.defaultProv = 'British Columbia';
    }
    // https://geocoder.api.gov.bc.ca/addresses.json?minScore=50&maxResults=5&echo=false&brief=true&autoComplete=true&addressString=784+Hock
    /**
     * @param {?} address
     * @return {?}
     */
    lookup(address) {
        /** @type {?} */
        const params = new HttpParams()
            .set('minScore', '50')
            .set('maxResults', '10')
            .set('echo', 'false')
            .set('brief', 'false') // API splits address string up into sub-attributes, like city  / street name
            .set('autoComplete', 'true')
            .set('matchPrecisionNot', 'LOCALITY,STREET,BLOCK,INTERSECTION')
            .set('addressString', address);
        return this.get(this.ADDRESS_URL, params).pipe(map(this.processResponse));
    }
    /**
     * Formats the response from ADDRESS_URL, trimming irrelevant fields.
     *
     * This works for other requests for the same API too, however it may error
     * out on some items if matchPrecisionNot is not set.
     *
     * @private
     * @param {?} obj The response from ADDRESS_URL
     * @return {?}
     */
    processResponse(obj) {
        return obj.features.map((/**
         * @param {?} feature
         * @return {?}
         */
        feature => {
            /** @type {?} */
            const props = feature.properties;
            /** @type {?} */
            const city = props.localityName;
            // We get street just by trimming everything before city, more
            // stable than looking for commas, etc.
            /** @type {?} */
            const cityIndex = props.fullAddress.indexOf(`, ${city}`);
            /** @type {?} */
            const street = props.fullAddress.slice(0, cityIndex);
            return {
                fullAddress: props.fullAddress,
                city,
                street,
                country: this.defaultCountry,
                // Default to Canada
                province: this.defaultProv // Default to BC
            };
        }));
    }
    /**
     * @protected
     * @param {?} error
     * @return {?}
     */
    handleError(error) {
        console.error('GeoCoder network error', { error });
        return throwError('Geocoder error');
    }
}
GeocoderService.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root'
            },] }
];
/** @nocollapse */
GeocoderService.ctorParameters = () => [
    { type: HttpClient }
];
/** @nocollapse */ GeocoderService.ngInjectableDef = defineInjectable({ factory: function GeocoderService_Factory() { return new GeocoderService(inject(HttpClient)); }, token: GeocoderService, providedIn: "root" });

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const moment = moment_;
class CommonLogger extends AbstractHttpService {
    /**
     * @param {?} http
     */
    constructor(http) {
        super(http);
        this.http = http;
        /**
         * The HTTP Headers which go with each request.  These MUST be set if you are
         * using the logger.  Fields include:
         *
         * - program (REQUIRED, the application wide code)
         * - applicationId (REQUIRED, like sessionId)
         * - request_method (REQUIRED, 'POST')
         * - logsource: (REQUIRED, window.location.hostname)
         * - http_x_forwarded_host (REQUIRED, window.location.hostname)
         *
         */
        this._headers = new HttpHeaders({
            request_method: 'POST',
            logsource: window.location.hostname,
            http_x_forwarded_host: window.location.hostname
        });
        this.url = null;
    }
    /**
     * @param {?} id
     * @return {?}
     */
    set applicationId(id) {
        this._headers = this._headers.set('applicationId', id);
    }
    /**
     * @return {?}
     */
    get applicationId() {
        return this._headers.get('applicationId');
    }
    /**
     * @param {?} name
     * @return {?}
     */
    set programName(name) {
        this._headers = this._headers.set('program', name);
    }
    /**
     * @return {?}
     */
    get programName() {
        return this._headers.get('name');
    }
    /**
     * @param {?} newURL
     * @return {?}
     */
    setURL(newURL) {
        this.url = newURL;
    }
    /**
     * @param {?} message
     * @return {?}
     */
    log(message) {
        this._log((/** @type {?} */ (message)));
    }
    /**
     * @param {?} errorMessage
     * @return {?}
     */
    logError(errorMessage) {
        this._logError((/** @type {?} */ (errorMessage)));
    }
    /**
     * Log a message to Splunk. This is the main way to send logs and
     * automatically includes meta-data. You do **not** need to subscribe to the
     * response, as the service already does that. The input object must have an
     * 'event' property set, everything else is optional.
     *
     * Example:
     * ```
     * this.logService.log({
     * event: 'submission',
     * dateObj: new Date()
     * });
     * ```
     * @protected
     * @param {?} message A JavaScript object, nesting is fine, with `event` property
     * set.
     * @return {?}
     */
    _log(message) {
        this.setSeverity(SeverityLevels.INFO);
        return this._sendLog(message);
    }
    /**
     * @protected
     * @param {?} errorMessage
     * @return {?}
     */
    _logError(errorMessage) {
        this.setSeverity(SeverityLevels.ERROR);
        return this._sendLog(errorMessage);
    }
    /**
     * Log HTTP errors, e.g. when losing network connectivity or receiving an
     * error response code.
     * @param {?} error
     * @return {?}
     */
    logHttpError(error) {
        return this._logError({
            event: 'error',
            message: error.message,
            errorName: error.name,
            statusText: error.statusText
        });
    }
    /**
     * Internal method to send logs to Splunk, includes meta-data except that's
     * consistent across all requests, but not specific values like severity
     * level.
     *
     * @private
     * @param {?} message A JavaScript object or anything that can be toString()'d,
     * like Date
     * @return {?}
     */
    _sendLog(message) {
        // Update headers
        this.setTimestamp();
        this.setTags(message.event);
        if (this.url === null) {
            /** @type {?} */
            const msg = 'Unable to send logs as URL as not been set via setURL()';
            console.error(msg);
            return throwError(msg);
        }
        // Configure request
        /** @type {?} */
        const body = { message: message };
        // We call .subscribe() here because we don't care about the response and
        // we want to ensure that we never forget to call subscribe.
        return this.post(this.url, body).subscribe();
    }
    /**
     * @protected
     * @param {?} error
     * @return {?}
     */
    handleError(error) {
        console.log('logService handleError()', error);
        if (error.error instanceof ErrorEvent) {
            // Client-side / network error occured
            console.error('An error occured: ', error.error.message);
        }
        else {
            // The backend returned an unsuccessful response code
            console.error(`Backend returned error code: ${error.status}.  Error body: ${error.error}`);
        }
        return throwError(error);
    }
    /**
     * Overwrite the inherited httpOptions so we can set responseType to text.
     * This updates Angular's parsing, and it won't error out due to the server
     * not responding with JSON.
     * @protected
     * @return {?}
     */
    get httpOptions() {
        return {
            headers: this._headers,
            responseType: 'text'
        };
    }
    /**
     * @private
     * @return {?}
     */
    setTimestamp() {
        this._headers = this._headers.set('timestamp', moment().toISOString());
    }
    /**
     * @private
     * @param {?} severity
     * @return {?}
     */
    setSeverity(severity) {
        this._headers = this._headers.set('severity', severity);
    }
    /**
     * The headers are easier to search in splunk, and we aren't using tags, so
     * repurpose it to event type.
     * @private
     * @param {?} message
     * @return {?}
     */
    setTags(message) {
        this._headers = this._headers.set('tags', message);
    }
}
CommonLogger.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root'
            },] }
];
/** @nocollapse */
CommonLogger.ctorParameters = () => [
    { type: HttpClient }
];
/** @nocollapse */ CommonLogger.ngInjectableDef = defineInjectable({ factory: function CommonLogger_Factory() { return new CommonLogger(inject(HttpClient)); }, token: CommonLogger, providedIn: "root" });
/** @enum {string} */
const SeverityLevels = {
    INFO: 'info',
    ERROR: 'error',
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

export { GeocoderService, AbstractHttpService, CommonLogger };

//# sourceMappingURL=moh-common-lib-services.js.map